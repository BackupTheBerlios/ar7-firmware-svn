Index: toolchain/gcc/Config.in
===================================================================
--- toolchain/gcc/Config.in	(Revision 3803)
+++ toolchain/gcc/Config.in	(Arbeitskopie)
@@ -12,11 +12,9 @@
 # these manually ... annoying.
 config BR2_GCC_VERSION_3_4_4
 	bool
-	default y if BR2_LINUX_2_4_BRCM
 
 config BR2_GCC_VERSION_4_0_3
 	bool
-	default y if BR2_LINUX_2_6_ARUBA || BR2_LINUX_2_6_XSCALE
 
 config BR2_GCC_VERSION_4_1_0
 	bool
Index: .config
===================================================================
--- .config	(Revision 0)
+++ .config	(Revision 0)
@@ -0,0 +1,1288 @@
+#
+# Automatically generated make config: don't edit
+#
+MODULES=y
+BR2_HAVE_DOT_CONFIG=y
+BR2_mipsel=y
+BR2_ARCH="mipsel"
+BR2_WGET="wget --passive-ftp -nd"
+# BR2_TAR_VERBOSITY is not set
+BR2_JLEVEL=1
+# BR2_LINUX_2_6_AU1000 is not set
+# BR2_LINUX_2_6_ARUBA is not set
+# BR2_LINUX_2_4_AR531X is not set
+# BR2_LINUX_2_4_BRCM is not set
+# BR2_LINUX_2_6_BRCM is not set
+# BR2_LINUX_2_6_XSCALE is not set
+BR2_LINUX_2_4_AR7=y
+# BR2_LINUX_2_4_X86 is not set
+# BR2_LINUX_2_6_X86 is not set
+# BR2_LINUX_2_6_SIBYTE is not set
+# BR2_LINUX_2_6_MIPS64 is not set
+# BR2_LINUX_2_6_ARM is not set
+# BR2_LINUX_2_6_CRIS is not set
+# BR2_LINUX_2_6_M68K is not set
+# BR2_LINUX_2_6_PPC is not set
+# BR2_LINUX_2_6_SH3 is not set
+# BR2_LINUX_2_6_SH3EB is not set
+# BR2_LINUX_2_6_SH4 is not set
+# BR2_LINUX_2_6_SH4EB is not set
+# BR2_LINUX_2_6_SPARC is not set
+# BR2_LINUX_2_4_WAX is not set
+# BR2_LINUX_2_4_GIGASET is not set
+BR2_LINUX_2_4_SINUS154=y
+
+#
+# Device variants
+#
+BR2_LINUX_2_4_SINUS154_DSL_BASIC_SE=y
+BR2_LINUX_2_4_SINUS154_DSL_BASIC_3=y
+
+#
+# Toolchain Options
+#
+# BR2_UCLIBC_VERSION_SNAPSHOT is not set
+BR2_BINUTILS_VERSION="2.16.1"
+BR2_PACKAGE_LIBGCC=y
+BR2_GCC_VERSION="3.4.6"
+BR2_GCC_USE_SJLJ_EXCEPTIONS=""
+BR2_EXTRA_GCC_CONFIG_OPTIONS=""
+BR2_INSTALL_LIBSTDCPP=y
+
+#
+# Using defaults
+#
+# BR2_ENABLE_MULTILIB is not set
+BR2_LARGEFILE=y
+BR2_TARGET_OPTIMIZATION="-Os -pipe -mips32 -mtune=mips32 -funit-at-a-time"
+
+#
+# OpenWrt Package Selection
+#
+
+#
+# Package categories
+#
+
+#
+# Base system
+#
+
+#
+# busybox........................... The Swiss Army Knife of embedded Linux
+#
+BR2_PACKAGE_BUSYBOX=y
+
+#
+# Busybox Configuration
+#
+BUSYBOX_HAVE_DOT_CONFIG=y
+
+#
+# Busybox Settings
+#
+
+#
+# General Configuration
+#
+# BUSYBOX_CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+BUSYBOX_CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# BUSYBOX_CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+BUSYBOX_CONFIG_FEATURE_VERBOSE_USAGE=y
+# BUSYBOX_CONFIG_FEATURE_INSTALLER is not set
+# BUSYBOX_CONFIG_LOCALE_SUPPORT is not set
+BUSYBOX_CONFIG_FEATURE_DEVFS=y
+BUSYBOX_CONFIG_FEATURE_DEVPTS=y
+# BUSYBOX_CONFIG_FEATURE_CLEAN_UP is not set
+BUSYBOX_CONFIG_FEATURE_SUID=y
+# BUSYBOX_CONFIG_FEATURE_SUID_CONFIG is not set
+# BUSYBOX_CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+# BUSYBOX_CONFIG_STATIC is not set
+# BUSYBOX_CONFIG_DISABLE_SHARED is not set
+BUSYBOX_CONFIG_LFS=y
+BUSYBOX_USING_CROSS_COMPILER=y
+BUSYBOX_CROSS_COMPILER_PREFIX="mipsel-uclibc-"
+BUSYBOX_EXTRA_CFLAGS_OPTIONS="-Os "
+# BUSYBOX_CONFIG_BUILD_AT_ONCE is not set
+
+#
+# Debugging Options
+#
+# BUSYBOX_CONFIG_DEBUG is not set
+BUSYBOX_CONFIG_DEBUG_YANK_SUSv2=y
+
+#
+# Installation Options
+#
+# BUSYBOX_CONFIG_INSTALL_NO_USR is not set
+BUSYBOX_CONFIG_INSTALL_APPLET_SYMLINKS=y
+# BUSYBOX_CONFIG_INSTALL_APPLET_HARDLINKS is not set
+# BUSYBOX_CONFIG_INSTALL_APPLET_DONT is not set
+BUSYBOX_PREFIX="./_install"
+
+#
+# Busybox Library Tuning
+#
+BUSYBOX_CONFIG_MD5_SIZE_VS_SPEED=2
+
+#
+# Applets
+#
+
+#
+# Archival Utilities
+#
+# BUSYBOX_CONFIG_AR is not set
+BUSYBOX_CONFIG_BUNZIP2=y
+# BUSYBOX_CONFIG_CPIO is not set
+# BUSYBOX_CONFIG_DPKG is not set
+# BUSYBOX_CONFIG_DPKG_DEB is not set
+BUSYBOX_CONFIG_GUNZIP=y
+BUSYBOX_CONFIG_FEATURE_GUNZIP_UNCOMPRESS=y
+BUSYBOX_CONFIG_GZIP=y
+# BUSYBOX_CONFIG_IPKG is not set
+# BUSYBOX_CONFIG_RPM2CPIO is not set
+# BUSYBOX_CONFIG_RPM is not set
+BUSYBOX_CONFIG_TAR=y
+BUSYBOX_CONFIG_FEATURE_TAR_CREATE=y
+BUSYBOX_CONFIG_FEATURE_TAR_BZIP2=y
+# BUSYBOX_CONFIG_FEATURE_TAR_LZMA is not set
+BUSYBOX_CONFIG_FEATURE_TAR_FROM=y
+BUSYBOX_CONFIG_FEATURE_TAR_GZIP=y
+# BUSYBOX_CONFIG_FEATURE_TAR_COMPRESS is not set
+# BUSYBOX_CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+BUSYBOX_CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# BUSYBOX_CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# BUSYBOX_CONFIG_UNCOMPRESS is not set
+# BUSYBOX_CONFIG_UNLZMA is not set
+# BUSYBOX_CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# BUSYBOX_CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+BUSYBOX_CONFIG_BASENAME=y
+# BUSYBOX_CONFIG_CAL is not set
+BUSYBOX_CONFIG_CAT=y
+BUSYBOX_CONFIG_CHGRP=y
+BUSYBOX_CONFIG_CHMOD=y
+BUSYBOX_CONFIG_CHOWN=y
+BUSYBOX_CONFIG_CHROOT=y
+BUSYBOX_CONFIG_CMP=y
+# BUSYBOX_CONFIG_COMM is not set
+BUSYBOX_CONFIG_CP=y
+BUSYBOX_CONFIG_CUT=y
+BUSYBOX_CONFIG_DATE=y
+BUSYBOX_CONFIG_FEATURE_DATE_ISOFMT=y
+BUSYBOX_CONFIG_DD=y
+BUSYBOX_CONFIG_DF=y
+BUSYBOX_CONFIG_DIRNAME=y
+# BUSYBOX_CONFIG_DOS2UNIX is not set
+BUSYBOX_CONFIG_DU=y
+BUSYBOX_CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+BUSYBOX_CONFIG_ECHO=y
+BUSYBOX_CONFIG_FEATURE_FANCY_ECHO=y
+BUSYBOX_CONFIG_ENV=y
+BUSYBOX_CONFIG_EXPR=y
+# BUSYBOX_CONFIG_EXPR_MATH_SUPPORT_64 is not set
+BUSYBOX_CONFIG_FALSE=y
+# BUSYBOX_CONFIG_FOLD is not set
+BUSYBOX_CONFIG_HEAD=y
+BUSYBOX_CONFIG_FEATURE_FANCY_HEAD=y
+BUSYBOX_CONFIG_HOSTID=y
+BUSYBOX_CONFIG_ID=y
+# BUSYBOX_CONFIG_INSTALL is not set
+BUSYBOX_CONFIG_LENGTH=y
+BUSYBOX_CONFIG_LN=y
+# BUSYBOX_CONFIG_LOGNAME is not set
+BUSYBOX_CONFIG_LS=y
+BUSYBOX_CONFIG_FEATURE_LS_FILETYPES=y
+BUSYBOX_CONFIG_FEATURE_LS_FOLLOWLINKS=y
+BUSYBOX_CONFIG_FEATURE_LS_RECURSIVE=y
+BUSYBOX_CONFIG_FEATURE_LS_SORTFILES=y
+BUSYBOX_CONFIG_FEATURE_LS_TIMESTAMPS=y
+BUSYBOX_CONFIG_FEATURE_LS_USERNAME=y
+BUSYBOX_CONFIG_FEATURE_LS_COLOR=y
+BUSYBOX_CONFIG_FEATURE_LS_COLOR_IS_DEFAULT=y
+BUSYBOX_CONFIG_MD5SUM=y
+BUSYBOX_CONFIG_MKDIR=y
+BUSYBOX_CONFIG_MKFIFO=y
+# BUSYBOX_CONFIG_MKNOD is not set
+BUSYBOX_CONFIG_MV=y
+# BUSYBOX_CONFIG_NICE is not set
+# BUSYBOX_CONFIG_NOHUP is not set
+BUSYBOX_CONFIG_OD=y
+# BUSYBOX_CONFIG_PRINTENV is not set
+BUSYBOX_CONFIG_PRINTF=y
+BUSYBOX_CONFIG_PWD=y
+# BUSYBOX_CONFIG_REALPATH is not set
+BUSYBOX_CONFIG_RM=y
+BUSYBOX_CONFIG_RMDIR=y
+BUSYBOX_CONFIG_SEQ=y
+# BUSYBOX_CONFIG_SHA1SUM is not set
+BUSYBOX_CONFIG_SLEEP=y
+BUSYBOX_CONFIG_FEATURE_FANCY_SLEEP=y
+BUSYBOX_CONFIG_SORT=y
+# BUSYBOX_CONFIG_FEATURE_SORT_BIG is not set
+# BUSYBOX_CONFIG_STAT is not set
+BUSYBOX_CONFIG_STTY=y
+# BUSYBOX_CONFIG_SUM is not set
+BUSYBOX_CONFIG_SYNC=y
+BUSYBOX_CONFIG_TAIL=y
+BUSYBOX_CONFIG_FEATURE_FANCY_TAIL=y
+BUSYBOX_CONFIG_TEE=y
+BUSYBOX_CONFIG_FEATURE_TEE_USE_BLOCK_IO=y
+BUSYBOX_CONFIG_TEST=y
+# BUSYBOX_CONFIG_FEATURE_TEST_64 is not set
+BUSYBOX_CONFIG_TOUCH=y
+BUSYBOX_CONFIG_TR=y
+# BUSYBOX_CONFIG_FEATURE_TR_CLASSES is not set
+# BUSYBOX_CONFIG_FEATURE_TR_EQUIV is not set
+BUSYBOX_CONFIG_TRUE=y
+# BUSYBOX_CONFIG_TTY is not set
+BUSYBOX_CONFIG_UNAME=y
+BUSYBOX_CONFIG_UNIQ=y
+# BUSYBOX_CONFIG_USLEEP is not set
+# BUSYBOX_CONFIG_UUDECODE is not set
+# BUSYBOX_CONFIG_UUENCODE is not set
+# BUSYBOX_CONFIG_WATCH is not set
+BUSYBOX_CONFIG_WC=y
+# BUSYBOX_CONFIG_WHO is not set
+# BUSYBOX_CONFIG_WHOAMI is not set
+BUSYBOX_CONFIG_YES=y
+
+#
+# Common options for cp and mv
+#
+BUSYBOX_CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls, more and telnet
+#
+BUSYBOX_CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+BUSYBOX_CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+BUSYBOX_CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# BUSYBOX_CONFIG_CHVT is not set
+BUSYBOX_CONFIG_CLEAR=y
+# BUSYBOX_CONFIG_DEALLOCVT is not set
+# BUSYBOX_CONFIG_DUMPKMAP is not set
+# BUSYBOX_CONFIG_LOADFONT is not set
+# BUSYBOX_CONFIG_LOADKMAP is not set
+# BUSYBOX_CONFIG_OPENVT is not set
+BUSYBOX_CONFIG_RESET=y
+# BUSYBOX_CONFIG_SETCONSOLE is not set
+# BUSYBOX_CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+BUSYBOX_CONFIG_MKTEMP=y
+# BUSYBOX_CONFIG_PIPE_PROGRESS is not set
+# BUSYBOX_CONFIG_READLINK is not set
+# BUSYBOX_CONFIG_RUN_PARTS is not set
+# BUSYBOX_CONFIG_START_STOP_DAEMON is not set
+BUSYBOX_CONFIG_WHICH=y
+
+#
+# Editors
+#
+BUSYBOX_CONFIG_AWK=y
+BUSYBOX_CONFIG_FEATURE_AWK_MATH=y
+# BUSYBOX_CONFIG_PATCH is not set
+BUSYBOX_CONFIG_SED=y
+BUSYBOX_CONFIG_VI=y
+BUSYBOX_CONFIG_FEATURE_VI_COLON=y
+BUSYBOX_CONFIG_FEATURE_VI_YANKMARK=y
+BUSYBOX_CONFIG_FEATURE_VI_SEARCH=y
+BUSYBOX_CONFIG_FEATURE_VI_USE_SIGNALS=y
+BUSYBOX_CONFIG_FEATURE_VI_DOT_CMD=y
+BUSYBOX_CONFIG_FEATURE_VI_READONLY=y
+BUSYBOX_CONFIG_FEATURE_VI_SETOPTS=y
+BUSYBOX_CONFIG_FEATURE_VI_SET=y
+BUSYBOX_CONFIG_FEATURE_VI_WIN_RESIZE=y
+BUSYBOX_CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+BUSYBOX_CONFIG_FIND=y
+# BUSYBOX_CONFIG_FEATURE_FIND_MTIME is not set
+# BUSYBOX_CONFIG_FEATURE_FIND_MMIN is not set
+BUSYBOX_CONFIG_FEATURE_FIND_PERM=y
+BUSYBOX_CONFIG_FEATURE_FIND_TYPE=y
+BUSYBOX_CONFIG_FEATURE_FIND_XDEV=y
+# BUSYBOX_CONFIG_FEATURE_FIND_NEWER is not set
+# BUSYBOX_CONFIG_FEATURE_FIND_INUM is not set
+BUSYBOX_CONFIG_FEATURE_FIND_EXEC=y
+BUSYBOX_CONFIG_GREP=y
+BUSYBOX_CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+BUSYBOX_CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+BUSYBOX_CONFIG_FEATURE_GREP_CONTEXT=y
+BUSYBOX_CONFIG_XARGS=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+BUSYBOX_CONFIG_INIT=y
+BUSYBOX_CONFIG_FEATURE_USE_INITTAB=y
+# BUSYBOX_CONFIG_FEATURE_INIT_SCTTY is not set
+# BUSYBOX_CONFIG_FEATURE_EXTRA_QUIET is not set
+# BUSYBOX_CONFIG_FEATURE_INIT_COREDUMPS is not set
+# BUSYBOX_CONFIG_FEATURE_INITRD is not set
+BUSYBOX_CONFIG_HALT=y
+BUSYBOX_CONFIG_MESG=y
+
+#
+# Login/Password Management Utilities
+#
+BUSYBOX_CONFIG_FEATURE_SHADOWPASSWDS=y
+# BUSYBOX_CONFIG_USE_BB_PWD_GRP is not set
+BUSYBOX_CONFIG_ADDGROUP=y
+BUSYBOX_CONFIG_DELGROUP=y
+BUSYBOX_CONFIG_ADDUSER=y
+BUSYBOX_CONFIG_DELUSER=y
+# BUSYBOX_CONFIG_GETTY is not set
+# BUSYBOX_CONFIG_LOGIN is not set
+BUSYBOX_CONFIG_PASSWD=y
+# BUSYBOX_CONFIG_SU is not set
+# BUSYBOX_CONFIG_SULOGIN is not set
+# BUSYBOX_CONFIG_VLOCK is not set
+
+#
+# Linux Ext2 FS Progs
+#
+# BUSYBOX_CONFIG_CHATTR is not set
+# BUSYBOX_CONFIG_E2FSCK is not set
+# BUSYBOX_CONFIG_FSCK is not set
+# BUSYBOX_CONFIG_LSATTR is not set
+# BUSYBOX_CONFIG_MKE2FS is not set
+# BUSYBOX_CONFIG_TUNE2FS is not set
+
+#
+# Linux Module Utilities
+#
+BUSYBOX_CONFIG_INSMOD=y
+# BUSYBOX_CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+BUSYBOX_CONFIG_RMMOD=y
+BUSYBOX_CONFIG_LSMOD=y
+# BUSYBOX_CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT is not set
+# BUSYBOX_CONFIG_MODPROBE is not set
+
+#
+# Options common to multiple modutils
+#
+BUSYBOX_CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+BUSYBOX_CONFIG_FEATURE_2_4_MODULES=y
+# BUSYBOX_CONFIG_FEATURE_2_6_MODULES is not set
+# BUSYBOX_CONFIG_FEATURE_QUERY_MODULE_INTERFACE is not set
+
+#
+# Linux System Utilities
+#
+BUSYBOX_CONFIG_DMESG=y
+# BUSYBOX_CONFIG_FBSET is not set
+# BUSYBOX_CONFIG_FDFLUSH is not set
+# BUSYBOX_CONFIG_FDFORMAT is not set
+# BUSYBOX_CONFIG_FDISK is not set
+BUSYBOX_FDISK_SUPPORT_LARGE_DISKS=y
+# BUSYBOX_CONFIG_FREERAMDISK is not set
+# BUSYBOX_CONFIG_FSCK_MINIX is not set
+# BUSYBOX_CONFIG_MKFS_MINIX is not set
+# BUSYBOX_CONFIG_GETOPT is not set
+BUSYBOX_CONFIG_HEXDUMP=y
+# BUSYBOX_CONFIG_HWCLOCK is not set
+# BUSYBOX_CONFIG_IPCRM is not set
+# BUSYBOX_CONFIG_IPCS is not set
+BUSYBOX_CONFIG_LOSETUP=y
+# BUSYBOX_CONFIG_MDEV is not set
+BUSYBOX_CONFIG_MKSWAP=y
+BUSYBOX_CONFIG_MORE=y
+BUSYBOX_CONFIG_FEATURE_USE_TERMIOS=y
+BUSYBOX_CONFIG_MOUNT=y
+BUSYBOX_CONFIG_FEATURE_MOUNT_NFS=y
+BUSYBOX_CONFIG_PIVOT_ROOT=y
+BUSYBOX_CONFIG_RDATE=y
+# BUSYBOX_CONFIG_READPROFILE is not set
+# BUSYBOX_CONFIG_SETARCH is not set
+BUSYBOX_CONFIG_SWAPONOFF=y
+BUSYBOX_CONFIG_SWITCH_ROOT=y
+BUSYBOX_CONFIG_UMOUNT=y
+BUSYBOX_CONFIG_FEATURE_UMOUNT_ALL=y
+
+#
+# Common options for mount/umount
+#
+BUSYBOX_CONFIG_FEATURE_MOUNT_LOOP=y
+# BUSYBOX_CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Miscellaneous Utilities
+#
+# BUSYBOX_CONFIG_ADJTIMEX is not set
+# BUSYBOX_CONFIG_BBCONFIG is not set
+BUSYBOX_CONFIG_CROND=y
+# BUSYBOX_CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+BUSYBOX_CONFIG_CRONTAB=y
+# BUSYBOX_CONFIG_DC is not set
+# BUSYBOX_CONFIG_DEVFSD is not set
+# BUSYBOX_CONFIG_EJECT is not set
+# BUSYBOX_CONFIG_LAST is not set
+# BUSYBOX_CONFIG_LESS is not set
+# BUSYBOX_CONFIG_HDPARM is not set
+BUSYBOX_CONFIG_LOCK=y
+# BUSYBOX_CONFIG_MAKEDEVS is not set
+# BUSYBOX_CONFIG_MOUNTPOINT is not set
+# BUSYBOX_CONFIG_MT is not set
+# BUSYBOX_CONFIG_RUNLEVEL is not set
+BUSYBOX_CONFIG_RX=y
+BUSYBOX_CONFIG_STRINGS=y
+# BUSYBOX_CONFIG_SETSID is not set
+BUSYBOX_CONFIG_TIME=y
+# BUSYBOX_CONFIG_WATCHDOG is not set
+
+#
+# Networking Utilities
+#
+BUSYBOX_CONFIG_FEATURE_IPV6=y
+BUSYBOX_CONFIG_ARPING=y
+# BUSYBOX_CONFIG_DNSD is not set
+# BUSYBOX_CONFIG_ETHER_WAKE is not set
+# BUSYBOX_CONFIG_FAKEIDENTD is not set
+# BUSYBOX_CONFIG_FTPGET is not set
+# BUSYBOX_CONFIG_FTPPUT is not set
+BUSYBOX_CONFIG_HOSTNAME=y
+BUSYBOX_CONFIG_HTTPD=y
+# BUSYBOX_CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+BUSYBOX_CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_AUTH_MD5=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP=y
+# BUSYBOX_CONFIG_FEATURE_HTTPD_SETUID is not set
+BUSYBOX_CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_CGI=y
+# BUSYBOX_CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR is not set
+BUSYBOX_CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+BUSYBOX_CONFIG_IFCONFIG=y
+BUSYBOX_CONFIG_FEATURE_IFCONFIG_STATUS=y
+# BUSYBOX_CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# BUSYBOX_CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ is not set
+BUSYBOX_CONFIG_FEATURE_IFCONFIG_HW=y
+BUSYBOX_CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS=y
+# BUSYBOX_CONFIG_IFUPDOWN is not set
+# BUSYBOX_CONFIG_INETD is not set
+# BUSYBOX_CONFIG_IP is not set
+BUSYBOX_CONFIG_IPCALC=y
+BUSYBOX_CONFIG_FEATURE_IPCALC_FANCY=y
+# BUSYBOX_CONFIG_IPADDR is not set
+# BUSYBOX_CONFIG_IPLINK is not set
+# BUSYBOX_CONFIG_IPROUTE is not set
+# BUSYBOX_CONFIG_IPTUNNEL is not set
+# BUSYBOX_CONFIG_NAMEIF is not set
+BUSYBOX_CONFIG_NC=y
+BUSYBOX_CONFIG_NETMSG=y
+# BUSYBOX_CONFIG_NC_GAPING_SECURITY_HOLE is not set
+BUSYBOX_CONFIG_NETSTAT=y
+BUSYBOX_CONFIG_NSLOOKUP=y
+BUSYBOX_CONFIG_PING=y
+BUSYBOX_CONFIG_FEATURE_FANCY_PING=y
+BUSYBOX_CONFIG_PING6=y
+BUSYBOX_CONFIG_FEATURE_FANCY_PING6=y
+BUSYBOX_CONFIG_ROUTE=y
+BUSYBOX_CONFIG_TELNET=y
+BUSYBOX_CONFIG_FEATURE_TELNET_TTYPE=y
+# BUSYBOX_CONFIG_FEATURE_TELNET_AUTOLOGIN is not set
+BUSYBOX_CONFIG_TELNETD=y
+# BUSYBOX_CONFIG_FEATURE_TELNETD_INETD is not set
+# BUSYBOX_CONFIG_TFTP is not set
+BUSYBOX_CONFIG_TRACEROUTE=y
+BUSYBOX_CONFIG_FEATURE_TRACEROUTE_VERBOSE=y
+# BUSYBOX_CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE is not set
+# BUSYBOX_CONFIG_FEATURE_TRACEROUTE_USE_ICMP is not set
+BUSYBOX_CONFIG_VCONFIG=y
+BUSYBOX_CONFIG_WGET=y
+BUSYBOX_CONFIG_FEATURE_WGET_STATUSBAR=y
+BUSYBOX_CONFIG_FEATURE_WGET_AUTHENTICATION=y
+BUSYBOX_CONFIG_FEATURE_WGET_IP6_LITERAL=y
+
+#
+# udhcp Server/Client
+#
+# BUSYBOX_CONFIG_UDHCPD is not set
+BUSYBOX_CONFIG_UDHCPC=y
+# BUSYBOX_CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# BUSYBOX_CONFIG_FEATURE_UDHCP_DEBUG is not set
+# BUSYBOX_CONFIG_ZCIP is not set
+
+#
+# Process Utilities
+#
+BUSYBOX_CONFIG_FREE=y
+# BUSYBOX_CONFIG_FUSER is not set
+BUSYBOX_CONFIG_KILL=y
+BUSYBOX_CONFIG_KILLALL=y
+BUSYBOX_CONFIG_KILLALL5=y
+BUSYBOX_CONFIG_PIDOF=y
+# BUSYBOX_CONFIG_FEATURE_PIDOF_SINGLE is not set
+# BUSYBOX_CONFIG_FEATURE_PIDOF_OMIT is not set
+BUSYBOX_CONFIG_PS=y
+# BUSYBOX_CONFIG_FEATURE_PS_WIDE is not set
+# BUSYBOX_CONFIG_RENICE is not set
+BUSYBOX_CONFIG_BB_SYSCTL=y
+BUSYBOX_CONFIG_TOP=y
+BUSYBOX_CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE=y
+BUSYBOX_CONFIG_UPTIME=y
+
+#
+# Shells
+#
+BUSYBOX_CONFIG_FEATURE_SH_IS_ASH=y
+# BUSYBOX_CONFIG_FEATURE_SH_IS_HUSH is not set
+# BUSYBOX_CONFIG_FEATURE_SH_IS_LASH is not set
+# BUSYBOX_CONFIG_FEATURE_SH_IS_MSH is not set
+# BUSYBOX_CONFIG_FEATURE_SH_IS_NONE is not set
+BUSYBOX_CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+BUSYBOX_CONFIG_ASH_JOB_CONTROL=y
+# BUSYBOX_CONFIG_ASH_READ_NCHARS is not set
+BUSYBOX_CONFIG_ASH_READ_TIMEOUT=y
+BUSYBOX_CONFIG_ASH_ALIAS=y
+BUSYBOX_CONFIG_ASH_MATH_SUPPORT=y
+# BUSYBOX_CONFIG_ASH_MATH_SUPPORT_64 is not set
+BUSYBOX_CONFIG_ASH_GETOPTS=y
+BUSYBOX_CONFIG_ASH_CMDCMD=y
+BUSYBOX_CONFIG_ASH_BUILTIN_ECHO=y
+# BUSYBOX_CONFIG_ASH_MAIL is not set
+BUSYBOX_CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# BUSYBOX_CONFIG_ASH_RANDOM_SUPPORT is not set
+# BUSYBOX_CONFIG_ASH_EXPAND_PRMT is not set
+# BUSYBOX_CONFIG_HUSH is not set
+# BUSYBOX_CONFIG_LASH is not set
+# BUSYBOX_CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# BUSYBOX_CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# BUSYBOX_CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+BUSYBOX_CONFIG_FEATURE_COMMAND_EDITING=y
+# BUSYBOX_CONFIG_FEATURE_COMMAND_EDITING_VI is not set
+BUSYBOX_CONFIG_FEATURE_COMMAND_HISTORY=15
+# BUSYBOX_CONFIG_FEATURE_COMMAND_SAVEHISTORY is not set
+BUSYBOX_CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# BUSYBOX_CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+BUSYBOX_CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+BUSYBOX_CONFIG_SYSLOGD=y
+BUSYBOX_CONFIG_FEATURE_ROTATE_LOGFILE=y
+BUSYBOX_CONFIG_FEATURE_REMOTE_LOG=y
+BUSYBOX_CONFIG_FEATURE_IPC_SYSLOG=y
+BUSYBOX_CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=16
+BUSYBOX_CONFIG_LOGREAD=y
+# BUSYBOX_CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+BUSYBOX_CONFIG_KLOGD=y
+BUSYBOX_CONFIG_LOGGER=y
+# BR2_PACKAGE_BRIDGE is not set
+# BR2_PACKAGE_DNSMASQ is not set
+BR2_PACKAGE_IPKG=y
+
+#
+# iptables.......................... IPv4 / IPv6 firewall administration
+#
+# BR2_PACKAGE_IPTABLES is not set
+# BR2_PACKAGE_IP6TABLES is not set
+# BR2_PACKAGE_MTD is not set
+# BR2_PACKAGE_MTD_STATIC is not set
+
+#
+# Applications
+#
+# BR2_PACKAGE_AUTOSSH is not set
+# BR2_PACKAGE_BITCHX is not set
+
+#
+# collectd.......................... Lightweight system statistics collection daemon
+#
+# BR2_PACKAGE_COLLECTD is not set
+# BR2_PACKAGE_CBTT is not set
+# BR2_PACKAGE_CBTT_MYSQL is not set
+# BR2_PACKAGE_CTORRENT is not set
+# BR2_PACKAGE_DECO is not set
+# BR2_PACKAGE_ELINKS is not set
+# BR2_PACKAGE_FETCHMAIL is not set
+# BR2_PACKAGE_GPSD is not set
+# BR2_PACKAGE_GPG is not set
+# BR2_PACKAGE_HASERL is not set
+# BR2_PACKAGE_IRSSI is not set
+# BR2_PACKAGE_JAMVM is not set
+# BR2_PACKAGE_LCD4LINUX is not set
+BR2_PACKAGE_LESS=m
+
+#
+# lua............................... LUA programming language
+#
+# BR2_PACKAGE_LIBLUA is not set
+# BR2_PACKAGE_LUA is not set
+# BR2_PACKAGE_LUAC is not set
+# BR2_PACKAGE_LUA_EXAMPLES is not set
+# BR2_PACKAGE_MICROPERL is not set
+# BR2_PACKAGE_MONIT is not set
+# BR2_PACKAGE_MONIT_NOSSL is not set
+# BR2_PACKAGE_MOTION is not set
+# BR2_PACKAGE_MGETTY is not set
+# BR2_PACKAGE_MUTT is not set
+# BR2_PACKAGE_NANO is not set
+# BR2_PACKAGE_OSIRISD is not set
+
+#
+# php4.............................. PHP4 Hypertext preprocessor
+#
+
+#
+# Server API ---
+#
+# BR2_PACKAGE_PHP4_CLI is not set
+# BR2_PACKAGE_PHP4_CGI is not set
+# BR2_PACKAGE_PHP4_FASTCGI is not set
+
+#
+# Extensions ---
+#
+
+#
+# php5.............................. PHP5 Hypertext preprocessor
+#
+
+#
+# Server API ---
+#
+# BR2_PACKAGE_PHP5_CLI is not set
+# BR2_PACKAGE_PHP5_CGI is not set
+# BR2_PACKAGE_PHP5_FASTCGI is not set
+
+#
+# Extensions ---
+#
+# BR2_PACKAGE_PROCMAIL is not set
+# BR2_PACKAGE_PSYBNC is not set
+BR2_PACKAGE_RUBY=m
+
+#
+# sablevm........................... A Java Virtual Machine (JVM) implementation
+#
+# BR2_PACKAGE_SABLEVM is not set
+# BR2_PACKAGE_LIBSABLEVM_CLASSPATH is not set
+# BR2_PACKAGE_LIBFFI_SABLE is not set
+# BR2_PACKAGE_SANE_BACKENDS is not set
+# BR2_PACKAGE_SCREEN is not set
+# BR2_PACKAGE_SER2NET is not set
+# BR2_PACKAGE_SYSLOG_NG is not set
+
+#
+# rrdtool........................... Round-Robin Database (RRD) libraries and tools
+#
+# BR2_COMPILE_RRDTOOL is not set
+BR2_COMPILE_RRDTOOL1=y
+# BR2_PACKAGE_LIBRRD1 is not set
+# BR2_PACKAGE_RRDCGI1 is not set
+# BR2_PACKAGE_RRDTOOL1 is not set
+# BR2_PACKAGE_VIM is not set
+
+#
+# Networking
+#
+# BR2_PACKAGE_AIRCRACK is not set
+# BR2_PACKAGE_AMWALL is not set
+# BR2_PACKAGE_ARPD is not set
+# BR2_PACKAGE_ARPTABLES is not set
+# BR2_PACKAGE_ARPWATCH is not set
+
+#
+# asterisk.......................... Complete open source PBX
+#
+# BR2_PACKAGE_ASTERISK is not set
+# BR2_PACKAGE_ASTERISK_MINI is not set
+# BR2_PACKAGE_ATFTP is not set
+# BR2_PACKAGE_ATFTPD is not set
+
+#
+# avahi............................. An mDNS/DNS-SD (aka RendezVous/Bonjour/ZeroConf) implementation
+#
+# BR2_PACKAGE_AVAHI_DAEMON is not set
+# BR2_PACKAGE_LIBAVAHI is not set
+
+#
+# bind.............................. A DNS server implementation
+#
+# BR2_PACKAGE_BIND_TOOLS is not set
+# BR2_PACKAGE_BIND_RNDC is not set
+# BR2_PACKAGE_BIND_CHECK is not set
+# BR2_PACKAGE_BIND_DNSSEC is not set
+# BR2_PACKAGE_BIND_HOST is not set
+# BR2_PACKAGE_BIND_DIG is not set
+# BR2_PACKAGE_BIND_CLIENT is not set
+# BR2_PACKAGE_BIND_SERVER is not set
+# BR2_PACKAGE_BITLBEE is not set
+# BR2_PACKAGE_BWM is not set
+# BR2_PACKAGE_CHILLISPOT is not set
+# BR2_PACKAGE_CIFSMOUNT is not set
+# BR2_PACKAGE_CLICK is not set
+# BR2_PACKAGE_CUPS is not set
+# BR2_PACKAGE_CUTTER is not set
+# BR2_PACKAGE_DHCP_RELAY is not set
+# BR2_PACKAGE_DHCP_SERVER is not set
+# BR2_PACKAGE_DHCP_FORWARDER is not set
+# BR2_PACKAGE_DROPBEAR is not set
+# BR2_PACKAGE_DSNIFF is not set
+# BR2_PACKAGE_EBTABLES is not set
+# BR2_PACKAGE_ELHTTP is not set
+# BR2_PACKAGE_ETHER_WAKE is not set
+# BR2_PACKAGE_ETHTOOL is not set
+# BR2_PACKAGE_EZIPUPDATE is not set
+# BR2_PACKAGE_FAKEIDENTD is not set
+# BR2_PACKAGE_FPING is not set
+# BR2_PACKAGE_FPROBE is not set
+# BR2_PACKAGE_FPROBE_ULOG is not set
+
+#
+# freeradius........................ A Flexible RADIUS server implementation
+#
+# BR2_PACKAGE_FREERADIUS is not set
+# BR2_PACKAGE_FRICKIN is not set
+
+#
+# howl.............................. A Zeroconf networking implementation
+#
+# BR2_PACKAGE_LIBHOWL is not set
+
+#
+# Daemons ---
+#
+# BR2_PACKAGE_AUTOIPD is not set
+# BR2_PACKAGE_MDNSRESPONDER is not set
+# BR2_PACKAGE_NIFD is not set
+# BR2_PACKAGE_HOSTAP_UTILS is not set
+# BR2_PACKAGE_HOSTAPD is not set
+# BR2_PACKAGE_HOSTAPD_MINI is not set
+# BR2_PACKAGE_HOSTAPD_UTILS is not set
+# BR2_PACKAGE_HTPDATE is not set
+
+#
+# httping........................... Httping is like 'ping' but for http-requests.
+#
+# BR2_PACKAGE_HTTPING is not set
+# BR2_PACKAGE_IFTOP is not set
+# BR2_PACKAGE_IGMPPROXY is not set
+# BR2_PACKAGE_IPCAD is not set
+
+#
+# iproute2.......................... A collection of utilites for controlling TCP/IP networking and Traffic Control
+#
+# BR2_PACKAGE_IP is not set
+# BR2_PACKAGE_TC is not set
+# BR2_PACKAGE_IPERF is not set
+# BR2_PACKAGE_IPSET is not set
+# BR2_PACKAGE_IPTABLES_SNMP is not set
+# BR2_PACKAGE_IPTRAF is not set
+# BR2_PACKAGE_KISMET_CLIENT is not set
+# BR2_PACKAGE_KISMET_DRONE is not set
+# BR2_PACKAGE_KISMET_SERVER is not set
+# BR2_PACKAGE_KNOCK is not set
+# BR2_PACKAGE_KNOCKD is not set
+# BR2_PACKAGE_L2TPD is not set
+# BR2_PACKAGE_L2TPNS is not set
+
+#
+# lighttpd.......................... Flexible and lightweight web server
+#
+# BR2_PACKAGE_LIGHTTPD is not set
+# BR2_PACKAGE_LINUX_ATM is not set
+# BR2_PACKAGE_MACCHANGER is not set
+# BR2_PACKAGE_MARADNS is not set
+# BR2_PACKAGE_MATRIXTUNNEL is not set
+# BR2_PACKAGE_MIAU is not set
+
+#
+# mini-httpd........................ A small web server
+#
+# BR2_PACKAGE_MINI_HTTPD is not set
+# BR2_PACKAGE_MINI_HTTPD_HTPASSWD is not set
+# BR2_PACKAGE_MINI_HTTPD_MATRIXSSL is not set
+# BR2_PACKAGE_MINI_HTTPD_OPENSSL is not set
+# BR2_PACKAGE_MINI_SENDMAIL is not set
+# BR2_PACKAGE_MTR is not set
+
+#
+# net-snmp.......................... Open source SNMP (Simple Network Management Protocol) implementation
+#
+# BR2_PACKAGE_LIBNETSNMP is not set
+# BR2_PACKAGE_SNMPD is not set
+# BR2_PACKAGE_SNMPD_STATIC is not set
+# BR2_PACKAGE_NETPERF is not set
+# BR2_PACKAGE_NETSTAT_NAT is not set
+# BR2_PACKAGE_NFS_SERVER is not set
+# BR2_PACKAGE_NMAP is not set
+# BR2_PACKAGE_NOCATSPLASH is not set
+# BR2_PACKAGE_NTPCLIENT is not set
+
+#
+# olsrd............................. OLSR (Optimized Link State Routing) daemon
+#
+# BR2_PACKAGE_OLSRD is not set
+# BR2_PACKAGE_OPENNTPD is not set
+
+#
+# openser........................... Configurable, free SIP server
+#
+# BR2_PACKAGE_OPENSER is not set
+
+#
+# openssh........................... A free implementation of the Secure Shell protocol
+#
+# BR2_PACKAGE_OPENSSH_CLIENT is not set
+# BR2_PACKAGE_OPENSSH_SERVER is not set
+# BR2_PACKAGE_OPENSSH_SFTP_CLIENT is not set
+# BR2_PACKAGE_OPENSSH_SFTP_SERVER is not set
+# BR2_PACKAGE_OPENSWAN is not set
+
+#
+# openvpn........................... Open source VPN solution using SSL
+#
+# BR2_PACKAGE_OPENVPN is not set
+# BR2_PACKAGE_P910ND is not set
+# BR2_PACKAGE_PARPROUTED is not set
+# BR2_PACKAGE_PIPACS is not set
+
+#
+# pmacct............................ IPv4/IPv6 accounting and aggregation tools
+#
+# BR2_PACKAGE_NFACCTD_BASIC is not set
+# BR2_PACKAGE_NFACCTD_MYSQL is not set
+# BR2_PACKAGE_NFACCTD_PGSQL is not set
+# BR2_PACKAGE_NFACCTD_SQLITE is not set
+# BR2_PACKAGE_NFACCTD_CUSTOM is not set
+# BR2_PACKAGE_PMACCTD_BASIC is not set
+# BR2_PACKAGE_PMACCTD_MYSQL is not set
+# BR2_PACKAGE_PMACCTD_PGSQL is not set
+# BR2_PACKAGE_PMACCTD_SQLITE is not set
+# BR2_PACKAGE_PMACCTD_CUSTOM is not set
+# BR2_PACKAGE_PMACCT_CLIENT is not set
+# BR2_PACKAGE_PORTMAP is not set
+# BR2_PACKAGE_PORTSENTRY is not set
+
+#
+# ppp............................... PPP (Point-to-Point Protocol) daemon
+#
+BR2_PACKAGE_PPP=y
+BR2_PACKAGE_PPP_WITH_FILTER=y
+# BR2_PACKAGE_PPP_MOD_PPPOA is not set
+BR2_PACKAGE_PPP_MOD_PPPOE=y
+# BR2_PACKAGE_PPP_MOD_RADIUS is not set
+# BR2_PACKAGE_CHAT is not set
+# BR2_PACKAGE_PPPDUMP is not set
+# BR2_PACKAGE_PPPSTATS is not set
+# BR2_PACKAGE_PPTP is not set
+# BR2_PACKAGE_PPTPD is not set
+# BR2_PACKAGE_PRIVOXY is not set
+# BR2_PACKAGE_PTUNNEL is not set
+
+#
+# quagga............................ The Quagga Software Routing Suite
+#
+# BR2_PACKAGE_QUAGGA is not set
+# BR2_PACKAGE_RADDUMP is not set
+# BR2_PACKAGE_RARPD is not set
+# BR2_PACKAGE_REAIM is not set
+# BR2_PACKAGE_ROBOCFG is not set
+# BR2_PACKAGE_PPPOE_CLIENT is not set
+# BR2_PACKAGE_PPPOE_RELAY is not set
+# BR2_PACKAGE_PPPOE_SERVER is not set
+# BR2_PACKAGE_PPPOE_SNIFF is not set
+# BR2_PACKAGE_RRS is not set
+# BR2_PACKAGE_RRS_NOSSL is not set
+# BR2_PACKAGE_RSYNC is not set
+# BR2_PACKAGE_SAMBA is not set
+# BR2_PACKAGE_SAMBA_CLIENT is not set
+# BR2_PACKAGE_SCANLOGD is not set
+# BR2_PACKAGE_SCDP is not set
+# BR2_PACKAGE_SHAT is not set
+# BR2_PACKAGE_SIPP is not set
+# BR2_PACKAGE_SIPROXD is not set
+# BR2_PACKAGE_SIPSAK is not set
+# BR2_PACKAGE_SLURM is not set
+
+#
+# snort............................. Ligthweight Network Intrusion Detection System (NIDS)
+#
+# BR2_PACKAGE_SNORT_BASIC is not set
+# BR2_PACKAGE_SNORT_MYSQL is not set
+# BR2_PACKAGE_SNORT_PGSQL is not set
+# BR2_PACKAGE_SNORT_CUSTOM is not set
+
+#
+# snort-wireless.................... Ligthweight Wireless Network Intrusion Detection System (NIDS)
+#
+# BR2_PACKAGE_SNORT_WIRELESS_BASIC is not set
+# BR2_PACKAGE_SNORT_WIRELESS_MYSQL is not set
+# BR2_PACKAGE_SNORT_WIRELESS_PGSQL is not set
+# BR2_PACKAGE_SNORT_WIRELESS_CUSTOM is not set
+# BR2_PACKAGE_SOCAT is not set
+
+#
+# squid............................. proxy and web cache
+#
+# BR2_PACKAGE_SQUID is not set
+# BR2_PACKAGE_SSLTUNNEL is not set
+# BR2_PACKAGE_SSMTP is not set
+# BR2_PACKAGE_SRELAY is not set
+# BR2_PACKAGE_TMSNC is not set
+# BR2_PACKAGE_TCPDUMP is not set
+# BR2_PACKAGE_TINC is not set
+
+#
+# tinyproxy......................... Tinyproxy is a lightweight HTTP and HTTPS proxy.
+#
+# BR2_PACKAGE_TINYPROXY is not set
+# BR2_PACKAGE_TOR is not set
+# BR2_PACKAGE_TTCP is not set
+# BR2_PACKAGE_UDP_BROADCAST_RELAY is not set
+
+#
+# ulogd............................. Netfilter userspace logging daemon
+#
+# BR2_PACKAGE_ULOGD is not set
+
+#
+# updatedd.......................... A tool to update dynamic dns services
+#
+# BR2_PACKAGE_UPDATEDD is not set
+# BR2_PACKAGE_VGP is not set
+# BR2_PACKAGE_VNCREPEATER is not set
+# BR2_PACKAGE_VNC_REFLECTOR is not set
+# BR2_PACKAGE_VNSTAT is not set
+# BR2_PACKAGE_VPNC is not set
+# BR2_PACKAGE_VRRPD is not set
+# BR2_PACKAGE_VSFTPD is not set
+# BR2_PACKAGE_VTUN is not set
+# BR2_PACKAGE_WCCPD is not set
+
+#
+# weechat........................... Lightweight IRC client
+#
+# BR2_PACKAGE_WEECHAT is not set
+# BR2_PACKAGE_WIFIDOG is not set
+# BR2_PACKAGE_WIRELESS_TOOLS is not set
+# BR2_PACKAGE_WIVIZ is not set
+# BR2_PACKAGE_WKNOCK is not set
+# BR2_PACKAGE_WOL is not set
+# BR2_PACKAGE_WONDERSHAPER is not set
+# BR2_PACKAGE_WPA_SUPPLICANT is not set
+# BR2_PACKAGE_WPUT is not set
+# BR2_PACKAGE_WX200D is not set
+# BR2_PACKAGE_XINETD is not set
+# BR2_PACKAGE_XSUPPLICANT is not set
+
+#
+# IPv6
+#
+# BR2_PACKAGE_6TUNNEL is not set
+# BR2_PACKAGE_AICCU is not set
+# BR2_PACKAGE_DHCP6 is not set
+# BR2_PACKAGE_MIREDO is not set
+# BR2_PACKAGE_MIREDO_SERVER is not set
+# BR2_PACKAGE_MRD6 is not set
+
+#
+# ndisc6............................ IPv6 discovery tools
+#
+# BR2_PACKAGE_NDISC6 is not set
+# BR2_PACKAGE_RDISC6 is not set
+# BR2_PACKAGE_TCPTRACEROUTE6 is not set
+# BR2_PACKAGE_RADVD is not set
+
+#
+# Libraries
+#
+
+#
+# axtls............................. Embedded client/server TLSv1 SSL library
+#
+# BR2_PACKAGE_LIBAXTLS is not set
+# BR2_PACKAGE_CGILIB is not set
+# BR2_PACKAGE_GLIB1 is not set
+# BR2_PACKAGE_ID3LIB is not set
+# BR2_PACKAGE_LIBAMSEL is not set
+# BR2_PACKAGE_LIBAO is not set
+# BR2_PACKAGE_LIBART is not set
+# BR2_PACKAGE_LIBCLI is not set
+# BR2_PACKAGE_CLINKC is not set
+# BR2_PACKAGE_LIBCURL is not set
+# BR2_PACKAGE_LIBDAEMON is not set
+# BR2_PACKAGE_LIBDB is not set
+# BR2_PACKAGE_LIBDNET is not set
+# BR2_PACKAGE_LIBELF is not set
+# BR2_PACKAGE_LIBEVENT is not set
+# BR2_PACKAGE_LIBEXPAT is not set
+# BR2_PACKAGE_LIBFLAC is not set
+# BR2_PACKAGE_LIBFREETYPE is not set
+# BR2_PACKAGE_LIBGCRYPT is not set
+# BR2_PACKAGE_LIBGD is not set
+# BR2_PACKAGE_LIBGDBM is not set
+# BR2_PACKAGE_LIBGMP is not set
+# BR2_PACKAGE_LIBGNUTLS is not set
+# BR2_PACKAGE_LIBGPG_ERROR is not set
+# BR2_PACKAGE_LIBGSM is not set
+# BR2_PACKAGE_LIBICONV is not set
+# BR2_PACKAGE_LIBID3TAG is not set
+# BR2_PACKAGE_LIBJPEG is not set
+# BR2_PACKAGE_LIBLTDL is not set
+# BR2_PACKAGE_LIBLZO is not set
+# BR2_PACKAGE_LIBMAD is not set
+# BR2_PACKAGE_LIBMATRIXSSL is not set
+# BR2_PACKAGE_LIBMYSQLCLIENT is not set
+BR2_COMPILE_NCURSES=m
+BR2_PACKAGE_LIBNCURSES=m
+# BR2_PACKAGE_LIBNET is not set
+# BR2_PACKAGE_LIBNIDS is not set
+# BR2_PACKAGE_LIBOGG is not set
+# BR2_PACKAGE_LIBOL is not set
+# BR2_PACKAGE_LIBOPENCDK is not set
+# BR2_COMPILE_OPENH323 is not set
+# BR2_PACKAGE_LIBOPENLDAP is not set
+BR2_COMPILE_OPENSSL=m
+BR2_PACKAGE_LIBOPENSSL=m
+# BR2_PACKAGE_OPENSSL_UTIL is not set
+# BR2_PACKAGE_LIBOSIP2 is not set
+# BR2_PACKAGE_LIBPCAP is not set
+# BR2_PACKAGE_LIBPCRE is not set
+# BR2_COMPILE_PWLIB is not set
+# BR2_PACKAGE_LIBPNG is not set
+# BR2_PACKAGE_LIBPOPT is not set
+# BR2_PACKAGE_LIBPQ is not set
+# BR2_PACKAGE_LIBPTHREAD is not set
+# BR2_PACKAGE_RADIUSCLIENT_NG is not set
+# BR2_PACKAGE_LIBRADIUSCLIENT_NG is not set
+# BR2_PACKAGE_LIBREADLINE is not set
+# BR2_PACKAGE_LIBSASL2 is not set
+# BR2_PACKAGE_LIBSPEEX is not set
+# BR2_PACKAGE_LIBSQLITE is not set
+# BR2_PACKAGE_LIBSQLITE2 is not set
+# BR2_PACKAGE_LIBTASN1 is not set
+# BR2_PACKAGE_LIBUPNP is not set
+# BR2_PACKAGE_LIBUSB is not set
+# BR2_PACKAGE_LIBVORBIS is not set
+# BR2_PACKAGE_LIBVORBISIDEC is not set
+# BR2_PACKAGE_LIBXML2 is not set
+# BR2_PACKAGE_LIBXSLT is not set
+# BR2_PACKAGE_UCLIBCXX is not set
+# BR2_PACKAGE_USTL is not set
+# BR2_PACKAGE_ZLIB is not set
+
+#
+# Multimedia
+#
+# BR2_PACKAGE_GMEDIASERVER is not set
+# BR2_PACKAGE_ICECAST is not set
+# BR2_PACKAGE_MADPLAY is not set
+
+#
+# mpd............................... Music Player Daemon
+#
+# BR2_PACKAGE_MPD is not set
+# BR2_PACKAGE_MT_DAAPD is not set
+# BR2_PACKAGE_PALANTIR is not set
+# BR2_PACKAGE_PEERCAST is not set
+# BR2_PACKAGE_SETPWC is not set
+
+#
+# Serial communications & terminal emulation
+#
+# BR2_PACKAGE_HEYU is not set
+# BR2_PACKAGE_LRZSZ is not set
+# BR2_PACKAGE_MICROCOM is not set
+# BR2_PACKAGE_PICOCOM is not set
+# BR2_PACKAGE_SERDISPLIB is not set
+# BR2_PACKAGE_SETSERIAL is not set
+
+#
+# Utilities
+#
+# BR2_PACKAGE_BC is not set
+# BR2_PACKAGE_DC is not set
+# BR2_PACKAGE_GCOM is not set
+BR2_PACKAGE_GDBSERVER=y
+# BR2_PACKAGE_HDPARM is not set
+# BR2_PACKAGE_LSUSB is not set
+# BR2_PACKAGE_PCIUTILS is not set
+# BR2_PACKAGE_STRACE is not set
+# BR2_PACKAGE_UDEV is not set
+# BR2_PACKAGE_WATCHDOG is not set
+
+#
+# FileSystems related
+#
+# BR2_PACKAGE_DOSFSTOOLS is not set
+# BR2_PACKAGE_E2FSPROGS is not set
+# BR2_PACKAGE_LIBFUSE is not set
+# BR2_PACKAGE_SHFS_UTILS is not set
+
+#
+# util-linux
+#
+# BR2_PACKAGE_FDISK is not set
+# BR2_PACKAGE_LOSETUP is not set
+# BR2_PACKAGE_SWAP_UTILS is not set
+
+#
+# Bluetooth
+#
+# BR2_PACKAGE_BLUEZ_LIBS is not set
+# BR2_PACKAGE_BLUEZ_UTILS is not set
+# BR2_PACKAGE_MIAX is not set
+
+#
+# Extra stuff
+#
+# BR2_PACKAGE_SDK is not set
+# BR2_PACKAGE_IMAGEBUILDER is not set
+
+#
+# Target Root Filesystem
+#
+# BR2_TARGET_ROOTFS_JFFS2 is not set
+BR2_TARGET_ROOTFS_SQUASHFS_LZMA=y
+# BR2_TARGET_ROOTFS_TGZ is not set
+
+#
+# Kernel Configuration / Device Support
+#
+
+#
+# Device specific configuration
+#
+# BR2_PACKAGE_KMOD_CPMAC is not set
+# BR2_PACKAGE_KMOD_SANGAM_ATM_A is not set
+# BR2_PACKAGE_KMOD_SANGAM_ATM_B is not set
+
+#
+# Kernel modules
+#
+
+#
+# Networking modules
+#
+BR2_PACKAGE_KMOD_ATM=m
+# BR2_PACKAGE_KMOD_GRE is not set
+# BR2_PACKAGE_KMOD_IMQ is not set
+# BR2_PACKAGE_KMOD_IPIP is not set
+# BR2_PACKAGE_KMOD_IPV6 is not set
+BR2_PACKAGE_KMOD_PPP=y
+# BR2_PACKAGE_KMOD_MPPE is not set
+# BR2_PACKAGE_KMOD_PPPOATM is not set
+BR2_PACKAGE_KMOD_PPPOE=y
+# BR2_PACKAGE_KMOD_RING is not set
+# BR2_PACKAGE_KMOD_SCHED is not set
+# BR2_PACKAGE_KMOD_TUN is not set
+
+#
+# Filtering/Firewalling
+#
+# BR2_PACKAGE_KMOD_ARPTABLES is not set
+# BR2_PACKAGE_KMOD_EBTABLES is not set
+# BR2_PACKAGE_KMOD_IPTABLES is not set
+# BR2_PACKAGE_KMOD_IPTABLES_EXTRA is not set
+# BR2_PACKAGE_KMOD_IPT_CONNTRACK is not set
+# BR2_PACKAGE_KMOD_IPT_FILTER is not set
+# BR2_PACKAGE_KMOD_IPT_IPOPT is not set
+# BR2_PACKAGE_KMOD_IPT_IPSEC is not set
+# BR2_PACKAGE_KMOD_IPT_NAT is not set
+# BR2_PACKAGE_KMOD_IPT_NAT_EXTRA is not set
+# BR2_PACKAGE_KMOD_IPT_QUEUE is not set
+# BR2_PACKAGE_KMOD_IPT_ULOG is not set
+# BR2_PACKAGE_KMOD_IPT_EXTRA is not set
+
+#
+# Block devices support
+#
+BR2_PACKAGE_KMOD_LOOP=m
+BR2_PACKAGE_KMOD_NBD=m
+# BR2_PACKAGE_KMOD_CRYPTO is not set
+
+#
+# Filesystems support
+#
+# BR2_PACKAGE_KMOD_FS_CIFS is not set
+# BR2_PACKAGE_KMOD_FS_EXT2 is not set
+# BR2_PACKAGE_KMOD_FS_EXT3 is not set
+# BR2_PACKAGE_KMOD_FS_HFSPLUS is not set
+BR2_PACKAGE_KMOD_FS_NFS=y
+# BR2_PACKAGE_KMOD_FS_VFAT is not set
+# BR2_PACKAGE_KMOD_FS_XFS is not set
+
+#
+# Multimedia devices support
+#
+# BR2_PACKAGE_KMOD_SOUNDCORE is not set
+# BR2_PACKAGE_KMOD_VIDEODEV is not set
+
+#
+# Native Language support
+#
+# BR2_PACKAGE_KMOD_NLS_BASE is not set
+
+#
+# USB support
+#
+# BR2_PACKAGE_KMOD_USB is not set
+
+#
+# Misc. devices support
+#
+# BR2_PACKAGE_KMOD_AX25 is not set
+# BR2_PACKAGE_KMOD_BLUETOOTH is not set
+# BR2_PACKAGE_KMOD_LP is not set
+# BR2_PACKAGE_KMOD_SOFTDOG is not set
+
+#
+# Additional kernel modules
+#
+# BR2_PACKAGE_KMOD_FUSE is not set
+# BR2_PACKAGE_KMOD_MADWIFI_OLD is not set
+# BR2_PACKAGE_KMOD_MADWIFI is not set
+# BR2_PACKAGE_KMOD_MINI_FO is not set
+# BR2_PACKAGE_KMOD_OPENSWAN is not set
+# BR2_PACKAGE_KMOD_SHFS is not set
+# BR2_PACKAGE_KMOD_SPCA5XX is not set
+# BR2_PACKAGE_KMOD_SWITCH is not set
Index: target/linux/image/ar7/src/gzip.h
===================================================================
--- target/linux/image/ar7/src/gzip.h	(Revision 3803)
+++ target/linux/image/ar7/src/gzip.h	(Arbeitskopie)
@@ -14,25 +14,12 @@
 typedef unsigned long  ulg;
 
 
-static char *output_data;
-static ulg output_ptr;
-
 #ifndef NULL
 #define NULL 0
 #endif
 
 #define NOMEMCPY                /* Does routine memcpy exist? */
 
-//bvb static uch *inbuf;		/* input buffer */
-static uch *window;
-
-//bvb static uch outwin[WSIZE];
-
-//bvb static unsigned insize;		/* valid bytes in inbuf */
-static unsigned inptr;		/* index of next byte to process in inbuf */
-
-static unsigned outcnt;		/* bytes in output buffer */
-
 /* gzip flag byte */
 #define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
 #define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
@@ -46,6 +33,3 @@
 #define BMAX 16         /* maximum bit length of any code (16 for explode) */
 #define N_MAX 288       /* maximum number of codes in any set */
 
-static char *input_data;
-
-static void *freememstart;
Index: target/linux/image/ar7/src/uart16550.h
===================================================================
--- target/linux/image/ar7/src/uart16550.h	(Revision 0)
+++ target/linux/image/ar7/src/uart16550.h	(Revision 0)
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _uart16550_h_
+#define _uart16550_h_
+
+typedef         unsigned char uint8;
+typedef         unsigned int  uint32;
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_DATA_5BIT             0x0
+#define         UART16550_DATA_6BIT             0x1
+#define         UART16550_DATA_7BIT             0x2
+#define         UART16550_DATA_8BIT             0x3
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 stop);
+
+/* blocking call */
+uint8 Uart16550GetPoll(void);
+
+void Uart16550Put(uint8 byte);
+void Uart16550Puts(const char *string);
+
+#endif
Index: target/linux/image/ar7/src/entry.S
===================================================================
--- target/linux/image/ar7/src/entry.S	(Revision 0)
+++ target/linux/image/ar7/src/entry.S	(Revision 0)
@@ -0,0 +1,51 @@
+// Copy compressed code from RAM start (0x94000000) to a higher RAM address.
+// The decompressor will write the decompressed code to RAM start.
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+
+	.text
+	LEAF(tikernelunzip)
+	.set noreorder
+	.set mips32r2
+
+#if 1
+        // Copy decompressor code to the right place.
+	// This code only works if source and destination do not overlap
+	// or if source is at a higher memory address than destination.
+	// a0 = destination
+	// a1 = source
+	// a2 = destination end
+        la      a0,tikernelunzip
+        la      a1,0x94000000
+	la	a2,0xe0000
+        addu   a2,a0,a2
+$L1:    lw      t0, 0(a1)
+        sw      t0, 0(a0)
+        add     a1, 4
+        blt     a0, a2, $L1
+        add     a0, 4
+#else
+        // Move decompressor code to the right place.
+	// This code works if source and destination do not overlap
+	// or if source is at a lower memory address than destination.
+	// a0 = destination
+	// a1 = source
+	// a2 = destination end
+        la      a0,0xe0000
+        la      a1,0x94000000
+        la      a2,tikernelunzip
+	addu	a1,a1,a0
+	addu	a0,a2,a0
+$L1:    sub     a1,4
+        sub     a0,4
+        lw      t0,0(a1)
+        bne     a0,a2, $L1
+        sw      t0,0(a0)
+#endif
+	la      k0, tikernelunzip2
+	jr      k0
+	nop
+
+	.set	reorder
+	END(tikernelunzip)
Index: target/linux/image/ar7/src/zimage.script.in
===================================================================
--- target/linux/image/ar7/src/zimage.script.in	(Revision 3803)
+++ target/linux/image/ar7/src/zimage.script.in	(Arbeitskopie)
@@ -6,6 +6,6 @@
 	{
 		kernelimage = .;
 		*(.data)
-		kernelimage_end = .;
+		kernelimage_end = ALIGN(4);
 	}
 }
Index: target/linux/image/ar7/src/ld.script.in
===================================================================
--- target/linux/image/ar7/src/ld.script.in	(Revision 3803)
+++ target/linux/image/ar7/src/ld.script.in	(Arbeitskopie)
@@ -5,7 +5,7 @@
 {
 
 	/* Allocate memory space on top of kernel bss space */
-	. = 0x94200000;
+	. = 0x94300000;
 	.text :
 	{
 		*(.text)
Index: target/linux/image/ar7/src/loader.c
===================================================================
--- target/linux/image/ar7/src/loader.c	(Revision 3803)
+++ target/linux/image/ar7/src/loader.c	(Arbeitskopie)
@@ -15,37 +15,50 @@
 #include <linux/config.h>
 #include "gzip.h"
 #include "LzmaDecode.h"
+#include "loader.h"
 
+#if defined(NO_FIRMWARE)
+#include "uart16550.h"
+#endif
+
 /* Function prototypes */
-unsigned char get_byte(void);
-int tikernelunzip(int,char *[], char *[]);
-static int tidecompress(uch *, uch *);
+static int tidecompress(void);
+#if defined(DEBUG)
+static void print_i(int i);
+#endif
+static void print_s(const char *ptr);
+#define printf(s) print_s(s)
 
-void kernel_entry(int, char *[], char *[]);
-void (*ke)(int, char *[], char *[]); /* Gen reference to kernel function */
-void (*prnt)(unsigned int, char *);		/* Gen reference to Yamon print function */
-void printf(char *ptr);			/* Generate our own printf */
+static const unsigned char *input_data;
 
-int tikernelunzip(int argc, char *argv[], char *arge[])
+static inline unsigned char get_byte(void)
 {
-	extern unsigned int _ftext;
-	extern uch kernelimage[];
-	uch *in, *out;
+	return *input_data++;
+}
+
+int tikernelunzip2(int argc, const char *argv[], const char *arge[])
+{
 	int status;
 
-	printf("Launching kernel decompressor.\n");
+#if defined(DEBUG)
+	printf("argc = "); print_i(argc); printf("\n");
+	printf("argv = "); print_i((int)argv); printf("\n");
+	printf("arge = "); print_i((int)arge); printf("\n");
+#endif
+	argc = 0;
+	argv = 0;
+	arge = 0;
 
-	out = (unsigned char *) LOADADDR;
-	in = &(kernelimage[0]);
+	printf("\nLaunching kernel decompressor.\n");
 
-	status = tidecompress(in, out);
+	status = tidecompress();
 
 	if (status == 0) {
+		/* Gen reference to kernel function */
+		void (*ke)(int, const char *[], const char *[]) =
+			(void(*)(int, const char *[], const char*[]))kernel_entry;
 		printf("Kernel decompressor was successful ... launching kernel.\n");
-
-		ke = ( void(*)(int, char *[],char*[]))kernel_entry;
 		(*ke)(argc,argv,arge);
-
 		return (0);
 	} else {
 		printf("Error in decompression.\n");
@@ -53,9 +66,9 @@
 	}
 }
 
-#if 0
-char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
-void print_i(int i)
+#if defined(DEBUG)
+static const char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+static void print_i(int i)
 {
 	int j;
 	char buf[11];
@@ -63,7 +76,7 @@
 	buf[0] = '0';
 	buf[1] = 'x';
 	buf[10] = 0;
-	
+
 	for (j = 0; j < 8; j++)
 	{
 		buf[2 + 7 - j] = hex[i & 0xf];
@@ -74,21 +87,61 @@
 }
 #endif
 
-int tidecompress(uch *indata, uch *outdata)
+static const uch *searchmarker(const uch *indata, const uch *abort)
 {
-	extern unsigned int workspace;
-	extern unsigned char kernelimage[], kernelimage_end[];
+	const uch *first = indata;
+	while (indata < abort) {
+		if (*indata++ != 'l') {
+			continue;
+		}
+		if (*indata++ != 'z') {
+			indata--;
+			continue;
+		}
+		if (*indata++ != 'm') {
+			indata -= 2;
+			continue;
+		}
+		if (*indata++ != 'a') {
+			indata -= 3;
+			continue;
+		}
+		break;
+	}
+	if (indata == abort) {
+		indata = first;
+	}
+	return indata;
+}
+
+static int tidecompress(void)
+{
 	unsigned int i;  /* temp value */
 	unsigned int lc; /* literal context bits */
 	unsigned int lp; /* literal pos state bits */
 	unsigned int pb; /* pos state bits */
 	unsigned int osize; /* uncompressed size */
 	unsigned int wsize; /* window size */
+	uch *outdata = (unsigned char *) LOADADDR;
+	const uch *indata = &(kernelimage[0]);
 	unsigned int insize = kernelimage_end - kernelimage;
 	int status;
-	
-	output_ptr = 0;
-	output_data = outdata;
+
+	if (insize == 0) {
+		/* Special marker for auto configuration. */
+		/* Search start and size of lzma data. */
+		const uch *first = searchmarker(indata, indata + 10000);
+		const uch *last = searchmarker(first, indata + 1000000);
+		indata = first;
+		insize = last - first - 4;
+		if (first == last) {
+			printf("Kernel decompressor did not find data.\n");
+			return 1;
+		} else {
+			printf("Kernel decompressor found data.\n");
+		}
+	}
+
 	input_data = indata;
 
 	/* lzma args */
@@ -113,28 +166,26 @@
 	i = 0;
 	wsize = (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp))) * sizeof(CProb);
 
-	if ((status = LzmaDecode((unsigned char *) &workspace, wsize, lc, lp, pb,
-		indata + 13, insize - 13, (unsigned char *) output_data, osize, &i)) == LZMA_RESULT_OK)
+	if ((status = LzmaDecode(&(workspace[0]), wsize, lc, lp, pb,
+		indata + 13, insize - 13, outdata, osize, &i)) == LZMA_RESULT_OK)
 			return 0;
 
 	return status;
 }
 
-
-void printf(char *ptr)
+static void print_s(const char *ptr)
 {
+#if defined(NO_FIRMWARE)
+	while (*ptr) {
+		if (*ptr == '\n') {
+			Uart16550Put('\r');
+		}
+		Uart16550Put(*ptr);
+		ptr++;
+	}
+#else
 	unsigned int *tempptr = (unsigned int  *)0x90000534;
 	prnt = ( void (*)(unsigned int, char *)) *tempptr;
 	(*prnt)(0,ptr);
+#endif
 }
-
-unsigned char get_byte()
-{
-	unsigned char c;
-	
-	c = *input_data;
-	input_data++;
-
-	return c;
-}
-
Index: target/linux/image/ar7/src/LzmaDecode.c
===================================================================
--- target/linux/image/ar7/src/LzmaDecode.c	(Revision 3803)
+++ target/linux/image/ar7/src/LzmaDecode.c	(Arbeitskopie)
@@ -34,8 +34,8 @@
 
 typedef struct _CRangeDecoder
 {
-  Byte *Buffer;
-  Byte *BufferLim;
+  const Byte *Buffer;
+  const Byte *BufferLim;
   UInt32 Range;
   UInt32 Code;
   #ifdef _LZMA_IN_CB
@@ -45,7 +45,7 @@
   int ExtraBytes;
 } CRangeDecoder;
 
-Byte RangeDecoderReadByte(CRangeDecoder *rd)
+static Byte RangeDecoderReadByte(CRangeDecoder *rd)
 {
   if (rd->Buffer == rd->BufferLim)
   {
@@ -66,11 +66,11 @@
 /* #define ReadByte (*rd->Buffer++) */
 #define ReadByte (RangeDecoderReadByte(rd))
 
-void RangeDecoderInit(CRangeDecoder *rd,
+static void RangeDecoderInit(CRangeDecoder *rd,
   #ifdef _LZMA_IN_CB
     ILzmaInCallback *inCallback
   #else
-    Byte *stream, UInt32 bufferSize
+    const Byte *stream, UInt32 bufferSize
   #endif
     )
 {
@@ -93,7 +93,7 @@
 #define RC_FLUSH_VAR rd->Range = range; rd->Code = code;
 #define RC_NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | ReadByte; }
 
-UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
+static UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
 {
   RC_INIT_VAR
   UInt32 result = 0;
@@ -121,7 +121,7 @@
   return result;
 }
 
-int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
+static int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
 {
   UInt32 bound = (rd->Range >> kNumBitModelTotalBits) * *prob;
   if (rd->Code < bound)
@@ -159,7 +159,7 @@
 
 #define RC_GET_BIT(prob, mi) RC_GET_BIT2(prob, mi, ; , ;)               
 
-int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+static int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
 {
   int mi = 1;
   int i;
@@ -181,7 +181,7 @@
   return mi - (1 << numLevels);
 }
 
-int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+static int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
 {
   int mi = 1;
   int i;
@@ -206,7 +206,7 @@
   return symbol;
 }
 
-Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
+static Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
 { 
   int symbol = 1;
   #ifdef _LZMA_LOC_OPT
@@ -228,7 +228,7 @@
   return symbol;
 }
 
-Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
+static Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
 { 
   int symbol = 1;
   #ifdef _LZMA_LOC_OPT
@@ -286,7 +286,7 @@
 #define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
 #define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
 
-int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
+static int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
 {
   if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
     return RangeDecoderBitTreeDecode(p + LenLow +
@@ -354,7 +354,7 @@
     #ifdef _LZMA_IN_CB
     ILzmaInCallback *inCallback
     #else
-    unsigned char *inStream, UInt32 inSize
+    const unsigned char *inStream, UInt32 inSize
     #endif
     )
 {
@@ -438,7 +438,7 @@
     #ifdef _LZMA_IN_CB
     ILzmaInCallback *inCallback,
     #else
-    unsigned char *inStream, UInt32 inSize,
+    const unsigned char *inStream, UInt32 inSize,
     #endif
     unsigned char *outStream, UInt32 outSize,
     UInt32 *outSizeProcessed)
Index: target/linux/image/ar7/src/loader.h
===================================================================
--- target/linux/image/ar7/src/loader.h	(Revision 0)
+++ target/linux/image/ar7/src/loader.h	(Revision 0)
@@ -0,0 +1,14 @@
+// Header file for loader.c
+
+// tikernelunzip is the entry point (first function) of the boot loader.
+int tikernelunzip(int argc, const char *argv[], const char *arge[]);
+
+int tikernelunzip2(int argc, const char *argv[], const char *arge[]);
+
+extern void kernel_entry(int, char *[], char *[]);
+
+// Next symbol is defined in ld.script.
+extern unsigned char workspace[];
+
+// These symbols are defined in zimage.script.
+extern unsigned char kernelimage[], kernelimage_end[];
Index: target/linux/image/ar7/src/LzmaDecode.h
===================================================================
--- target/linux/image/ar7/src/LzmaDecode.h	(Revision 3803)
+++ target/linux/image/ar7/src/LzmaDecode.h	(Arbeitskopie)
@@ -91,7 +91,7 @@
   #ifdef _LZMA_IN_CB
     ILzmaInCallback *inCallback,
   #else
-    unsigned char *inStream, UInt32 inSize,
+    const unsigned char *inStream, UInt32 inSize,
   #endif
   #endif
     unsigned char *outStream, UInt32 outSize,
Index: target/linux/image/ar7/src/uart16550.c
===================================================================
--- target/linux/image/ar7/src/uart16550.c	(Revision 0)
+++ target/linux/image/ar7/src/uart16550.c	(Revision 0)
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+
+#include "uart16550.h"
+
+/* === CONFIG === */
+
+#define         BASE                   	0xa8610E00
+#define         MAX_BAUD                1152000
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+
+/* memory-mapped read/write of the port */
+#define         UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))
+#define         UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) = z)
+
+#define DEBUG_LED (*(unsigned short*)0xb7ffffc0)
+#define OutputLED(x)  (DEBUG_LED = x)
+
+void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 stop)
+{
+    /* disable interrupts */
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    /* set up baud rate */
+    { 
+        uint32 divisor;
+       
+        /* set DIAB bit */
+        UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+        
+        /* set divisor */
+        divisor = MAX_BAUD / baud;
+        UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);
+        UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);
+
+        /* clear DIAB bit */
+        UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
+    }
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);
+}
+
+uint8 Uart16550GetPoll()
+{
+    while((UART16550_READ(OFS_LINE_STATUS) & 0x1) == 0);
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void Uart16550Put(uint8 byte)
+{
+    while ((UART16550_READ(OFS_LINE_STATUS) &0x20) == 0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void Uart16550Puts(const char *string)
+{
+	while (*string) {
+		if (*string == '\n') {
+			Uart16550Put('\r');
+		}
+		Uart16550Put(*string);
+		string++;
+	}
+}
Index: target/linux/image/ar7/Makefile
===================================================================
--- target/linux/image/ar7/Makefile	(Revision 3803)
+++ target/linux/image/ar7/Makefile	(Arbeitskopie)
@@ -5,16 +5,23 @@
 PKG_BUILD_DIR:=$(BUILD_DIR)/ar7loader
 
 ifeq ($(IB),)
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+LOADADDR := 0x94000000
+else
 LOADADDR := 0x94020000
+endif
 KERNEL_ENTRY := 0x${shell nm $(KDIR)/linux-$(KERNEL)*/vmlinux | grep kernel_entry | cut -d' ' -f1}
 OUTPUT_FORMAT := elf32-tradlittlemips
 
 CFLAGS := -D__KERNEL__ -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
-	-fno-strict-aliasing -fno-common -fomit-frame-pointer -G 0 -mno-abicalls -fno-pic \
+	-fno-strict-aliasing -fomit-frame-pointer -G 0 -mno-abicalls -fno-pic \
 	-pipe -mlong-calls -fno-common \
 	-mabi=32 -march=mips32 -Wa,-32 -Wa,-march=mips32 -Wa,-mips32 -Wa,--trap \
 	-DLOADADDR=$(LOADADDR)
 
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+CFLAGS += -DNO_FIRMWARE
+endif
 
 $(PKG_BUILD_DIR):
 	mkdir -p $(PKG_BUILD_DIR)
@@ -27,6 +34,9 @@
 	sed -e 's/@@OUTPUT_FORMAT@@/$(OUTPUT_FORMAT)/' \
 	    -e 's/@@LOADADDR@@/$(LOADADDR)/' <$< >$@
 
+$(PKG_BUILD_DIR)/entry.o: src/entry.S
+	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
+
 $(PKG_BUILD_DIR)/cksum.o: $(PKG_BUILD_DIR)/cksum.c
 	$(HOSTCC) -o $@ $<
 
@@ -42,6 +52,18 @@
 $(PKG_BUILD_DIR)/loader.o: src/loader.c
 	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
 
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+$(PKG_BUILD_DIR)/uart16550.o: src/uart16550.c
+	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
+endif
+
+loader_objects := $(PKG_BUILD_DIR)/entry.o
+loader_objects += $(PKG_BUILD_DIR)/loader.o
+loader_objects += $(PKG_BUILD_DIR)/LzmaDecode.o
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+loader_objects += $(PKG_BUILD_DIR)/uart16550.o
+endif
+
 $(STAGING_DIR)/bin/srec2bin: src/srec2bin.c
 	$(HOSTCC) -o $@ $<
 
@@ -51,19 +73,30 @@
 $(KDIR)/vmlinux.bin: $(KDIR)/vmlinux.lzma compile
 	$(TARGET_CROSS)ld -T $(PKG_BUILD_DIR)/zimage.script -r -b binary $< -o $(KDIR)/zimage.o
 	$(TARGET_CROSS)ld -static -G 0 --defsym kernel_entry=$(KERNEL_ENTRY) -T $(PKG_BUILD_DIR)/ld.script \
-		$(PKG_BUILD_DIR)/loader.o \
-		$(PKG_BUILD_DIR)/LzmaDecode.o \
+		$(loader_objects) \
 		$(KDIR)/zimage.o \
 		-o $(KDIR)/loader
 	$(TARGET_CROSS)objcopy -O srec $(KDIR)/loader $(KDIR)/ram_zimage.sre
 	$(STAGING_DIR)/bin/srec2bin $(KDIR)/ram_zimage.sre $@
 	
+$(KDIR)/loader.bin: $(KDIR)/vmlinux.lzma compile $(loader_objects)
+	$(TARGET_CROSS)ld -T $(PKG_BUILD_DIR)/zimage.script -r -b binary $< -o $(KDIR)/zimage.o
+	$(TARGET_CROSS)ld -static -G 0 --defsym kernel_entry=$(KERNEL_ENTRY) -T $(PKG_BUILD_DIR)/ld.script \
+		$(loader_objects) \
+		--defsym kernelimage=0xb0110000 \
+		--defsym kernelimage_end=0xb0110000 \
+		--oformat binary -o $@
+
 $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin: $(KDIR)/vmlinux.bin 
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.raw: $(KDIR)/vmlinux.bin
 endif
 
 $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin:
 	$(CP) $(KDIR)/vmlinux.bin $@
 
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.raw:
+	$(TARGET_CROSS)objcopy -O binary $(KDIR)/loader $@
+
 ifeq ($(FS),jffs2-8MB)
 ALIGN:=bs=131072 conv=sync
 endif
@@ -93,15 +126,19 @@
 install: $(BIN_DIR)/openwrt-$(1)-$(KERNEL)-$(FS).img
 endef
 
+ifeq ($(BR2_LINUX_2_4_SERCOMM),y)
 $(eval $(call sercomm_template,dg834))
 $(eval $(call sercomm_template,jdr454wb))
+endif
 
+ifeq ($(BR2_LINUX_2_4_WAX),y)
 $(eval $(call pattern_template,AG1B))
 $(eval $(call pattern_template,WA22))
 $(eval $(call pattern_template,WAG2))
 $(eval $(call pattern_template,WA21))
 $(eval $(call pattern_template,WA31,-b))
 $(eval $(call pattern_template,WA32,-b))
+endif
 
 ifeq ($(IB),)
 clean:
@@ -109,14 +146,74 @@
 	rm -f $(BIN_DIR)/openwrt-$(BOARD)*
 
 prepare: $(PKG_BUILD_DIR) $(PKG_BUILD_DIR)/zimage.script $(PKG_BUILD_DIR)/ld.script
-compile: prepare $(PKG_BUILD_DIR)/loader.o $(PKG_BUILD_DIR)/LzmaDecode.o $(STAGING_DIR)/bin/srec2bin
+compile: prepare $(loader_objects) $(STAGING_DIR)/bin/srec2bin
 else
 clean:
 prepare:
 compile:
 endif
 
-install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-$(FS).bin
+ifeq ($(BR2_LINUX_2_4_WAX),y)
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin
+endif
+ifeq ($(BR2_LINUX_$(subst .,_,$(KERNEL))_SINUS154),y)
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.raw
+endif
+
+define sinus_template
+# kernel image (zip + lzma)
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-lzma-$(1).bin: $(KDIR)/loader.bin $(KDIR)/vmlinux.lzma
+	rm -rf /tmp/lzma
+	mkdir -p /tmp/lzma
+	ln -s $(KDIR)/loader.bin /tmp/lzma/soho.bin
+	zip -9Xv /tmp/lzma/soho.zip -j /tmp/lzma/soho.bin
+	echo -n lzma >>/tmp/lzma/soho.zip
+	cat $(KDIR)/vmlinux.lzma >>/tmp/lzma/soho.zip
+	echo -n lzma >>/tmp/lzma/soho.zip
+	$(STAGING_DIR)/bin/mkfirm -o $$@ -m $(2) /tmp/lzma/soho.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-lzma-$(1).bin
+
+# kernel image (zip)
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-$(1).bin: $(KDIR)/vmlinux
+	rm -f /tmp/soho.???
+	ln -s $(KDIR)/vmlinux /tmp/soho.bin
+	zip -9Xv /tmp/soho.zip -j /tmp/soho.bin
+	$(STAGING_DIR)/bin/mkfirm -o $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-$(1).bin -m $(2) /tmp/soho.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-$(1).bin
+
+# filesystem image (zip + squashfs)
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-squashfs-$(1).bin: $(KDIR)/root.squashfs
+	rm -f /tmp/pfs.???
+	#echo "PFS/0.9" | cat - /dev/zero | dd of=/tmp/pfs.img bs=65536 count=1
+	cat $(TOPDIR)/PFS.IMG /dev/zero | dd of=/tmp/pfs.img bs=65536 count=1
+	zip -9Xv /tmp/pfstmp.zip -j /tmp/pfs.img
+	cat /tmp/pfstmp.zip /dev/zero | dd of=/tmp/pfs.zip bs=65536 count=1
+	cat $(KDIR)/root.squashfs >>/tmp/pfs.zip
+	$(STAGING_DIR)/bin/mkfirm -o $$@ -m $(2) /tmp/pfs.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-squashfs-$(1).bin
+
+# runtime image (combined  lzma kernel and filesystem)
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-runtime-lzma-$(1).bin:
+	$(STAGING_DIR)/bin/mkfirm -o $$@ -m $(2) /tmp/pfs.zip /tmp/lzma/soho.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-runtime-lzma-$(1).bin
+
+# runtime image (combined  kernel and filesystem)
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-runtime-$(1).bin:
+	$(STAGING_DIR)/bin/mkfirm -o $$@ -m $(2) /tmp/pfs.zip /tmp/soho.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-runtime-$(1).bin
+endef
+
+ifeq ($(BR2_TARGET_ROOTFS_SQUASHFS_LZMA),y)
+ifeq ($(BR2_LINUX_$(subst .,_,$(KERNEL))_SINUS154_DSL_BASIC_SE),y)
+$(eval $(call sinus_template,SINUS154_DSL_BASIC_SE,BRN154BAS))
+endif
+ifeq ($(BR2_LINUX_$(subst .,_,$(KERNEL))_SINUS154_DSL_BASIC_3),y)
+$(eval $(call sinus_template,SINUS154_DSL_BASIC_3,BRNDTBAS3))
+endif
+endif
+
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-$(FS).bin
+
 install-ib:
 	mkdir -p $(IB_DIR)/build_$(ARCH)/linux-$(KERNEL)-$(BOARD)
 	$(CP) $(KDIR)/vmlinux.bin $(IB_DIR)/build_$(ARCH)/linux-$(KERNEL)-$(BOARD)/
Index: target/linux/ar7-2.4/config
===================================================================
--- target/linux/ar7-2.4/config	(Revision 3803)
+++ target/linux/ar7-2.4/config	(Arbeitskopie)
@@ -77,6 +77,7 @@
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SIBYTE_SB1xxx_SOC is not set
+CONFIG_MIPS_SINUS154=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TANBAC_TB0226 is not set
 # CONFIG_TANBAC_TB0229 is not set
@@ -135,23 +136,9 @@
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
 # CONFIG_SBUS is not set
-CONFIG_HOTPLUG=y
-
-#
-# PCMCIA/CardBus support
-#
+# CONFIG_HOTPLUG is not set
 # CONFIG_PCMCIA is not set
-
-#
-# PCI Hotplug Support
-#
 # CONFIG_HOTPLUG_PCI is not set
-# CONFIG_HOTPLUG_PCI_COMPAQ is not set
-# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
-# CONFIG_HOTPLUG_PCI_SHPC is not set
-# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
-# CONFIG_HOTPLUG_PCI_PCIE is not set
-# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -166,8 +153,7 @@
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs,jffs2 init=/etc/preinit noinitrd"
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -193,25 +179,13 @@
 CONFIG_MTD_CFI=y
 # CONFIG_MTD_JEDECPROBE is not set
 CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_CFI_B1 is not set
-CONFIG_MTD_CFI_B2=y
-# CONFIG_MTD_CFI_B4 is not set
-# CONFIG_MTD_CFI_B8 is not set
-CONFIG_MTD_CFI_I1=y
-# CONFIG_MTD_CFI_I2 is not set
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
 CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_AMDSTD is not set
 # CONFIG_MTD_CFI_STAA is not set
 # CONFIG_MTD_CFI_SSTSTD is not set
 # CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
+CONFIG_MTD_ROM=y
 # CONFIG_MTD_ABSENT is not set
 # CONFIG_MTD_OBSOLETE_CHIPS is not set
 # CONFIG_MTD_AMDSTD is not set
@@ -222,11 +196,9 @@
 # Mapping drivers for chip access
 #
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_AR7=y
-CONFIG_MTD_AR7_DEFAULTS=y
-CONFIG_MTD_AR7_START=0x10000000
-CONFIG_MTD_AR7_LEN=0x400000
-CONFIG_MTD_AR7_BUSWIDTH=2
+CONFIG_MTD_SINUS154=y
+# CONFIG_MTD_AR7 is not set
+# CONFIG_MTD_AR7_DEFAULTS is not set
 # CONFIG_MTD_PB1000 is not set
 # CONFIG_MTD_PB1500 is not set
 # CONFIG_MTD_PB1100 is not set
@@ -311,160 +283,32 @@
 #
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=m
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
 # CONFIG_FILTER is not set
 CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_FWMARK=y
-CONFIG_IP_ROUTE_NAT=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_TOS=y
-# CONFIG_IP_ROUTE_VERBOSE is not set
-# CONFIG_IP_PNP is not set
-CONFIG_NET_IPIP=m
-CONFIG_NET_IPGRE=m
-# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
-
-#
-#   IP: Netfilter Configuration
-#
-CONFIG_IP_NF_CONNTRACK=y
-CONFIG_IP_NF_CONNTRACK_MARK=y
-CONFIG_IP_NF_FTP=y
-CONFIG_IP_NF_AMANDA=m
-CONFIG_IP_NF_TFTP=m
-CONFIG_IP_NF_IRC=y
-CONFIG_IP_NF_CT_ACCT=m
-CONFIG_IP_NF_MATCH_CONNBYTES=m
-CONFIG_IP_NF_CT_PROTO_GRE=m
-CONFIG_IP_NF_PPTP=m
-CONFIG_IP_NF_H323=m
-CONFIG_IP_NF_MMS=m
-CONFIG_IP_NF_RTSP=m
-CONFIG_IP_NF_QUEUE=m
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_LIMIT=m
-CONFIG_IP_NF_MATCH_QUOTA=m
-CONFIG_IP_NF_SET=m
-CONFIG_IP_NF_SET_MAX=256
-CONFIG_IP_NF_SET_HASHSIZE=1024
-CONFIG_IP_NF_MATCH_SET=m
-CONFIG_IP_NF_TARGET_SET=m
-CONFIG_IP_NF_SET_IPMAP=m
-CONFIG_IP_NF_SET_PORTMAP=m
-CONFIG_IP_NF_SET_MACIPMAP=m
-CONFIG_IP_NF_SET_IPHASH=m
-CONFIG_IP_NF_SET_NETHASH=m
-CONFIG_IP_NF_SET_IPTREE=m
-CONFIG_IP_NF_MATCH_MAC=m
-CONFIG_IP_NF_MATCH_PKTTYPE=m
-CONFIG_IP_NF_MATCH_MARK=y
-CONFIG_IP_NF_MATCH_MULTIPORT=y
-CONFIG_IP_NF_MATCH_TOS=m
-CONFIG_IP_NF_MATCH_TIME=m
-CONFIG_IP_NF_MATCH_CONDITION=m
-CONFIG_IP_NF_MATCH_RECENT=m
-CONFIG_IP_NF_MATCH_ECN=m
-CONFIG_IP_NF_MATCH_IPP2P=m
-CONFIG_IP_NF_MATCH_DSCP=m
-CONFIG_IP_NF_MATCH_AH_ESP=m
-CONFIG_IP_NF_MATCH_LENGTH=m
-CONFIG_IP_NF_MATCH_TTL=m
-CONFIG_IP_NF_MATCH_TCPMSS=m
-CONFIG_IP_NF_MATCH_HELPER=m
-CONFIG_IP_NF_MATCH_STATE=y
-CONFIG_IP_NF_MATCH_CONNTRACK=m
-CONFIG_IP_NF_MATCH_CONNMARK=m
-CONFIG_IP_NF_MATCH_UNCLEAN=m
-CONFIG_IP_NF_MATCH_STRING=m
-CONFIG_IP_NF_MATCH_OWNER=m
-CONFIG_IP_NF_MATCH_LAYER7=m
-# CONFIG_IP_NF_MATCH_LAYER7_DEBUG is not set
-CONFIG_IP_NF_MATCH_LAYER7_MAXDATALEN=2048
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_MIRROR=m
-CONFIG_IP_NF_NAT=y
-CONFIG_IP_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_REDIRECT=m
-CONFIG_IP_NF_TARGET_NETMAP=m
-CONFIG_IP_NF_NAT_PPTP=m
-CONFIG_IP_NF_NAT_PROTO_GRE=m
-CONFIG_IP_NF_NAT_H323=m
-CONFIG_IP_NF_NAT_MMS=m
-CONFIG_IP_NF_NAT_RTSP=m
-CONFIG_IP_NF_NAT_AMANDA=m
-CONFIG_IP_NF_NAT_SNMP_BASIC=m
-CONFIG_IP_NF_NAT_IRC=y
-CONFIG_IP_NF_NAT_FTP=y
-CONFIG_IP_NF_NAT_TFTP=m
-CONFIG_IP_NF_MANGLE=y
-CONFIG_IP_NF_TARGET_TOS=m
-CONFIG_IP_NF_TARGET_ECN=m
-CONFIG_IP_NF_TARGET_DSCP=m
-CONFIG_IP_NF_TARGET_MARK=y
-CONFIG_IP_NF_TARGET_IMQ=m
-CONFIG_IP_NF_TARGET_CONNMARK=m
-CONFIG_IP_NF_TARGET_LOG=m
-CONFIG_IP_NF_TARGET_TTL=m
-CONFIG_IP_NF_TARGET_ULOG=m
-CONFIG_IP_NF_TARGET_TCPMSS=y
-CONFIG_IP_NF_ARPTABLES=m
-CONFIG_IP_NF_ARPFILTER=m
-CONFIG_IP_NF_ARP_MANGLE=m
-
-#
-#   IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-CONFIG_IPV6=m
-
-#
-#   IPv6: Netfilter Configuration
-#
-CONFIG_IP6_NF_QUEUE=m
-CONFIG_IP6_NF_IPTABLES=m
-CONFIG_IP6_NF_MATCH_LIMIT=m
-CONFIG_IP6_NF_MATCH_CONDITION=m
-CONFIG_IP6_NF_MATCH_MAC=m
-# CONFIG_IP6_NF_MATCH_RT is not set
-# CONFIG_IP6_NF_MATCH_OPTS is not set
-# CONFIG_IP6_NF_MATCH_FRAG is not set
-# CONFIG_IP6_NF_MATCH_HL is not set
-CONFIG_IP6_NF_MATCH_MULTIPORT=m
-CONFIG_IP6_NF_MATCH_OWNER=m
-CONFIG_IP6_NF_MATCH_MARK=m
-# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
-# CONFIG_IP6_NF_MATCH_AHESP is not set
-CONFIG_IP6_NF_MATCH_LENGTH=m
-CONFIG_IP6_NF_MATCH_EUI64=m
-CONFIG_IP6_NF_FILTER=m
-CONFIG_IP6_NF_TARGET_LOG=m
-CONFIG_IP6_NF_MANGLE=m
-CONFIG_IP6_NF_TARGET_MARK=m
-CONFIG_IP6_NF_TARGET_IMQ=m
+# CONFIG_IPV6 is not set
 # CONFIG_KHTTPD is not set
 
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
 # CONFIG_IP_SCTP is not set
-CONFIG_ATM=m
-# CONFIG_ATM_CLIP is not set
-# CONFIG_ATM_LANE is not set
-CONFIG_ATM_BR2684=m
-# CONFIG_ATM_BR2684_IPFILTER is not set
-CONFIG_VLAN_8021Q=y
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
 
 #
 #  
@@ -472,51 +316,26 @@
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
 # CONFIG_DECNET is not set
-CONFIG_BRIDGE=y
+# CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
 # CONFIG_LLC is not set
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
-CONFIG_WAN_ROUTER=m
+# CONFIG_WAN_ROUTER is not set
 # CONFIG_NET_FASTROUTE is not set
 # CONFIG_NET_HW_FLOWCONTROL is not set
 
 #
 # QoS and/or fair queueing
 #
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CBQ=m
-CONFIG_NET_SCH_HTB=m
-CONFIG_NET_SCH_CSZ=m
-CONFIG_NET_SCH_HFSC=m
-# CONFIG_NET_SCH_ATM is not set
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_SFQ=m
-CONFIG_NET_SCH_TEQL=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_SCH_GRED=m
-# CONFIG_NET_SCH_NETEM is not set
-CONFIG_NET_SCH_DSMARK=m
-CONFIG_NET_SCH_INGRESS=m
-CONFIG_NET_QOS=y
-CONFIG_NET_ESTIMATOR=y
-CONFIG_NET_CLS=y
-CONFIG_NET_CLS_TCINDEX=m
-CONFIG_NET_CLS_ROUTE4=m
-CONFIG_NET_CLS_ROUTE=y
-CONFIG_NET_CLS_FW=m
-CONFIG_NET_CLS_U32=m
-CONFIG_NET_CLS_RSVP=m
-CONFIG_NET_CLS_RSVP6=m
-CONFIG_NET_CLS_POLICE=y
+# CONFIG_NET_SCHED is not set
 
 #
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
-CONFIG_IPSEC_NAT_TRAVERSAL=y
+# CONFIG_IPSEC_NAT_TRAVERSAL is not set
 
 #
 # Telephony Support
@@ -534,83 +353,9 @@
 #
 # SCSI support
 #
-CONFIG_SCSI=m
+# CONFIG_SCSI is not set
 
 #
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=m
-CONFIG_SD_EXTRA_DEVS=5
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-CONFIG_CHR_DEV_SG=m
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_DEBUG_QUEUES is not set
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_SCSI_7000FASST is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AHA1542 is not set
-# CONFIG_SCSI_AHA1740 is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_MEGARAID is not set
-# CONFIG_SCSI_MEGARAID2 is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_SATA_AHCI is not set
-# CONFIG_SCSI_SATA_SVW is not set
-# CONFIG_SCSI_ATA_PIIX is not set
-# CONFIG_SCSI_SATA_NV is not set
-# CONFIG_SCSI_SATA_QSTOR is not set
-# CONFIG_SCSI_SATA_PROMISE is not set
-# CONFIG_SCSI_SATA_SX4 is not set
-# CONFIG_SCSI_SATA_SIL is not set
-# CONFIG_SCSI_SATA_SIS is not set
-# CONFIG_SCSI_SATA_ULI is not set
-# CONFIG_SCSI_SATA_VIA is not set
-# CONFIG_SCSI_SATA_VITESSE is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_DMA is not set
-# CONFIG_SCSI_EATA_PIO is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_NCR53C406A is not set
-# CONFIG_SCSI_NCR53C7xx is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PCI2000 is not set
-# CONFIG_SCSI_PCI2220I is not set
-# CONFIG_SCSI_PSI240I is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_SIM710 is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_U14_34F is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
@@ -631,7 +376,10 @@
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
-CONFIG_IMQ=m
+
+#
+# IMQ needs CONFIG_NETFILTER enabled
+#
 CONFIG_TUN=m
 CONFIG_NET_RANDOM=y
 # CONFIG_ETHERTAP is not set
@@ -640,7 +388,7 @@
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-CONFIG_MIPS_AVALANCHE_CPMAC=m
+CONFIG_MIPS_AVALANCHE_CPMAC=y
 CONFIG_MIPS_CPMAC_INIT_BUF_MALLOC=y
 CONFIG_MIPS_CPMAC_PORTS=1
 CONFIG_AVALANCHE_CPMAC_AUTO=y
@@ -674,16 +422,7 @@
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
 # CONFIG_PLIP is not set
-CONFIG_PPP=m
-# CONFIG_PPP_MULTILINK is not set
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=m
-# CONFIG_PPP_SYNC_TTY is not set
-CONFIG_PPP_DEFLATE=m
-CONFIG_PPP_BSDCOMP=m
-CONFIG_PPP_MPPE_MPPC=m
-CONFIG_PPPOE=m
-CONFIG_PPPOATM=m
+# CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 
 #
@@ -702,7 +441,7 @@
 # Prism54 PCI/PCMCIA GT/Duette Driver - 802.11(a/b/g)
 #
 # CONFIG_PRISM54 is not set
-# CONFIG_NET_WIRELESS is not set
+CONFIG_NET_WIRELESS=y
 
 #
 # Token Ring devices
@@ -710,7 +449,7 @@
 # CONFIG_TR is not set
 # CONFIG_NET_FC is not set
 # CONFIG_RCPCI is not set
-CONFIG_SHAPER=m
+# CONFIG_SHAPER is not set
 
 #
 # Wan interfaces
@@ -718,12 +457,6 @@
 # CONFIG_WAN is not set
 
 #
-# ATM drivers
-#
-# CONFIG_ATM_TCP is not set
-CONFIG_MIPS_SANGAM_ATM=m
-
-#
 # Amateur Radio support
 #
 # CONFIG_HAMRADIO is not set
@@ -762,7 +495,7 @@
 CONFIG_AR7_VLYNQ=y
 CONFIG_VLYNQ_CLK_LOCAL=y
 CONFIG_AR7_VLYNQ_PORTS=2
-CONFIG_AR7_ADAM2=y
+# CONFIG_AR7_ADAM2 is not set
 
 #
 # I2C support
@@ -800,7 +533,7 @@
 CONFIG_WATCHDOG=y
 CONFIG_WATCHDOG_NOWAYOUT=y
 CONFIG_AR7_WDT=y
-CONFIG_SOFT_WATCHDOG=m 
+# CONFIG_SOFT_WATCHDOG is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
@@ -835,33 +568,34 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
-CONFIG_HFSPLUS_FS=m
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
-CONFIG_EXT3_FS=m
-CONFIG_JBD=m
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
 # CONFIG_JBD_DEBUG is not set
-CONFIG_FAT_FS=m
+# CONFIG_FAT_FS is not set
 # CONFIG_MSDOS_FS is not set
 # CONFIG_UMSDOS_FS is not set
-CONFIG_VFAT_FS=m
+# CONFIG_VFAT_FS is not set
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS is not set
 # CONFIG_JFFS2_BBC_ARMLIB is not set
 # CONFIG_JFFS2_BBC_LZO is not set
-CONFIG_JFFS2_BBC_LZARI=y
+# CONFIG_JFFS2_BBC_LZARI is not set
 # CONFIG_JFFS2_BBC_LZHD is not set
 # CONFIG_JFFS2_BBC_LZSS is not set
 # CONFIG_CRAMFS is not set
 CONFIG_SQUASHFS=y
-# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
 CONFIG_TMPFS=y
 CONFIG_RAMFS=y
-CONFIG_ISO9660_FS=m
-CONFIG_JOLIET=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
 # CONFIG_ZISOFS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_JFS_DEBUG is not set
@@ -879,13 +613,13 @@
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_QNX4FS_RW is not set
 # CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UDF_FS is not set
 # CONFIG_UDF_RW is not set
 # CONFIG_UFS_FS is not set
 # CONFIG_UFS_FS_WRITE is not set
-CONFIG_XFS_FS=m
+# CONFIG_XFS_FS is not set
 # CONFIG_XFS_QUOTA is not set
 # CONFIG_XFS_RT is not set
 # CONFIG_XFS_TRACE is not set
@@ -896,19 +630,19 @@
 #
 # CONFIG_CODA_FS is not set
 # CONFIG_INTERMEZZO_FS is not set
-CONFIG_NFS_FS=m
+CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_DIRECTIO is not set
-# CONFIG_ROOT_NFS is not set
+CONFIG_ROOT_NFS=y
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
 # CONFIG_NFSD_TCP is not set
-CONFIG_SUNRPC=m
-CONFIG_LOCKD=m
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-CONFIG_CIFS=m
+# CONFIG_CIFS is not set
 # CONFIG_CIFS_STATS is not set
-CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_POSIX is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
@@ -929,63 +663,17 @@
 # CONFIG_OSF_PARTITION is not set
 # CONFIG_AMIGA_PARTITION is not set
 # CONFIG_ATARI_PARTITION is not set
-CONFIG_MAC_PARTITION=y
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
 # CONFIG_LDM_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
 # CONFIG_EFI_PARTITION is not set
 # CONFIG_SMB_NLS is not set
-CONFIG_NLS=y
+# CONFIG_NLS is not set
 
 #
-# Native Language Support
-#
-CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-
-#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -1008,39 +696,20 @@
 #
 # Bluetooth support
 #
-CONFIG_BLUEZ=m
-CONFIG_BLUEZ_L2CAP=m
-CONFIG_BLUEZ_SCO=m
-CONFIG_BLUEZ_RFCOMM=m
-CONFIG_BLUEZ_RFCOMM_TTY=y
-CONFIG_BLUEZ_BNEP=m
-CONFIG_BLUEZ_BNEP_MC_FILTER=y
-CONFIG_BLUEZ_BNEP_PROTO_FILTER=y
+# CONFIG_BLUEZ is not set
 
 #
-# Bluetooth device drivers
-#
-# CONFIG_BLUEZ_HCIUSB is not set
-CONFIG_BLUEZ_HCIUART=m
-CONFIG_BLUEZ_HCIUART_H4=y
-CONFIG_BLUEZ_HCIUART_BCSP=y
-CONFIG_BLUEZ_HCIUART_BCSP_TXCRC=y
-# CONFIG_BLUEZ_HCIBFUSB is not set
-# CONFIG_BLUEZ_HCIDTL1 is not set
-# CONFIG_BLUEZ_HCIBT3C is not set
-# CONFIG_BLUEZ_HCIBLUECARD is not set
-# CONFIG_BLUEZ_HCIBTUART is not set
-# CONFIG_BLUEZ_HCIVHCI is not set
-
-#
 # Kernel hacking
 #
 CONFIG_CROSSCOMPILE=y
-# CONFIG_RUNTIME_DEBUG is not set
-# CONFIG_KGDB is not set
-# CONFIG_GDB_CONSOLE is not set
-# CONFIG_DEBUG_INFO is not set
+CONFIG_RUNTIME_DEBUG=y
+CONFIG_KGDB=y
+CONFIG_GDB_CONSOLE=y
+CONFIG_DEBUG_INFO=y
 CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_FRAME_POINTER=y
+CONFIG_REMOTE_DEBUG=y
 # CONFIG_MIPS_UNCACHED is not set
 CONFIG_LOG_BUF_SHIFT=0
 
@@ -1076,5 +745,4 @@
 #
 # CONFIG_CRC32 is not set
 CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-# CONFIG_FW_LOADER is not set
+CONFIG_ZLIB_DEFLATE=m
Index: target/linux/ar7-2.4/patches/000-ar7_support.patch
===================================================================
--- target/linux/ar7-2.4/patches/000-ar7_support.patch	(Revision 3803)
+++ target/linux/ar7-2.4/patches/000-ar7_support.patch	(Arbeitskopie)
@@ -1959,7 +1959,7 @@
 +		int line;
 +		argptr += strlen("kgdb=ttyS");
 +		if (*argptr != '0' && *argptr != '1')
-+			printk("KGDB: Uknown serial line /dev/ttyS%c, "
++			printk("KGDB: Unknown serial line /dev/ttyS%c, "
 +					"falling back to /dev/ttyS1\n", *argptr);
 +		line = *argptr == '0' ? 0 : 1;
 +		printk("KGDB: Using serial line /dev/ttyS%d for session\n",
@@ -3123,7 +3123,7 @@
  
  	exception_handlers[n] = handler;
  	if (n == 0 && cpu_has_divec) {
-+	  printk(KERN_DEBUG "%s: using long jump via k0 to reach %08x\n",
++	  printk(KERN_DEBUG "%s: using long jump via k0 to reach %08lx\n",
 +		 __FUNCTION__, handler);
 +	  /* where does the 8 byte limit mentioned in head.S come from??? */
 +	  if (handler > 0x0fffffff) { /* maximum for single J instruction */
@@ -3250,424 +3250,6 @@
  source drivers/i2c/Config.in
  
  mainmenu_option next_comment
-diff -urN linux.old/drivers/char/Config.in.orig linux.dev/drivers/char/Config.in.orig
---- linux.old/drivers/char/Config.in.orig	1970-01-01 01:00:00.000000000 +0100
-+++ linux.dev/drivers/char/Config.in.orig	2005-11-10 01:10:45.863575750 +0100
-@@ -0,0 +1,414 @@
-+#
-+# Character device configuration
-+#
-+mainmenu_option next_comment
-+comment 'Character devices'
-+
-+bool 'Virtual terminal' CONFIG_VT
-+if [ "$CONFIG_VT" = "y" ]; then
-+   bool '  Support for console on virtual terminal' CONFIG_VT_CONSOLE
-+   if [ "$CONFIG_GSC_LASI" = "y" ]; then
-+      bool '    Support for Lasi/Dino PS2 port' CONFIG_GSC_PS2
-+   fi
-+fi
-+tristate 'Standard/generic (8250/16550 and compatible UARTs) serial support' CONFIG_SERIAL
-+if [ "$CONFIG_SERIAL" = "y" ]; then
-+   bool '  Support for console on serial port' CONFIG_SERIAL_CONSOLE
-+   if [ "$CONFIG_GSC_LASI" = "y" ]; then
-+      bool '   serial port on GSC support' CONFIG_SERIAL_GSC
-+   fi
-+   if [ "$CONFIG_IA64" = "y" ]; then
-+      bool '  Support for serial port described by EFI HCDP table' CONFIG_SERIAL_HCDP
-+   fi
-+   if [ "$CONFIG_ARCH_ACORN" = "y" ]; then
-+      tristate '   Atomwide serial port support' CONFIG_ATOMWIDE_SERIAL
-+      tristate '   Dual serial port support' CONFIG_DUALSP_SERIAL
-+   fi
-+fi
-+dep_mbool 'Extended dumb serial driver options' CONFIG_SERIAL_EXTENDED $CONFIG_SERIAL
-+if [ "$CONFIG_SERIAL_EXTENDED" = "y" ]; then
-+   bool '  Support more than 4 serial ports' CONFIG_SERIAL_MANY_PORTS
-+   bool '  Support for sharing serial interrupts' CONFIG_SERIAL_SHARE_IRQ
-+   bool '  Autodetect IRQ on standard ports (unsafe)' CONFIG_SERIAL_DETECT_IRQ
-+   bool '  Support special multiport boards' CONFIG_SERIAL_MULTIPORT
-+   bool '  Support the Bell Technologies HUB6 card' CONFIG_HUB6
-+fi
-+bool 'Non-standard serial port support' CONFIG_SERIAL_NONSTANDARD
-+if [ "$CONFIG_SERIAL_NONSTANDARD" = "y" ]; then
-+   tristate '  Computone IntelliPort Plus serial support' CONFIG_COMPUTONE
-+   tristate '  Comtrol Rocketport support' CONFIG_ROCKETPORT
-+   tristate '  Cyclades async mux support' CONFIG_CYCLADES
-+   if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_CYCLADES" != "n" ]; then
-+      bool '    Cyclades-Z interrupt mode operation (EXPERIMENTAL)' CONFIG_CYZ_INTR
-+   fi
-+   if [ "$CONFIG_X86_64" != "y" ]; then
-+      tristate '  Digiboard Intelligent Async Support' CONFIG_DIGIEPCA
-+      if [ "$CONFIG_DIGIEPCA" = "n" ]; then
-+         tristate '  Digiboard PC/Xx Support' CONFIG_DIGI
-+      fi
-+   fi
-+   dep_tristate '  Hayes ESP serial port support' CONFIG_ESPSERIAL $CONFIG_ISA
-+   tristate '  Moxa Intellio support' CONFIG_MOXA_INTELLIO
-+   tristate '  Moxa SmartIO support' CONFIG_MOXA_SMARTIO
-+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-+      dep_tristate '  Multi-Tech multiport card support (EXPERIMENTAL)' CONFIG_ISI m
-+   fi
-+   tristate '  Microgate SyncLink card support' CONFIG_SYNCLINK
-+   tristate '  SyncLink Multiport support' CONFIG_SYNCLINKMP
-+   tristate '  HDLC line discipline support' CONFIG_N_HDLC
-+   tristate '  SDL RISCom/8 card support' CONFIG_RISCOM8
-+   if [ "$CONFIG_X86_64" != "y" ]; then
-+      tristate '  Specialix IO8+ card support' CONFIG_SPECIALIX
-+      if [ "$CONFIG_SPECIALIX" != "n" ]; then
-+         bool '  Specialix DTR/RTS pin is RTS' CONFIG_SPECIALIX_RTSCTS
-+      fi 
-+      tristate '  Specialix SX (and SI) card support' CONFIG_SX
-+      tristate '  Specialix RIO system support' CONFIG_RIO
-+      if [ "$CONFIG_RIO" != "n" ]; then
-+        bool '    Support really old RIO/PCI cards' CONFIG_RIO_OLDPCI
-+      fi
-+   fi
-+   bool '  Stallion multiport serial support' CONFIG_STALDRV
-+   if [ "$CONFIG_STALDRV" = "y" ]; then
-+     tristate '    Stallion EasyIO or EC8/32 support' CONFIG_STALLION
-+     tristate '    Stallion EC8/64, ONboard, Brumby support' CONFIG_ISTALLION
-+   fi
-+   if [ "$CONFIG_PARISC" = "y" ]; then
-+     if [ "$CONFIG_PDC_CONSOLE" != "y" ]; then
-+       bool '  Serial MUX support' CONFIG_SERIAL_MUX CONFIG_SERIAL_NONSTANDARD
-+     fi
-+     if [ "$CONFIG_SERIAL_MUX" != "y" ]; then
-+       bool '  PDC software console support' CONFIG_PDC_CONSOLE CONFIG_SERIAL_NONSTANDARD
-+     fi
-+   fi
-+   if [ "$CONFIG_MIPS" = "y" ]; then
-+      bool '  TX3912/PR31700 serial port support' CONFIG_SERIAL_TX3912
-+      dep_bool '     Console on TX3912/PR31700 serial port' CONFIG_SERIAL_TX3912_CONSOLE $CONFIG_SERIAL_TX3912
-+      bool '  TMPTX39XX/49XX serial port support' CONFIG_SERIAL_TXX9
-+      dep_bool '     Console on TMPTX39XX/49XX serial port' CONFIG_SERIAL_TXX9_CONSOLE $CONFIG_SERIAL_TXX9
-+      if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
-+	 bool '  Enable Au1x00 UART Support' CONFIG_AU1X00_UART
-+	 if [ "$CONFIG_AU1X00_UART" = "y" ]; then
-+	    bool '        Enable Au1x00 serial console' CONFIG_AU1X00_SERIAL_CONSOLE
-+         fi
-+         dep_tristate '  Au1x00 USB TTY Device support' CONFIG_AU1X00_USB_TTY $CONFIG_SOC_AU1X00
-+	    if [ "$CONFIG_AU1000_USB_TTY" != "y" ]; then
-+	       dep_tristate '  Au1x00 USB Raw Device support' CONFIG_AU1X00_USB_RAW $CONFIG_SOC_AU1X00
-+	    fi
-+	    if [ "$CONFIG_AU1X00_USB_TTY" != "n" -o \
-+	         "$CONFIG_AU1X00_USB_RAW" != "n" ]; then
-+		 define_bool CONFIG_AU1X00_USB_DEVICE y
-+	    fi
-+      fi
-+      bool '  TXx927 SIO support' CONFIG_TXX927_SERIAL 
-+      if [ "$CONFIG_TXX927_SERIAL" = "y" ]; then
-+         bool '    TXx927 SIO Console support' CONFIG_TXX927_SERIAL_CONSOLE  
-+      fi                             
-+      if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
-+         bool '  Support for BCM1xxx onchip DUART' CONFIG_SIBYTE_SB1250_DUART
-+         if [ "$CONFIG_SIBYTE_SB1250_DUART" = "y" ]; then
-+            bool '    Console on BCM1xxx DUART' CONFIG_SIBYTE_SB1250_DUART_CONSOLE
-+            if [ "$CONFIG_SIBYTE_SB1250_DUART_CONSOLE" = "y" ]; then
-+               define_bool CONFIG_SERIAL_CONSOLE y
-+            fi
-+         fi
-+      fi
-+   fi
-+   if [ "$CONFIG_DECSTATION" = "y" ]; then
-+      bool '  DECstation serial support' CONFIG_SERIAL_DEC
-+      dep_bool '    Support for console on a DECstation serial port' CONFIG_SERIAL_DEC_CONSOLE $CONFIG_SERIAL_DEC
-+      dep_bool '    DZ11 serial support' CONFIG_DZ $CONFIG_SERIAL_DEC $CONFIG_MIPS32
-+      dep_bool '    Z85C30 serial support' CONFIG_ZS $CONFIG_SERIAL_DEC $CONFIG_TC
-+   fi
-+   if [ "$CONFIG_SGI_IP22" = "y" ]; then
-+      bool '  SGI Zilog85C30 serial support' CONFIG_IP22_SERIAL
-+   fi
-+   if [ "$CONFIG_IA64" = "y" ]; then
-+      bool '  SGI SN2 l1 serial port support' CONFIG_SGI_L1_SERIAL
-+      if [ "$CONFIG_SGI_L1_SERIAL" = "y" ]; then
-+	 bool '    SGI SN2 l1 Console support' CONFIG_SGI_L1_SERIAL_CONSOLE
-+      fi
-+      if [ "$CONFIG_IA64_GENERIC" = "y" -o "$CONFIG_IA64_SGI_SN2" = "y" ]; then
-+	 bool '  SGI SN2 IOC4 serial port support' CONFIG_SGI_IOC4_SERIAL
-+      fi
-+   fi
-+fi
-+if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_ZORRO" = "y" ]; then
-+   tristate 'Commodore A2232 serial support (EXPERIMENTAL)' CONFIG_A2232
-+fi
-+if [ "$CONFIG_FOOTBRIDGE" = "y" ]; then
-+   bool 'DC21285 serial port support' CONFIG_SERIAL_21285
-+   if [ "$CONFIG_SERIAL_21285" = "y" ]; then
-+      if [ "$CONFIG_OBSOLETE" = "y" ]; then
-+         bool '  Use /dev/ttyS0 device (OBSOLETE)' CONFIG_SERIAL_21285_OLD
-+      fi
-+      bool '  Console on DC21285 serial port' CONFIG_SERIAL_21285_CONSOLE
-+   fi
-+   if [ "$CONFIG_PARISC" = "y" ]; then
-+     bool '  PDC software console support' CONFIG_PDC_CONSOLE
-+   fi
-+fi
-+if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
-+   bool 'Enable Qtronix 990P Keyboard Support' CONFIG_QTRONIX_KEYBOARD
-+   if [ "$CONFIG_QTRONIX_KEYBOARD" = "y" ]; then
-+     define_bool CONFIG_IT8172_CIR y
-+   else
-+     bool '    Enable PS2 Keyboard Support' CONFIG_PC_KEYB
-+   fi
-+   bool 'Enable Smart Card Reader 0 Support ' CONFIG_IT8172_SCR0
-+   bool 'Enable Smart Card Reader 1 Support ' CONFIG_IT8172_SCR1
-+fi
-+if [ "$CONFIG_MIPS_IVR" = "y" ]; then
-+   bool 'Enable Qtronix 990P Keyboard Support' CONFIG_QTRONIX_KEYBOARD
-+   if [ "$CONFIG_QTRONIX_KEYBOARD" = "y" ]; then
-+     define_bool CONFIG_IT8172_CIR y
-+   fi
-+   bool 'Enable Smart Card Reader 0 Support ' CONFIG_IT8172_SCR0
-+fi
-+if [ "$CONFIG_CPU_VR41XX" = "y" ]; then
-+   bool 'NEC VR4100 series Keyboard Interface Unit Support ' CONFIG_VR41XX_KIU
-+fi
-+bool 'Unix98 PTY support' CONFIG_UNIX98_PTYS
-+if [ "$CONFIG_UNIX98_PTYS" = "y" ]; then
-+   int 'Maximum number of Unix98 PTYs in use (0-2048)' CONFIG_UNIX98_PTY_COUNT 256
-+fi
-+if [ "$CONFIG_PARPORT" != "n" ]; then
-+   dep_tristate 'Parallel printer support' CONFIG_PRINTER $CONFIG_PARPORT
-+   if [ "$CONFIG_PRINTER" != "n" ]; then
-+      bool '  Support for console on line printer' CONFIG_LP_CONSOLE
-+   fi
-+   dep_tristate 'Support for user-space parallel port device drivers' CONFIG_PPDEV $CONFIG_PARPORT
-+   dep_tristate 'Texas Instruments parallel link cable support' CONFIG_TIPAR $CONFIG_PARPORT
-+fi
-+
-+if [ "$CONFIG_PPC64" = "y" ] ; then 
-+   bool 'pSeries Hypervisor Virtual Console support' CONFIG_HVC_CONSOLE
-+fi
-+if [ "$CONFIG_ALL_PPC" = "y" ]; then
-+   tristate 'Total Impact briQ front panel driver' CONFIG_BRIQ_PANEL
-+fi
-+
-+if [ "$CONFIG_AR7" = "y" ]; then  
-+   bool 'VLYNQ support for the TI SOC' CONFIG_AR7_VLYNQ
-+   dep_bool 'VLYNQ clock source Internal' CONFIG_VLYNQ_CLK_LOCAL $CONFIG_AR7_VLYNQ
-+                   
-+   define_int CONFIG_AR7_VLYNQ_PORTS 2 
-+fi                                                                                             
-+
-+source drivers/i2c/Config.in
-+
-+mainmenu_option next_comment
-+comment 'Mice'
-+tristate 'Bus Mouse Support' CONFIG_BUSMOUSE
-+if [ "$CONFIG_BUSMOUSE" != "n" ]; then
-+   dep_tristate '  ATIXL busmouse support' CONFIG_ATIXL_BUSMOUSE $CONFIG_BUSMOUSE
-+   dep_tristate '  Logitech busmouse support' CONFIG_LOGIBUSMOUSE $CONFIG_BUSMOUSE
-+   dep_tristate '  Microsoft busmouse support' CONFIG_MS_BUSMOUSE $CONFIG_BUSMOUSE
-+   if [ "$CONFIG_ADB" = "y" -a "$CONFIG_ADB_KEYBOARD" = "y" ]; then
-+      dep_tristate '  Apple Desktop Bus mouse support (old driver)' CONFIG_ADBMOUSE $CONFIG_BUSMOUSE
-+   fi
-+#   if [ "$CONFIG_DECSTATION" = "y" ]; then
-+#      dep_bool '  MAXINE Access.Bus mouse (VSXXX-BB/GB) support' CONFIG_DTOP_MOUSE $CONFIG_ACCESSBUS
-+#   fi
-+fi
-+
-+tristate 'Mouse Support (not serial and bus mice)' CONFIG_MOUSE
-+if [ "$CONFIG_MOUSE" != "n" ]; then
-+   bool '  PS/2 mouse (aka "auxiliary device") support' CONFIG_PSMOUSE
-+   tristate '  C&T 82C710 mouse port support (as on TI Travelmate)' CONFIG_82C710_MOUSE
-+   tristate '  PC110 digitizer pad support' CONFIG_PC110_PAD
-+   tristate '  MK712 touch screen support' CONFIG_MK712_MOUSE
-+fi
-+endmenu
-+
-+source drivers/char/joystick/Config.in
-+
-+tristate 'QIC-02 tape support' CONFIG_QIC02_TAPE
-+if [ "$CONFIG_QIC02_TAPE" != "n" ]; then
-+   bool '  Do you want runtime configuration for QIC-02' CONFIG_QIC02_DYNCONF
-+   if [ "$CONFIG_QIC02_DYNCONF" != "y" ]; then
-+      comment '  Edit configuration parameters in ./include/linux/tpqic02.h!'
-+   else
-+      comment '  Setting runtime QIC-02 configuration is done with qic02conf'
-+      comment '  from the tpqic02-support package.  It is available at'
-+      comment '  metalab.unc.edu or ftp://titus.cfw.com/pub/Linux/util/'
-+   fi
-+fi
-+
-+tristate 'IPMI top-level message handler' CONFIG_IPMI_HANDLER
-+dep_mbool '  Generate a panic event to all BMCs on a panic' CONFIG_IPMI_PANIC_EVENT $CONFIG_IPMI_HANDLER
-+dep_tristate '  Device interface for IPMI' CONFIG_IPMI_DEVICE_INTERFACE $CONFIG_IPMI_HANDLER
-+dep_tristate '  IPMI KCS handler' CONFIG_IPMI_KCS $CONFIG_IPMI_HANDLER
-+dep_tristate '  IPMI Watchdog Timer' CONFIG_IPMI_WATCHDOG $CONFIG_IPMI_HANDLER
-+
-+mainmenu_option next_comment
-+comment 'Watchdog Cards'
-+bool 'Watchdog Timer Support'	CONFIG_WATCHDOG
-+if [ "$CONFIG_WATCHDOG" != "n" ]; then
-+   bool '  Disable watchdog shutdown on close' CONFIG_WATCHDOG_NOWAYOUT
-+   tristate '  Acquire SBC Watchdog Timer' CONFIG_ACQUIRE_WDT
-+   tristate '  Advantech SBC Watchdog Timer' CONFIG_ADVANTECH_WDT
-+   tristate '  ALi M7101 PMU on ALi 1535D+ Watchdog Timer' CONFIG_ALIM1535_WDT
-+   tristate '  ALi M7101 PMU Watchdog Timer' CONFIG_ALIM7101_WDT
-+   tristate '  AMD "Elan" SC520 Watchdog Timer' CONFIG_SC520_WDT
-+   tristate '  Berkshire Products PC Watchdog' CONFIG_PCWATCHDOG
-+   if [ "$CONFIG_FOOTBRIDGE" = "y" ]; then
-+      tristate '  DC21285 watchdog' CONFIG_21285_WATCHDOG
-+      if [ "$CONFIG_ARCH_NETWINDER" = "y" ]; then
-+         tristate '  NetWinder WB83C977 watchdog' CONFIG_977_WATCHDOG
-+      fi
-+   fi
-+   tristate '  Eurotech CPU-1220/1410 Watchdog Timer' CONFIG_EUROTECH_WDT
-+   tristate '  IB700 SBC Watchdog Timer' CONFIG_IB700_WDT
-+   tristate '  ICP ELectronics Wafer 5823 Watchdog' CONFIG_WAFER_WDT
-+   tristate '  Intel i810 TCO timer / Watchdog' CONFIG_I810_TCO
-+   tristate '  Mixcom Watchdog' CONFIG_MIXCOMWD 
-+   tristate '  SBC-60XX Watchdog Timer' CONFIG_60XX_WDT
-+   dep_tristate '  SC1200 Watchdog Timer (EXPERIMENTAL)' CONFIG_SC1200_WDT $CONFIG_EXPERIMENTAL
-+   tristate '  NatSemi SCx200 Watchdog' CONFIG_SCx200_WDT
-+   tristate '  Software Watchdog' CONFIG_SOFT_WATCHDOG
-+   tristate '  W83877F (EMACS) Watchdog Timer' CONFIG_W83877F_WDT
-+   tristate '  WDT Watchdog timer' CONFIG_WDT
-+   tristate '  WDT PCI Watchdog timer' CONFIG_WDTPCI
-+   if [ "$CONFIG_WDT" != "n" ]; then
-+      bool '    WDT501 features' CONFIG_WDT_501
-+      if [ "$CONFIG_WDT_501" = "y" ]; then
-+         bool '      Fan Tachometer' CONFIG_WDT_501_FAN
-+      fi
-+   fi
-+   tristate '  ZF MachZ Watchdog' CONFIG_MACHZ_WDT
-+   if [ "$CONFIG_SGI_IP22" = "y" ]; then
-+      dep_tristate '  Indy/I2 Hardware Watchdog' CONFIG_INDYDOG $CONFIG_SGI_IP22
-+   fi
-+   if [ "$CONFIG_8xx" = "y" ]; then
-+      tristate '  MPC8xx Watchdog Timer' CONFIG_8xx_WDT
-+   fi
-+fi
-+endmenu
-+
-+if [ "$CONFIG_ARCH_NETWINDER" = "y" ]; then
-+   tristate 'NetWinder thermometer support' CONFIG_DS1620
-+   tristate 'NetWinder Button' CONFIG_NWBUTTON
-+   if [ "$CONFIG_NWBUTTON" != "n" ]; then
-+      bool '  Reboot Using Button' CONFIG_NWBUTTON_REBOOT
-+   fi
-+   tristate 'NetWinder flash support' CONFIG_NWFLASH
-+fi
-+tristate 'NatSemi SCx200 Support' CONFIG_SCx200
-+dep_tristate '  NatSemi SCx200 GPIO Support' CONFIG_SCx200_GPIO $CONFIG_SCx200
-+
-+if [ "$CONFIG_IA64_GENERIC" = "y" -o "$CONFIG_IA64_SGI_SN2" = "y" ] ; then
-+   bool 'SGI SN2 fetchop support' CONFIG_FETCHOP
-+fi
-+
-+if [ "$CONFIG_X86" = "y" -o "$CONFIG_X86_64" = "y" ]; then
-+   dep_tristate 'AMD 768/8111 Random Number Generator support' CONFIG_AMD_RNG $CONFIG_PCI
-+fi
-+if [ "$CONFIG_X86" = "y" -o "$CONFIG_IA64" = "y" ]; then
-+   dep_tristate 'Intel i8x0 Random Number Generator support' CONFIG_INTEL_RNG $CONFIG_PCI
-+fi
-+if [ "$CONFIG_X86" = "y" -o "$CONFIG_IA64" = "y" -o \
-+     "$CONFIG_X86_64" = "y" ]; then
-+   dep_tristate 'Intel/AMD/VIA HW Random Number Generator support' CONFIG_HW_RANDOM $CONFIG_PCI
-+fi
-+dep_tristate 'AMD 76x native power management (Experimental)' CONFIG_AMD_PM768 $CONFIG_PCI
-+tristate '/dev/nvram support' CONFIG_NVRAM
-+tristate 'Enhanced Real Time Clock Support' CONFIG_RTC
-+if [ "$CONFIG_IA64" = "y" ]; then
-+   bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
-+fi
-+if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
-+   bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
-+fi
-+if [ "$CONFIG_SGI_IP22" = "y" ]; then
-+   tristate 'Dallas DS1286 RTC support' CONFIG_DS1286
-+fi
-+if [ "$CONFIG_SGI_IP27" = "y" ]; then
-+   tristate 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
-+fi
-+if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" -o "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
-+   tristate 'Dallas DS1742 RTC support' CONFIG_DS1742
-+fi
-+
-+tristate 'Double Talk PC internal speech card support' CONFIG_DTLK
-+tristate 'Siemens R3964 line discipline' CONFIG_R3964
-+tristate 'Applicom intelligent fieldbus card support' CONFIG_APPLICOM
-+if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_X86" = "y" -a "$CONFIG_X86_64" != "y" ]; then
-+   dep_tristate 'Sony Vaio Programmable I/O Control Device support (EXPERIMENTAL)' CONFIG_SONYPI $CONFIG_PCI
-+fi
-+
-+mainmenu_option next_comment
-+comment 'Ftape, the floppy tape device driver'
-+tristate 'Ftape (QIC-80/Travan) support' CONFIG_FTAPE
-+if [ "$CONFIG_FTAPE" != "n" ]; then
-+   source drivers/char/ftape/Config.in
-+fi
-+
-+endmenu
-+
-+if [ "$CONFIG_GART_IOMMU" = "y" ]; then
-+	bool '/dev/agpgart (AGP Support)' CONFIG_AGP
-+	define_bool CONFIG_AGP_AMD_K8 y
-+else
-+	tristate '/dev/agpgart (AGP Support)' CONFIG_AGP
-+fi      
-+if [ "$CONFIG_AGP" != "n" ]; then
-+   bool '  Intel 440LX/BX/GX and I815/I820/I830M/I830MP/I840/I845/I850/I860 support' CONFIG_AGP_INTEL
-+   bool '  Intel I810/I815/I830M (on-board) support' CONFIG_AGP_I810
-+   bool '  VIA chipset support' CONFIG_AGP_VIA
-+   bool '  AMD Irongate, 761, and 762 support' CONFIG_AGP_AMD
-+   if [ "$CONFIG_GART_IOMMU" != "y" ]; then
-+      bool '  AMD Opteron/Athlon64 on-CPU GART support' CONFIG_AGP_AMD_K8
-+   fi   
-+   bool '  Generic SiS support' CONFIG_AGP_SIS
-+   bool '  ALI chipset support' CONFIG_AGP_ALI
-+   bool '  Serverworks LE/HE support' CONFIG_AGP_SWORKS
-+   if [ "$CONFIG_X86" = "y" ]; then
-+      bool '  NVIDIA chipset support' CONFIG_AGP_NVIDIA
-+   fi
-+   if [ "$CONFIG_IA64" = "y" ]; then
-+      bool '  Intel 460GX support' CONFIG_AGP_I460
-+      bool '  HP ZX1 AGP support' CONFIG_AGP_HP_ZX1
-+   fi
-+   bool '  ATI IGP chipset support' CONFIG_AGP_ATI
-+fi
-+
-+mainmenu_option next_comment
-+comment 'Direct Rendering Manager (XFree86 DRI support)'
-+bool 'Direct Rendering Manager (XFree86 DRI support)' CONFIG_DRM
-+if [ "$CONFIG_DRM" = "y" ]; then
-+   bool '  Build drivers for old (XFree 4.0) DRM' CONFIG_DRM_OLD
-+   if [ "$CONFIG_DRM_OLD" = "y" ]; then
-+      comment 'DRM 4.0 drivers'
-+      source drivers/char/drm-4.0/Config.in
-+   else
-+      comment 'DRM 4.1 drivers'
-+      define_bool CONFIG_DRM_NEW y
-+      source drivers/char/drm/Config.in
-+   fi
-+fi
-+
-+if [ "$CONFIG_X86" = "y" ]; then
-+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
-+fi
-+
-+endmenu
-+
-+if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
-+   source drivers/char/pcmcia/Config.in
-+fi
-+if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
-+   tristate ' Alchemy Au1x00 GPIO device support' CONFIG_AU1X00_GPIO
-+   tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1X00_ADS7846
-+   #tristate ' Alchemy Au1550 PSC SPI support' CONFIG_AU1550_PSC_SPI
-+fi
-+if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
-+  tristate ' ITE GPIO' CONFIG_ITE_GPIO
-+fi
-+
-+if [ "$CONFIG_X86" = "y" ]; then
-+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
-+   dep_tristate 'HP OB600 C/CT Pop-up mouse support' CONFIG_OBMOUSE $CONFIG_INPUT_MOUSEDEV
-+fi
-+
-+endmenu
 diff -urN linux.old/drivers/char/Makefile linux.dev/drivers/char/Makefile
 --- linux.old/drivers/char/Makefile	2005-10-21 16:43:16.460960500 +0200
 +++ linux.dev/drivers/char/Makefile	2005-11-10 01:10:45.871576250 +0100
@@ -3697,384 +3279,6 @@
  include $(TOPDIR)/Rules.make
  
  fastdep:
-diff -urN linux.old/drivers/char/Makefile.orig linux.dev/drivers/char/Makefile.orig
---- linux.old/drivers/char/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
-+++ linux.dev/drivers/char/Makefile.orig	2005-11-10 01:10:45.871576250 +0100
-@@ -0,0 +1,374 @@
-+#
-+# Makefile for the kernel character device drivers.
-+#
-+# Note! Dependencies are done automagically by 'make dep', which also
-+# removes any old dependencies. DON'T put your own dependencies here
-+# unless it's something special (ie not a .c file).
-+#
-+# Note 2! The CFLAGS definitions are now inherited from the
-+# parent makes..
-+#
-+
-+#
-+# This file contains the font map for the default (hardware) font
-+#
-+FONTMAPFILE = cp437.uni
-+
-+O_TARGET := char.o
-+
-+obj-y	 += mem.o tty_io.o n_tty.o tty_ioctl.o raw.o pty.o misc.o random.o
-+
-+# All of the (potential) objects that export symbols.
-+# This list comes from 'grep -l EXPORT_SYMBOL *.[hc]'.
-+
-+export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
-+			misc.o pty.o random.o selection.o serial.o \
-+			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-+			au1000_gpio.o vac-serial.o hp_psaux.o nvram.o \
-+			scx200.o fetchop.o
-+
-+mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
-+
-+list-multi	:=	
-+
-+KEYMAP   =defkeymap.o
-+KEYBD    =pc_keyb.o
-+CONSOLE  =console.o
-+SERIAL   =serial.o
-+
-+ifeq ($(ARCH),s390)
-+  KEYMAP   =
-+  KEYBD    =
-+  CONSOLE  =
-+  SERIAL   =
-+endif
-+
-+ifeq ($(ARCH),mips)
-+  ifneq ($(CONFIG_PC_KEYB),y)
-+    KEYBD    =
-+  endif
-+  ifeq ($(CONFIG_VR41XX_KIU),y)
-+    ifeq ($(CONFIG_IBM_WORKPAD),y)
-+      KEYMAP = ibm_workpad_keymap.o
-+    endif
-+    ifeq ($(CONFIG_VICTOR_MPC30X),y)
-+      KEYMAP = victor_mpc30x_keymap.o
-+    endif
-+    KEYBD    = vr41xx_keyb.o
-+  endif
-+endif
-+
-+ifeq ($(ARCH),s390x)
-+  KEYMAP   =
-+  KEYBD    =
-+  CONSOLE  =
-+  SERIAL   =
-+endif
-+
-+ifeq ($(ARCH),m68k)
-+   ifdef CONFIG_AMIGA
-+      KEYBD = amikeyb.o
-+   else
-+      ifndef CONFIG_MAC
-+	 KEYBD =
-+      endif
-+   endif
-+   SERIAL   =
-+endif
-+
-+ifeq ($(ARCH),parisc)
-+   ifdef CONFIG_GSC_PS2
-+      KEYBD   = hp_psaux.o hp_keyb.o
-+   else
-+      KEYBD   =
-+   endif
-+   ifdef CONFIG_SERIAL_MUX
-+      CONSOLE += mux.o
-+   endif
-+   ifdef CONFIG_PDC_CONSOLE
-+      CONSOLE += pdc_console.o
-+   endif
-+endif
-+
-+ifdef CONFIG_Q40
-+  KEYBD += q40_keyb.o
-+  SERIAL = serial.o
-+endif
-+
-+ifdef CONFIG_APOLLO
-+  KEYBD += dn_keyb.o
-+endif
-+
-+ifeq ($(ARCH),parisc)
-+   ifdef CONFIG_GSC_PS2
-+      KEYBD   = hp_psaux.o hp_keyb.o
-+   else
-+      KEYBD   =
-+   endif
-+   ifdef CONFIG_PDC_CONSOLE
-+      CONSOLE += pdc_console.o
-+   endif
-+endif
-+
-+ifeq ($(ARCH),arm)
-+  ifneq ($(CONFIG_PC_KEYMAP),y)
-+    KEYMAP   =
-+  endif
-+  ifneq ($(CONFIG_PC_KEYB),y)
-+    KEYBD    =
-+  endif
-+endif
-+
-+ifeq ($(ARCH),sh)
-+  KEYMAP   =
-+  KEYBD    =
-+  CONSOLE  =
-+  ifeq ($(CONFIG_SH_HP600),y)
-+  KEYMAP   = defkeymap.o
-+  KEYBD    = scan_keyb.o hp600_keyb.o
-+  CONSOLE  = console.o
-+  endif
-+  ifeq ($(CONFIG_SH_DMIDA),y)
-+  # DMIDA does not connect the HD64465 PS/2 keyboard port
-+  # but we allow for USB keyboards to be plugged in.
-+  KEYMAP   = defkeymap.o
-+  KEYBD    = # hd64465_keyb.o pc_keyb.o
-+  CONSOLE  = console.o
-+  endif
-+  ifeq ($(CONFIG_SH_EC3104),y)
-+  KEYMAP   = defkeymap.o
-+  KEYBD    = ec3104_keyb.o
-+  CONSOLE  = console.o
-+  endif
-+  ifeq ($(CONFIG_SH_DREAMCAST),y)
-+  KEYMAP   = defkeymap.o
-+  KEYBD    =
-+  CONSOLE  = console.o
-+  endif
-+endif
-+
-+ifeq ($(CONFIG_DECSTATION),y)
-+  KEYMAP   =
-+  KEYBD    =
-+endif
-+
-+ifeq ($(CONFIG_BAGET_MIPS),y)
-+  KEYBD    =
-+  SERIAL   = vac-serial.o
-+endif
-+
-+ifeq ($(CONFIG_NINO),y)
-+  SERIAL   =
-+endif
-+
-+ifneq ($(CONFIG_SUN_SERIAL),)
-+  SERIAL   =
-+endif
-+
-+ifeq ($(CONFIG_QTRONIX_KEYBOARD),y)
-+  KEYBD    = qtronix.o
-+  KEYMAP   = qtronixmap.o
-+endif
-+
-+ifeq ($(CONFIG_DUMMY_KEYB),y)
-+  KEYBD = dummy_keyb.o
-+endif
-+
-+obj-$(CONFIG_VT) += vt.o vc_screen.o consolemap.o consolemap_deftbl.o $(CONSOLE) selection.o
-+obj-$(CONFIG_SERIAL) += $(SERIAL)
-+obj-$(CONFIG_PARPORT_SERIAL) += parport_serial.o
-+obj-$(CONFIG_SERIAL_HCDP) += hcdp_serial.o
-+obj-$(CONFIG_SERIAL_21285) += serial_21285.o
-+obj-$(CONFIG_SERIAL_SA1100) += serial_sa1100.o
-+obj-$(CONFIG_SERIAL_AMBA) += serial_amba.o
-+obj-$(CONFIG_TS_AU1X00_ADS7846) += au1000_ts.o
-+obj-$(CONFIG_SERIAL_DEC) += decserial.o
-+
-+ifndef CONFIG_SUN_KEYBOARD
-+  obj-$(CONFIG_VT) += keyboard.o $(KEYMAP) $(KEYBD)
-+else
-+  obj-$(CONFIG_PCI) += keyboard.o $(KEYMAP)
-+endif
-+
-+obj-$(CONFIG_HIL) += hp_keyb.o
-+obj-$(CONFIG_MAGIC_SYSRQ) += sysrq.o
-+obj-$(CONFIG_ATARI_DSP56K) += dsp56k.o
-+obj-$(CONFIG_ROCKETPORT) += rocket.o
-+obj-$(CONFIG_MOXA_SMARTIO) += mxser.o
-+obj-$(CONFIG_MOXA_INTELLIO) += moxa.o
-+obj-$(CONFIG_DIGI) += pcxx.o
-+obj-$(CONFIG_DIGIEPCA) += epca.o
-+obj-$(CONFIG_CYCLADES) += cyclades.o
-+obj-$(CONFIG_STALLION) += stallion.o
-+obj-$(CONFIG_ISTALLION) += istallion.o
-+obj-$(CONFIG_SIBYTE_SB1250_DUART) += sb1250_duart.o
-+obj-$(CONFIG_COMPUTONE) += ip2.o ip2main.o
-+obj-$(CONFIG_RISCOM8) += riscom8.o
-+obj-$(CONFIG_ISI) += isicom.o
-+obj-$(CONFIG_ESPSERIAL) += esp.o
-+obj-$(CONFIG_SYNCLINK) += synclink.o
-+obj-$(CONFIG_SYNCLINKMP) += synclinkmp.o
-+obj-$(CONFIG_N_HDLC) += n_hdlc.o
-+obj-$(CONFIG_SPECIALIX) += specialix.o
-+obj-$(CONFIG_AMIGA_BUILTIN_SERIAL) += amiserial.o
-+obj-$(CONFIG_A2232) += ser_a2232.o generic_serial.o
-+obj-$(CONFIG_SX) += sx.o generic_serial.o
-+obj-$(CONFIG_RIO) += rio/rio.o generic_serial.o
-+obj-$(CONFIG_SH_SCI) += sh-sci.o generic_serial.o
-+obj-$(CONFIG_SERIAL167) += serial167.o
-+obj-$(CONFIG_MVME147_SCC) += generic_serial.o vme_scc.o
-+obj-$(CONFIG_MVME162_SCC) += generic_serial.o vme_scc.o
-+obj-$(CONFIG_BVME6000_SCC) += generic_serial.o vme_scc.o
-+obj-$(CONFIG_HVC_CONSOLE) += hvc_console.o
-+obj-$(CONFIG_SERIAL_TX3912) += generic_serial.o serial_tx3912.o
-+obj-$(CONFIG_TXX927_SERIAL) += serial_txx927.o
-+obj-$(CONFIG_SERIAL_TXX9) += generic_serial.o serial_txx9.o
-+obj-$(CONFIG_IP22_SERIAL) += sgiserial.o
-+obj-$(CONFIG_AU1X00_UART) += au1x00-serial.o
-+obj-$(CONFIG_SGI_L1_SERIAL) += sn_serial.o
-+
-+subdir-$(CONFIG_RIO) += rio
-+subdir-$(CONFIG_INPUT) += joystick
-+
-+obj-$(CONFIG_ATIXL_BUSMOUSE) += atixlmouse.o
-+obj-$(CONFIG_LOGIBUSMOUSE) += logibusmouse.o
-+obj-$(CONFIG_PRINTER) += lp.o
-+obj-$(CONFIG_TIPAR) += tipar.o
-+obj-$(CONFIG_OBMOUSE) += obmouse.o
-+
-+ifeq ($(CONFIG_INPUT),y)
-+obj-y += joystick/js.o
-+endif
-+
-+#
-+# Texas Intruments VLYNQ driver
-+# 
-+
-+subdir-$(CONFIG_AR7_VLYNQ) += avalanche_vlynq
-+obj-$(CONFIG_AR7_VLYNQ) += avalanche_vlynq/avalanche_vlynq.o                                                        
-+
-+obj-$(CONFIG_FETCHOP) += fetchop.o
-+obj-$(CONFIG_BUSMOUSE) += busmouse.o
-+obj-$(CONFIG_DTLK) += dtlk.o
-+obj-$(CONFIG_R3964) += n_r3964.o
-+obj-$(CONFIG_APPLICOM) += applicom.o
-+obj-$(CONFIG_SONYPI) += sonypi.o
-+obj-$(CONFIG_MS_BUSMOUSE) += msbusmouse.o
-+obj-$(CONFIG_82C710_MOUSE) += qpmouse.o
-+obj-$(CONFIG_AMIGAMOUSE) += amigamouse.o
-+obj-$(CONFIG_ATARIMOUSE) += atarimouse.o
-+obj-$(CONFIG_ADBMOUSE) += adbmouse.o
-+obj-$(CONFIG_PC110_PAD) += pc110pad.o
-+obj-$(CONFIG_MK712_MOUSE) += mk712.o
-+obj-$(CONFIG_RTC) += rtc.o
-+obj-$(CONFIG_GEN_RTC) += genrtc.o
-+obj-$(CONFIG_EFI_RTC) += efirtc.o
-+obj-$(CONFIG_MIPS_RTC) += mips_rtc.o
-+obj-$(CONFIG_SGI_IP27_RTC) += ip27-rtc.o
-+ifeq ($(CONFIG_PPC),)
-+  obj-$(CONFIG_NVRAM) += nvram.o
-+endif
-+obj-$(CONFIG_TOSHIBA) += toshiba.o
-+obj-$(CONFIG_I8K) += i8k.o
-+obj-$(CONFIG_DS1286) += ds1286.o
-+obj-$(CONFIG_DS1620) += ds1620.o
-+obj-$(CONFIG_DS1742) += ds1742.o
-+obj-$(CONFIG_INTEL_RNG) += i810_rng.o
-+obj-$(CONFIG_AMD_RNG) += amd768_rng.o
-+obj-$(CONFIG_HW_RANDOM) += hw_random.o
-+obj-$(CONFIG_AMD_PM768) += amd76x_pm.o
-+obj-$(CONFIG_BRIQ_PANEL) += briq_panel.o
-+
-+obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
-+obj-$(CONFIG_AU1X00_GPIO) += au1000_gpio.o
-+obj-$(CONFIG_AU1550_PSC_SPI) += au1550_psc_spi.o
-+obj-$(CONFIG_AU1X00_USB_TTY) += au1000_usbtty.o
-+obj-$(CONFIG_AU1X00_USB_RAW) += au1000_usbraw.o
-+obj-$(CONFIG_COBALT_LCD) += lcd.o
-+
-+obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
-+
-+subdir-$(CONFIG_FTAPE) += ftape
-+subdir-$(CONFIG_DRM_OLD) += drm-4.0
-+subdir-$(CONFIG_DRM_NEW) += drm
-+subdir-$(CONFIG_PCMCIA) += pcmcia
-+subdir-$(CONFIG_AGP) += agp
-+
-+ifeq ($(CONFIG_FTAPE),y)
-+obj-y       += ftape/ftape.o
-+endif
-+
-+obj-$(CONFIG_H8) += h8.o
-+obj-$(CONFIG_PPDEV) += ppdev.o
-+obj-$(CONFIG_DZ) += dz.o
-+obj-$(CONFIG_NWBUTTON) += nwbutton.o
-+obj-$(CONFIG_NWFLASH) += nwflash.o
-+obj-$(CONFIG_SCx200) += scx200.o
-+obj-$(CONFIG_SCx200_GPIO) += scx200_gpio.o
-+
-+# Only one watchdog can succeed. We probe the hardware watchdog
-+# drivers first, then the softdog driver.  This means if your hardware
-+# watchdog dies or is 'borrowed' for some reason the software watchdog
-+# still gives you some cover.
-+
-+obj-$(CONFIG_PCWATCHDOG) += pcwd.o
-+obj-$(CONFIG_ACQUIRE_WDT) += acquirewdt.o
-+obj-$(CONFIG_ADVANTECH_WDT) += advantechwdt.o
-+obj-$(CONFIG_IB700_WDT) += ib700wdt.o
-+obj-$(CONFIG_MIXCOMWD) += mixcomwd.o
-+obj-$(CONFIG_60XX_WDT) += sbc60xxwdt.o
-+obj-$(CONFIG_W83877F_WDT) += w83877f_wdt.o
-+obj-$(CONFIG_SC520_WDT) += sc520_wdt.o
-+obj-$(CONFIG_WDT) += wdt.o
-+obj-$(CONFIG_WDTPCI) += wdt_pci.o
-+obj-$(CONFIG_21285_WATCHDOG) += wdt285.o
-+obj-$(CONFIG_977_WATCHDOG) += wdt977.o
-+obj-$(CONFIG_I810_TCO) += i810-tco.o
-+obj-$(CONFIG_MACHZ_WDT) += machzwd.o
-+obj-$(CONFIG_SH_WDT) += shwdt.o
-+obj-$(CONFIG_EUROTECH_WDT) += eurotechwdt.o
-+obj-$(CONFIG_ALIM7101_WDT) += alim7101_wdt.o
-+obj-$(CONFIG_ALIM1535_WDT) += alim1535d_wdt.o
-+obj-$(CONFIG_INDYDOG) += indydog.o
-+obj-$(CONFIG_SC1200_WDT) += sc1200wdt.o
-+obj-$(CONFIG_SCx200_WDT) += scx200_wdt.o
-+obj-$(CONFIG_WAFER_WDT) += wafer5823wdt.o
-+obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
-+obj-$(CONFIG_INDYDOG) += indydog.o
-+obj-$(CONFIG_8xx_WDT) += mpc8xx_wdt.o
-+
-+subdir-$(CONFIG_MWAVE) += mwave
-+ifeq ($(CONFIG_MWAVE),y)
-+  obj-y += mwave/mwave.o
-+endif
-+
-+subdir-$(CONFIG_IPMI_HANDLER) += ipmi
-+ifeq ($(CONFIG_IPMI_HANDLER),y)
-+  obj-y += ipmi/ipmi.o
-+endif
-+
-+include $(TOPDIR)/Rules.make
-+
-+fastdep:
-+
-+conmakehash: conmakehash.c
-+	$(HOSTCC) $(HOSTCFLAGS) -o conmakehash conmakehash.c
-+
-+consolemap_deftbl.c: $(FONTMAPFILE) conmakehash
-+	./conmakehash $(FONTMAPFILE) > consolemap_deftbl.c
-+
-+consolemap_deftbl.o: consolemap_deftbl.c $(TOPDIR)/include/linux/types.h
-+
-+.DELETE_ON_ERROR:
-+
-+defkeymap.c: defkeymap.map
-+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
-+
-+qtronixmap.c: qtronixmap.map
-+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
-+
-+ibm_workpad_keymap.c: ibm_workpad_keymap.map
-+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
-+
-+victor_mpc30x_keymap.c: victor_mpc30x_keymap.map
-+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
 diff -urN linux.old/drivers/char/avalanche_vlynq/Makefile linux.dev/drivers/char/avalanche_vlynq/Makefile
 --- linux.old/drivers/char/avalanche_vlynq/Makefile	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/drivers/char/avalanche_vlynq/Makefile	2005-11-10 01:10:45.871576250 +0100
@@ -4122,7 +3326,7 @@
 +#include <linux/module.h>
 +#include <asm/ar7/sangam.h>  
 +#include <asm/ar7/avalanche_misc.h>  
-+#include <asm/ar7/vlynq.h>  
++#include <asm/ar7/vlynq_hal.h>  
 +   
 +#define SYS_VLYNQ_LOCAL_INTERRUPT_VECTOR	30 	/* MSB - 1 bit */
 +#define SYS_VLYNQ_REMOTE_INTERRUPT_VECTOR	31 	/* MSB bit */
@@ -4315,7 +3519,7 @@
 +#include <linux/capability.h>
 +#include <asm/ar7/avalanche_intc.h>
 +#include <asm/ar7/sangam.h>
-+#include <asm/ar7/vlynq.h>
++#include <asm/ar7/vlynq_hal.h>
 +
 +
 +#define    TI_VLYNQ_VERSION                 "0.2"
@@ -4572,7 +3776,7 @@
 +
 +#include <linux/stddef.h>
 +#include <linux/types.h>
-+#include <asm/ar7/vlynq.h>
++#include <asm/ar7/vlynq_hal.h>
 +
 +/**** Local Function prototypes *******/
 +static int vlynqInterruptInit(VLYNQ_DEV *pdev);
@@ -6501,7 +5705,7 @@
 diff -urN linux.old/include/asm-mips/ar7/avalanche_regs.h linux.dev/include/asm-mips/ar7/avalanche_regs.h
 --- linux.old/include/asm-mips/ar7/avalanche_regs.h	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/include/asm-mips/ar7/avalanche_regs.h	2005-11-10 01:10:46.071588750 +0100
-@@ -0,0 +1,567 @@
+@@ -0,0 +1,561 @@
 +/* 
 + *  $Id$
 + *  Avalanche Register Descriptions
@@ -7062,13 +6266,7 @@
 +
 +#define VMAC_STATS_BASE(X)     (X + 0x00000400)
 +
-+#endif __AVALANCHE_REGS_H
-+
-+
-+
-+
-+
-+
++#endif /* __AVALANCHE_REGS_H */
 diff -urN linux.old/include/asm-mips/ar7/avalanche_types.h linux.dev/include/asm-mips/ar7/avalanche_types.h
 --- linux.old/include/asm-mips/ar7/avalanche_types.h	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/include/asm-mips/ar7/avalanche_types.h	2005-11-10 01:10:46.071588750 +0100
@@ -8125,620 +7323,6 @@
 +__u32 tnetd73xx_get_revision(void);
 +
 +#endif /* __TNETD73XX_MISC_H__ */
-diff -urN linux.old/include/asm-mips/ar7/vlynq.h linux.dev/include/asm-mips/ar7/vlynq.h
---- linux.old/include/asm-mips/ar7/vlynq.h	1970-01-01 01:00:00.000000000 +0100
-+++ linux.dev/include/asm-mips/ar7/vlynq.h	2005-11-10 01:10:46.095590250 +0100
-@@ -0,0 +1,610 @@
-+/***************************************************************************
-+**+----------------------------------------------------------------------+**
-+**|                                ****                                  |**
-+**|                                ****                                  |**
-+**|                                ******o***                            |**
-+**|                          ********_///_****                           |**
-+**|                           ***** /_//_/ ****                          |**
-+**|                            ** ** (__/ ****                           |**
-+**|                                *********                             |**
-+**|                                 ****                                 |**
-+**|                                  ***                                 |**
-+**|                                                                      |**
-+**|     Copyright (c) 2003 Texas Instruments Incorporated                |**
-+**|                        ALL RIGHTS RESERVED                           |**
-+**|                                                                      |**
-+**| Permission is hereby granted to licensees of Texas Instruments       |**
-+**| Incorporated (TI) products to use this computer program for the sole |**
-+**| purpose of implementing a licensee product based on TI products.     |**
-+**| No other rights to reproduce, use, or disseminate this computer      |**
-+**| program, whether in part or in whole, are granted.                   |**
-+**|                                                                      |**
-+**| TI makes no representation or warranties with respect to the         |**
-+**| performance of this computer program, and specifically disclaims     |**
-+**| any responsibility for any damages, special or consequential,        |**
-+**| connected with the use of this program.                              |**
-+**|                                                                      |**
-+**+----------------------------------------------------------------------+**
-+***************************************************************************/
-+
-+/*********************************************************************************
-+ *  ------------------------------------------------------------------------------
-+ *   Module      : vlynq_hal.h
-+ *   Description :
-+ *   This header file provides the set of functions exported by the 
-+ *   VLYNQ HAL. This file is included from the SOC specific VLYNQ driver wrapper.
-+ *  ------------------------------------------------------------------------------
-+ *********************************************************************************/
-+
-+#ifndef _VLYNQ_HAL_H_
-+#define _VLYNQ_HAL_H_
-+
-+/* Enable/Disable debug feature */
-+#undef VLYNQ_DEBUG 
-+
-+#ifdef VLYNQ_DEBUG  /* This needs to be OS abstracted - for testing use vxworks/linux calls */
-+#define debugPrint(format,args...)    
-+#else 
-+#define debugPrint(format,args...)  
-+#endif
-+
-+ /* number of VLYNQ memory regions supported */
-+#define VLYNQ_MAX_MEMORY_REGIONS 0x04
-+  
-+ /* Max.number of external interrupt inputs supported by VLYNQ module */
-+#define VLYNQ_IVR_MAXIVR         0x08
-+
-+#define VLYNQ_CLK_DIV_MAX  0x08
-+#define VLYNQ_CLK_DIV_MIN  0x01
-+
-+
-+/*** the total number of entries allocated for ICB would be
-+ * 32(for 32 bits in IntPending register) + VLYNQ_IVR_CHAIN_SLOTS*/
-+#define VLYNQ_IVR_CHAIN_SLOTS 10
-+
-+
-+/* Error defines */
-+#define VLYNQ_SUCCESS               0
-+
-+#define VLYNQ_ERRCODE_BASE          0 /* Chosen by system */
-+#define VLYNQ_INVALID_ARG          -(VLYNQ_ERRCODE_BASE+1)
-+#define VLYNQ_INVALID_DRV_STATE    -(VLYNQ_ERRCODE_BASE+2)
-+#define VLYNQ_INT_CONFIG_ERR       -(VLYNQ_ERRCODE_BASE+3)
-+#define VLYNQ_LINK_DOWN            -(VLYNQ_ERRCODE_BASE+4)
-+#define VLYNQ_MEMALLOC_FAIL        -(VLYNQ_ERRCODE_BASE+5)
-+#define VLYNQ_ISR_NON_EXISTENT     -(VLYNQ_ERRCODE_BASE+6)
-+#define VLYNQ_INTVEC_MAP_NOT_FOUND -(VLYNQ_ERRCODE_BASE+7)
-+
-+/* Vlynq Defines and Macros */
-+
-+#define VLYNQ_NUM_INT_BITS              32 /* 32 bit interrupt staus register */
-+
-+/* Base address of module */
-+#define VLYNQ_BASE                      (pdev->module_base)
-+
-+#define VLYNQ_REMOTE_REGS_OFFSET        0x0080
-+
-+#define VLYNQ_REV_OFFSET                0x0000
-+#define VLYNQ_CTRL_OFFSET               0x0004
-+#define VLYNQ_STATUS_OFFSET             0x0008
-+#define VLYNQ_INT_STAT_OFFSET           0x0010
-+#define VLYNQ_INT_PEND_OFFSET           0x0014
-+#define VLYNQ_INT_PTR_OFFSET            0x0018
-+#define VLYNQ_TXMAP_OFFSET              0x001c
-+
-+#define VLYNQ_RX0MAP_SIZE_REG_OFFSET    0x0020
-+#define VLYNQ_RX0MAP_OFFSET_REG_OFFSET  0x0024
-+
-+#define VLYNQ_CHIP_VER_OFFSET           0x0040
-+#define VLYNQ_IVR_REGS_OFFSET           0x0060
-+
-+#define VLYNQ_INT_PENDING_REG_PTR       0x14
-+#define VLYNQ_R_INT_PENDING_REG_PTR     VLYNQ_REMOTE_REGS_OFFSET + 0x14
-+
-+#define VLYNQ_REV_REG       *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_REV_OFFSET))
-+#define VLYNQ_CTRL_REG      *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_CTRL_OFFSET))
-+#define VLYNQ_STATUS_REG    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_STATUS_OFFSET))
-+#define VLYNQ_INT_STAT_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_STAT_OFFSET))
-+#define VLYNQ_INT_PEND_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_PEND_OFFSET))
-+#define VLYNQ_INT_PTR_REG   *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_PTR_OFFSET))
-+#define VLYNQ_TXMAP_REG     *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_TXMAP_OFFSET))
-+
-+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
-+#define VLYNQ_RXMAP_SIZE_REG(map) \
-+    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_RX0MAP_SIZE_REG_OFFSET+( (map-1)<<3)))
-+    
-+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
-+#define VLYNQ_RXMAP_OFFSET_REG(map) \
-+    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_RX0MAP_OFFSET_REG_OFFSET+( (map-1)<<3)))
-+
-+#define VLYNQ_CHIP_VER_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_CHIP_VER_OFFSET))
-+
-+/* 0 =< ivr <= 31; currently ivr < VLYNQ_IVR_MAXIVR=8) */
-+#define VLYNQ_IVR_OFFSET(ivr)  \
-+    (VLYNQ_BASE + VLYNQ_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3) )
-+
-+#define VLYNQ_IVR_03TO00_REG  *((volatile unsigned int*) (VLYNQ_IVR_OFFSET(0)) )
-+#define VLYNQ_IVR_07TO04_REG  *((volatile unsigned int*) (VLYNQ_IVR_OFFSET(4)) )
-+/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
-+
-+#define VLYNQ_IVR_INTEN(ivr)    (((unsigned int)(0x80)) << ((((unsigned)(ivr)) % 4) * 8))
-+#define VLYNQ_IVR_INTTYPE(ivr)  (((unsigned int)(0x40)) << ((((unsigned)(ivr)) % 4) * 8))
-+#define VLYNQ_IVR_INTPOL(ivr)   (((unsigned int)(0x20)) << ((((unsigned)(ivr)) % 4) * 8))
-+#define VLYNQ_IVR_INTVEC(ivr)   (((unsigned int)(0x1F)) << ((((unsigned)(ivr)) % 4) * 8))
-+#define VLYNQ_IVR_INTALL(ivr)   (((unsigned int)(0xFF)) << ((((unsigned)(ivr)) % 4) * 8))
-+
-+
-+
-+/*********************************
-+ * Remote VLYNQ register set     *
-+ *********************************/
-+
-+#define VLYNQ_R_REV_OFFSET              0x0080
-+#define VLYNQ_R_CTRL_OFFSET             0x0084
-+#define VLYNQ_R_STATUS_OFFSET           0x0088
-+#define VLYNQ_R_INT_STAT_OFFSET         0x0090
-+#define VLYNQ_R_INT_PEND_OFFSET         0x0094
-+#define VLYNQ_R_INT_PTR_OFFSET          0x0098
-+#define VLYNQ_R_TXMAP_OFFSET            0x009c
-+
-+#define VLYNQ_R_RX0MAP_SIZE_REG_OFFSET  0x00A0
-+#define VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET 0x00A4
-+
-+#define VLYNQ_R_CHIP_VER_OFFSET         0x00C0
-+#define VLYNQ_R_IVR_REGS_OFFSET         0x00E0
-+
-+#define VLYNQ_R_REV_REG       *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_REV_OFFSET)) 
-+#define VLYNQ_R_CTRL_REG      *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_CTRL_OFFSET))
-+#define VLYNQ_R_STATUS_REG    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_STATUS_OFFSET))
-+#define VLYNQ_R_INT_STAT_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_STAT_OFFSET))
-+#define VLYNQ_R_INT_PEND_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_PEND_OFFSET))
-+#define VLYNQ_R_INT_PTR_REG   *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_PTR_OFFSET))
-+#define VLYNQ_R_TXMAP_REG     *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_TXMAP_OFFSET))
-+
-+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
-+#define VLYNQ_R_RXMAP_SIZE_REG(map) \
-+    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_SIZE_REG_OFFSET + ((map-1)<<3)))
-+    
-+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
-+#define VLYNQ_R_RXMAP_OFFSET_REG(map) \
-+    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET + ((map-1)<<3)))
-+
-+#define VLYNQ_R_CHIP_VER_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_CHIP_VER_OFFSET)
-+
-+#define VLYNQ_R_IVR_OFFSET(ivr)  \
-+    (VLYNQ_BASE + VLYNQ_R_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3))
-+ 
-+
-+/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
-+#define VLYNQ_R_IVR_03TO00_REG  *((volatile unsigned int*) (VLYNQ_R_IVR_OFFSET(0)) )
-+#define VLYNQ_R_IVR_07TO04_REG  *((volatile unsigned int*) (VLYNQ_R_IVR_OFFSET(4)) )
-+
-+
-+/****End of remote register set definition******/
-+
-+
-+/*** Masks for individual register fields ***/
-+
-+#define VLYNQ_MODULE_ID_MASK        0xffff0000
-+#define VLYNQ_MAJOR_REV_MASK        0x0000ff00
-+#define VLYNQ_MINOR_REV_MASK        0x000000ff
-+
-+    
-+#define VLYNQ_CTL_ILOOP_MASK        0x00000002
-+#define VLYNQ_CTL_INT2CFG_MASK      0x00000080
-+#define VLYNQ_CTL_INTVEC_MASK       0x00001f00
-+#define VLYNQ_CTL_INTEN_MASK        0x00002000
-+#define VLYNQ_CTL_INTLOCAL_MASK     0x00004000
-+#define VLYNQ_CTL_CLKDIR_MASK       0x00008000
-+#define VLYNQ_CTL_CLKDIV_MASK       0x00070000
-+#define VLYNQ_CTL_MODE_MASK         0x00e00000
-+
-+
-+#define VLYNQ_STS_LINK_MASK         0x00000001  /* Link is active */
-+#define VLYNQ_STS_MPEND_MASK        0x00000002  /* Pending master requests */
-+#define VLYNQ_STS_SPEND_MASK        0x00000004  /* Pending slave requests */
-+#define VLYNQ_STS_NFEMPTY0_MASK     0x00000008  /* Master data FIFO not empty */
-+#define VLYNQ_STS_NFEMPTY1_MASK     0x00000010  /* Master command FIFO not empty */
-+#define VLYNQ_STS_NFEMPTY2_MASK     0x00000020  /* Slave data FIFO not empty */
-+#define VLYNQ_STS_NFEMPTY3_MASK     0x00000040  /* Slave command FIFO not empty */
-+#define VLYNQ_STS_LERROR_MASK       0x00000080  /* Local error, w/c */
-+#define VLYNQ_STS_RERROR_MASK       0x00000100  /* remote error w/c */
-+#define VLYNQ_STS_OFLOW_MASK        0x00000200
-+#define VLYNQ_STS_IFLOW_MASK        0x00000400
-+#define VLYNQ_STS_MODESUP_MASK      0x00E00000  /* Highest mode supported */
-+#define VLYNQ_STS_SWIDTH_MASK       0x07000000  /* Used for reading the width of VLYNQ bus */
-+#define VLYNQ_STS_DEBUG_MASK        0xE0000000 
-+
-+#define VLYNQ_CTL_INTVEC_SHIFT      0x08
-+#define VLYNQ_CTL_INTEN_SHIFT       0x0D
-+#define VLYNQ_CTL_INT2CFG_SHIFT     0x07
-+#define VLYNQ_CTL_INTLOCAL_SHIFT    0x0E
-+
-+#define VLYNQ_CTL_INTFIELDS_CLEAR_MASK  0x7F80
-+
-+#define VLYNQ_CHIPVER_DEVREV_MASK   0xffff0000
-+#define VLYNQ_CHIPVER_DEVID_MASK    0x0000ffff
-+
-+#define VLYNQ_IVR_INTEN_MASK        0x80
-+#define VLYNQ_IVR_INTTYPE_MASK      0x40
-+#define VLYNQ_IVR_INTPOL_MASK       0x20
-+
-+
-+/**** Helper macros ****/
-+
-+#define VLYNQ_RESETCB(arg) \
-+   if( pdev->reset_cb != NULL)   \
-+   {                             \
-+      (pdev->reset_cb)(pdev, (arg));  \
-+   }
-+    
-+#define VLYNQ_STATUS_FLD_WIDTH(sts) (((sts) & VLYNQ_STS_SWIDTH_MASK) >> 24 )
-+#define VLYNQ_CTL_INTVEC(x)         (((x) & 31) << 8 )
-+
-+#define VLYNQ_INRANGE(x,hi,lo)      (((x) <= (hi)) && ((x) >= (lo)))
-+#define VLYNQ_OUTRANGE(x,hi,lo)     (((x) > (hi)) || ((x) < (lo)))
-+
-+#define VLYNQ_ALIGN4(x)             (x)=(x)&(~3)   
-+
-+
-+/*************************************
-+ *             Enums                 *
-+ *************************************/
-+
-+/* Initialization options define what operations are
-+ * undertaken during vlynq module initialization */
-+typedef enum
-+{
-+    /* Init host local memory regions.This allows
-+     * local host access remote memory regions */
-+    VLYNQ_INIT_LOCAL_MEM_REGIONS = 0x01,
-+    /* Init host remote memory regions.This allows
-+     * remote device access local memory regions */
-+    VLYNQ_INIT_REMOTE_MEM_REGIONS =0x02,
-+    /* Init local interrupt config*/
-+    VLYNQ_INIT_LOCAL_INTERRUPTS   =0x04,
-+    /* Init remote interrupt config*/
-+    VLYNQ_INIT_REMOTE_INTERRUPTS  =0x08,
-+    /* Check link during initialization*/
-+    VLYNQ_INIT_CHECK_LINK         =0x10,
-+    /* configure clock during init */
-+    VLYNQ_INIT_CONFIG_CLOCK       =0x20,
-+    /* Clear errors during init */    
-+    VLYNQ_INIT_CLEAR_ERRORS       =0x40,
-+    /* All options */
-+    VLYNQ_INIT_PERFORM_ALL        =0x7F
-+}VLYNQ_INIT_OPTIONS;
-+
-+
-+/* VLYNQ_DEV_TYPE identifies local or remote device */
-+typedef enum
-+{
-+    VLYNQ_LOCAL_DVC  = 0,           /* vlynq local device (SOC's vlynq module) */
-+    VLYNQ_REMOTE_DVC = 1            /* vlynq remote device (remote vlynq module) */
-+}VLYNQ_DEV_TYPE;
-+
-+
-+/* VLYNQ_CLK_SOURCE identifies the vlynq module clock source */
-+typedef enum
-+{
-+    VLYNQ_CLK_SOURCE_NONE   = 0,    /* do not initialize clock generator*/
-+    VLYNQ_CLK_SOURCE_LOCAL  = 1,    /* clock is generated by local machine  */
-+    VLYNQ_CLK_SOURCE_REMOTE = 2     /* clock is generated by remote machine */
-+}VLYNQ_CLK_SOURCE;
-+
-+
-+/* VLYNQ_DRV_STATE indicates the current driver state */
-+typedef enum
-+{
-+    VLYNQ_DRV_STATE_UNINIT = 0,     /* driver is uninitialized  */
-+    VLYNQ_DRV_STATE_ININIT = 1,     /* VLYNQ is being initialized */
-+    VLYNQ_DRV_STATE_RUN    = 2,     /* VLYNQ is running properly  */
-+    VLYNQ_DRV_STATE_HOLD   = 3,     /* driver stopped temporarily */
-+    VLYNQ_DRV_STATE_ERROR  = 4      /* driver stopped on unrecoverable error */
-+}VLYNQ_DRV_STATE;
-+
-+
-+/* VLYNQ_BUS_WIDTH identifies the vlynq module bus width */
-+typedef enum
-+{
-+   VLYNQ_BUS_WIDTH_3 =  3,
-+   VLYNQ_BUS_WIDTH_5 =  5,
-+   VLYNQ_BUS_WIDTH_7 =  7,
-+   VLYNQ_BUS_WIDTH_9 =  9
-+}VLYNQ_BUS_WIDTH;
-+
-+
-+/* VLYNQ_LOCAL_INT_CONFIG indicates whether the local vlynq 
-+ * interrupts are processed by the host or passed on to the 
-+ * remote device.
-+ */
-+typedef enum
-+{
-+    VLYNQ_INT_REMOTE = 0,   /* Interrupt packets sent to remote, intlocal=0 */
-+    VLYNQ_INT_LOCAL  = 1    /* Interrupts are handled locally, intlocal=1 */
-+}VLYNQ_LOCAL_INT_CONFIG;        
-+
-+
-+/* VLYNQ_REMOTE_INT_CONFIG indicates whether the remote 
-+ * interrupts are to be handled by the SOC system ISR 
-+ * or via the vlynq root ISR
-+ */
-+typedef enum 
-+{
-+    VLYNQ_INT_ROOT_ISR   = 0,   /* remote ints handled via vlynq root ISR */
-+    VLYNQ_INT_SYSTEM_ISR = 1    /* remote ints handled via system ISR */
-+}VLYNQ_REMOTE_INT_CONFIG;
-+
-+
-+/* VLYNQ_INTR_POLARITY - vlynq interrupt polarity setting */
-+typedef enum
-+{
-+    VLYNQ_INTR_ACTIVE_HIGH = 0,
-+    VLYNQ_INTR_ACTIVE_LOW  = 1
-+}VLYNQ_INTR_POLARITY;
-+
-+
-+/* VLYNQ_INTR_TYPE  - vlynq interrupt type */
-+typedef enum
-+{
-+    VLYNQ_INTR_LEVEL  = 0,
-+    VLYNQ_INTR_PULSED = 1
-+}VLYNQ_INTR_TYPE;
-+
-+
-+/* VLYNQ_RESET_MODE - vlynq reset mode */
-+typedef enum
-+{
-+   VLYNQ_RESET_ASSERT,      /* hold device in reset state */
-+   VLYNQ_RESET_DEASSERT,    /* release device from reset state */
-+   VLYNQ_RESET_INITFAIL,    /* handle the device in case driver initialization fails */
-+   VLYNQ_RESET_LINKESTABLISH,  /* handle the device in case driver established link */
-+   VLYNQ_RESET_INITFAIL2,   /* Driver initialization failed but VLYNQ link exist. */
-+   VLYNQ_RESET_INITOK       /* Driver initialization finished OK. */
-+}VLYNQ_RESET_MODE;
-+ 
-+
-+
-+/*************************************
-+ *             Typedefs              *
-+ *************************************/
-+
-+struct VLYNQ_DEV_t; /*forward declaration*/
-+
-+/*--------Function Pointers defintions -----------*/
-+
-+/* prototype for interrupt handler definition */
-+typedef void (*VLYNQ_INTR_CNTRL_ISR)(void *arg1,void *arg2,void *arg3);
-+
-+typedef void 
-+(*VLYNQ_RESET_REMOTE)(struct VLYNQ_DEV_t *pDev, VLYNQ_RESET_MODE mode);
-+
-+typedef void 
-+(*VLYNQ_REPORT_CB)( struct VLYNQ_DEV_t *pDev,   /* This VLYNQ */
-+                    VLYNQ_DEV_TYPE  aSrcDvc,    /* Event Cause -local/remote? */
-+                    unsigned int  dwStatRegVal);      /* Value of the relevant status register */
-+
-+
-+/*-------Structure Definitions------------*/
-+
-+typedef struct VLYNQ_MEMORY_MAP_t
-+{
-+    unsigned int Txmap;
-+    unsigned int RxOffset[VLYNQ_MAX_MEMORY_REGIONS];
-+    unsigned int RxSize[VLYNQ_MAX_MEMORY_REGIONS];
-+}VLYNQ_MEMORY_MAP;
-+
-+
-+/**VLYNQ_INTERRUPT_CNTRL - defines the vlynq module interrupt
-+ * settings in vlynq Control register  */ 
-+typedef struct VLYNQ_INTERRUPT_CNTRL_t
-+{
-+    /* vlynq interrupts handled by host or remote - maps to 
-+     * intLocal bit in vlynq control register */
-+    VLYNQ_LOCAL_INT_CONFIG intLocal;
-+
-+    /* remote interrupts handled by vlynq isr or host system
-+     * interrupt controller - maps to the int2Cfg in vlynq 
-+     * control register */
-+    VLYNQ_REMOTE_INT_CONFIG intRemote;
-+    
-+    /* bit in pending/set register used for module interrupts*/
-+    unsigned int map_vector;
-+    
-+    /* used only if remote interrupts are to be handled by system ISR*/    
-+    unsigned int intr_ptr;
-+
-+}VLYNQ_INTERRUPT_CNTRL;
-+
-+
-+/* VLYNQ_INTR_CNTRL_ICB - defines the Interrupt control block which hold
-+ * the interrupt dispatch table. The vlynq_root_isr() indexes into this 
-+ * table to identify the ISR to be invoked
-+ */
-+typedef struct VLYNQ_INTR_CNTRL_ICB_t
-+{
-+    VLYNQ_INTR_CNTRL_ISR            isr;    /* Clear errors during initialization */
-+    void                            *arg1 ; /* Arg 1 for the ISR */
-+    void                            *arg2 ; /* Arg 2 for the ISR */
-+    void                            *arg3 ; /* Arg 3 for the ISR */
-+    unsigned int  isrCount; /* number of ISR invocations so far */
-+    struct VLYNQ_INTR_CNTRL_ICB_t   *next;
-+}VLYNQ_INTR_CNTRL_ICB;
-+
-+/* overlay of vlynq register set */
-+typedef struct VLYNQ_REG_SET_t
-+{
-+    unsigned int revision; /*offset : 0x00 */
-+    unsigned int control;  /* 0x04*/
-+    unsigned int status;   /* 0x08*/
-+    unsigned int pad1;     /* 0x0c*/
-+    unsigned int intStatus;   /*0x10*/
-+    unsigned int intPending;  /*0x14*/
-+    unsigned int intPtr;      /*0x18*/
-+    unsigned int txMap;       /*0x1C*/ 
-+    unsigned int rxSize1;     /*0x20*/
-+    unsigned int rxOffset1;   /*0x24*/
-+    unsigned int rxSize2;     /*0x28*/
-+    unsigned int rxOffset2;   /*0x2C*/
-+    unsigned int rxSize3;     /*0x30*/
-+    unsigned int rxOffset3;   /*0x34*/
-+    unsigned int rxSize4;     /*0x38*/
-+    unsigned int rxOffset4;   /*0x3C*/
-+    unsigned int chipVersion; /*0x40*/
-+    unsigned int pad2[8];
-+    unsigned int ivr30;       /*0x60*/
-+    unsigned int ivr74;       /*0x64*/
-+    unsigned int pad3[7];
-+}VLYNQ_REG_SET;
-+    
-+
-+typedef struct VLYNQ_DEV_t
-+{
-+    /** module index:1,2,3... used for debugging purposes */
-+    unsigned int dev_idx; 
-+    
-+    /*VLYNQ module base address */
-+    unsigned int module_base;
-+   
-+    /* clock source selection */
-+    VLYNQ_CLK_SOURCE clk_source;
-+   
-+    /* Clock Divider.Val=1 to 8. VLYNQ_clk = VBUSCLK/clk_div */
-+    unsigned int  clk_div;
-+   
-+    /* State of the VLYNQ driver, set to VLYNQ_DRV_STATE_UNINIT, when initializing */
-+    VLYNQ_DRV_STATE state;
-+   
-+    /* Valid VLYNQ bus width, filled by driver  */
-+    VLYNQ_BUS_WIDTH width;
-+   
-+    /* local memory mapping   */
-+    VLYNQ_MEMORY_MAP local_mem;
-+   
-+    /* remote memory mapping   */
-+    VLYNQ_MEMORY_MAP remote_mem;
-+   
-+    /* Local module interrupt params */
-+    VLYNQ_INTERRUPT_CNTRL  local_irq;
-+   
-+    /* remote module interrupt params */
-+    VLYNQ_INTERRUPT_CNTRL  remote_irq;
-+
-+    /*** ICB related fields **/
-+   
-+    /* Sizeof of ICB = VLYNQ_NUM_INT_BITS(for 32 bits in IntPending) + 
-+     * expansion slots for shared interrupts*/
-+    VLYNQ_INTR_CNTRL_ICB  pIntrCB[VLYNQ_NUM_INT_BITS + VLYNQ_IVR_CHAIN_SLOTS];
-+    VLYNQ_INTR_CNTRL_ICB  *freelist;
-+   
-+   /* table holding mapping between intVector and the bit position the interrupt
-+    * is mapped to(mapVector)*/
-+    char vector_map[32];
-+   
-+    /* user callback for vlynq events, NULL if unused */
-+    VLYNQ_REPORT_CB        report_cb;    
-+    
-+   /* user callback for resetting/realeasing remote device */
-+    VLYNQ_RESET_REMOTE     reset_cb;
-+
-+    /*** Handles provided for direct access to register set if need be
-+     * Must be intialized to point to appropriate address during 
-+     * vlynq_init */
-+    volatile VLYNQ_REG_SET * local;
-+    volatile VLYNQ_REG_SET * remote;
-+
-+    unsigned int  intCount; /* number of interrupts generated so far */
-+    unsigned int  isrCount; /* number of ISR invocations so far */
-+}VLYNQ_DEV;
-+
-+
-+typedef struct VLYNQ_ISR_ARGS_t
-+{
-+    int irq;
-+    void * arg;
-+    void * regset;
-+}VLYNQ_ISR_ARGS;
-+
-+
-+/****************************************
-+ *        Function Prototypes           *
-+ * API exported by generic vlynq driver *
-+ ****************************************/
-+/* Initialization function */ 
-+int vlynq_init( VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options);
-+
-+/* Check vlynq link */
-+unsigned int vlynq_link_check( VLYNQ_DEV * pdev);
-+
-+/* Set interrupt vector in local or remote device */
-+int vlynq_interrupt_vector_set( VLYNQ_DEV *pdev, 
-+                                         unsigned int int_vector,
-+                                         unsigned int map_vector, 
-+                                         VLYNQ_DEV_TYPE dev,
-+                                         VLYNQ_INTR_POLARITY pol,
-+                                         VLYNQ_INTR_TYPE type);
-+
-+
-+int vlynq_interrupt_vector_cntl( VLYNQ_DEV *pdev,
-+                                          unsigned int int_vector,
-+                                          VLYNQ_DEV_TYPE dev,
-+                                          unsigned int enable);
-+
-+unsigned int vlynq_interrupt_get_count( VLYNQ_DEV *pdev,
-+                                         unsigned int map_vector);
-+
-+int vlynq_install_isr( VLYNQ_DEV *pdev,
-+                                unsigned int map_vector,
-+                                VLYNQ_INTR_CNTRL_ISR isr,
-+                                void *arg1, void *arg2, void *arg3);
-+
-+int vlynq_uninstall_isr( VLYNQ_DEV *pdev,
-+                                  unsigned int map_vector,
-+                                  void *arg1, void *arg2, void *arg3);
-+
-+
-+void vlynq_root_isr(void *arg);
-+
-+void vlynq_delay(unsigned int clktime);
-+
-+/* The following functions, provide better granularity in setting
-+ * interrupt parameters. (for better support of linux INT Controller)
-+ * Note: The interrupt source is identified by "map_vector"- the bit 
-+ * position in interrupt status register*/
-+
-+int vlynq_interrupt_vector_map(VLYNQ_DEV * pdev,
-+                                        VLYNQ_DEV_TYPE dev,
-+                                        unsigned int int_vector,
-+                                        unsigned int map_vector);
-+
-+int vlynq_interrupt_set_polarity(VLYNQ_DEV * pdev,
-+                                          VLYNQ_DEV_TYPE dev,
-+                                          unsigned int map_vector,
-+                                          VLYNQ_INTR_POLARITY pol);
-+
-+int vlynq_interrupt_get_polarity( VLYNQ_DEV *pdev ,
-+                                           VLYNQ_DEV_TYPE dev_type,
-+                                           unsigned int map_vector);
-+
-+int vlynq_interrupt_set_type(VLYNQ_DEV * pdev,
-+                                      VLYNQ_DEV_TYPE dev,
-+                                      unsigned int map_vector,
-+                                      VLYNQ_INTR_TYPE type);
-+
-+int vlynq_interrupt_get_type( VLYNQ_DEV *pdev, 
-+                                       VLYNQ_DEV_TYPE dev_type,
-+                                       unsigned int map_vector);
-+
-+int vlynq_interrupt_enable(VLYNQ_DEV* pdev,
-+                                    VLYNQ_DEV_TYPE dev,
-+                                    unsigned int map_vector);
-+
-+int vlynq_interrupt_disable(VLYNQ_DEV * pdev,
-+                                     VLYNQ_DEV_TYPE dev,
-+                                     unsigned int map_vector);
-+                 
-+
-+              
-+        
-+
-+#endif /* _VLYNQ_HAL_H_ */
 diff -urN linux.old/include/asm-mips/ar7/vlynq_hal.h linux.dev/include/asm-mips/ar7/vlynq_hal.h
 --- linux.old/include/asm-mips/ar7/vlynq_hal.h	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/include/asm-mips/ar7/vlynq_hal.h	2005-11-10 01:10:46.095590250 +0100
Index: target/linux/ar7-2.4/patches/003-net_driver_cpmac.patch
===================================================================
--- target/linux/ar7-2.4/patches/003-net_driver_cpmac.patch	(Revision 3803)
+++ target/linux/ar7-2.4/patches/003-net_driver_cpmac.patch	(Arbeitskopie)
@@ -4664,7 +4664,7 @@
 +#define RX_QOS_ACT               (1 << 2)
 +#define RX_FLOW_ACT              (1 << 1)
 +#define TX_FLOW_ACT              (1 << 0)
-+#endif _INC_CPMAC_REG
++#endif /* _INC_CPMAC_REG */
 diff -urN linux.old/drivers/net/avalanche_cpmac/cpmdio.c linux.dev/drivers/net/avalanche_cpmac/cpmdio.c
 --- linux.old/drivers/net/avalanche_cpmac/cpmdio.c	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/drivers/net/avalanche_cpmac/cpmdio.c	2005-07-12 02:48:42.046593000 +0200
@@ -6030,7 +6030,7 @@
 +         if (!pBuf)
 +           {
 +            /* malloc failed, add this RCB to Needs Buffer List */
-+            (HAL_RCB *)TempRcb->Eop = TempRcb;                                  /* GSG +030430 */
++            TempRcb->Eop = (void *)TempRcb;                                     /* GSG +030430 */
 +            TempRcb->mode=1<<8|Ch;
 +            TempRcb->Off_BLen=(bit32u)HalDev;
 +            
@@ -11114,7 +11114,7 @@
 +  #define NWAY_AUTO           (1<<0)
 +
 +
-+#endif _INC_MDIO_REG
++#endif /* _INC_MDIO_REG */
 diff -urN linux.old/drivers/net/avalanche_cpmac/psp_config_build.c linux.dev/drivers/net/avalanche_cpmac/psp_config_build.c
 --- linux.old/drivers/net/avalanche_cpmac/psp_config_build.c	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/drivers/net/avalanche_cpmac/psp_config_build.c	2005-07-12 02:48:42.176573000 +0200
Index: target/linux/ar7-2.4/patches/015-cfi.patch
===================================================================
--- target/linux/ar7-2.4/patches/015-cfi.patch	(Revision 0)
+++ target/linux/ar7-2.4/patches/015-cfi.patch	(Revision 0)
@@ -0,0 +1,19 @@
+diff -urN linux-2.4.32/drivers/mtd/chips/cfi_probe.c linux-2.4.32.new/drivers/mtd/chips/cfi_probe.c
+--- linux-2.4.32/drivers/mtd/chips/cfi_probe.c	2006-05-18 17:54:37.000000000 +0200
++++ linux-2.4.32.new/drivers/mtd/chips/cfi_probe.c	2006-05-12 20:51:07.000000000 +0200
+@@ -247,11 +247,11 @@
+ 		printk("No Alternate Algorithm Table\n");
+ 		
+ 		
+-	printk("Vcc Minimum: %x.%x V\n", cfip->VccMin >> 4, cfip->VccMin & 0xf);
+-	printk("Vcc Maximum: %x.%x V\n", cfip->VccMax >> 4, cfip->VccMax & 0xf);
++	printk("Vcc Minimum: %u.%x V\n", cfip->VccMin >> 4, cfip->VccMin & 0xf);
++	printk("Vcc Maximum: %u.%x V\n", cfip->VccMax >> 4, cfip->VccMax & 0xf);
+ 	if (cfip->VppMin) {
+-		printk("Vpp Minimum: %x.%x V\n", cfip->VppMin >> 4, cfip->VppMin & 0xf);
+-		printk("Vpp Maximum: %x.%x V\n", cfip->VppMax >> 4, cfip->VppMax & 0xf);
++		printk("Vpp Minimum: %u.%x V\n", cfip->VppMin >> 4, cfip->VppMin & 0xf);
++		printk("Vpp Maximum: %u.%x V\n", cfip->VppMax >> 4, cfip->VppMax & 0xf);
+ 	}
+ 	else
+ 		printk("No Vpp line\n");
Index: target/linux/ar7-2.4/patches/020-pretty.patch
===================================================================
--- target/linux/ar7-2.4/patches/020-pretty.patch	(Revision 0)
+++ target/linux/ar7-2.4/patches/020-pretty.patch	(Revision 0)
@@ -0,0 +1,49 @@
+diff -urN linux-2.4.30/net/ipv4/netfilter/ip_conntrack_core.c linux-2.4.30.new/net/ipv4/netfilter/ip_conntrack_core.c
+--- linux-2.4.30/net/ipv4/netfilter/ip_conntrack_core.c	2005-11-12 23:17:05.000000000 +0100
++++ linux-2.4.30.new/net/ipv4/netfilter/ip_conntrack_core.c	2005-11-07 21:10:16.000000000 +0100
+@@ -1469,10 +1469,13 @@
+ 	WRITE_UNLOCK(&ip_conntrack_lock);
+ 
+ 	for (i = 0; i < ip_conntrack_htable_size; i++)
++	{
+ 		INIT_LIST_HEAD(&ip_conntrack_hash[i]);
++	}
+ 
+ 	/* For use by ipt_REJECT */
+ 	ip_ct_attach = ip_conntrack_attach;
++	
+ 	return ret;
+ 
+ err_free_hash:
+diff -urN linux-2.4.32/arch/mips/ar7/cmdline.c linux-2.4.32.new/arch/mips/ar7/cmdline.c
+--- linux-2.4.32/arch/mips/ar7/cmdline.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/cmdline.c	2005-12-27 21:44:16.000000000 +0100
+@@ -17,13 +17,12 @@
+  *
+  * Kernel command line creation using the prom monitor (YAMON) argc/argv.
+  */
++#include <linux/config.h>
+ #include <linux/init.h>
+ #include <linux/string.h>
+ 
+ #include <asm/bootinfo.h>
+-
+-extern int prom_argc;
+-extern int *_prom_argv;
++#include <asm/ar7/adam2_env.h>	/* prom_getenv, prom_argc, ... */
+ 
+ /*
+  * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+diff -urN linux-2.4.32/include/asm-mips/ar7/adam2_env.h linux-2.4.32.new/include/asm-mips/ar7/adam2_env.h
+--- linux-2.4.32/include/asm-mips/ar7/adam2_env.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/adam2_env.h	2005-12-27 21:44:16.000000000 +0100
+@@ -1,6 +1,9 @@
+ #ifndef _INCLUDE_ASM_AR7_ADAM2_ENV_H_
+ #define	_INCLUDE_ASM_AR7_ADAM2_ENV_H_
+ 
++extern int prom_argc;
++extern int *_prom_argv;
++
+ /* Environment variable */
+ typedef struct {
+ 	char *name;
Index: target/linux/ar7-2.4/patches/021-debug.patch
===================================================================
--- target/linux/ar7-2.4/patches/021-debug.patch	(Revision 0)
+++ target/linux/ar7-2.4/patches/021-debug.patch	(Revision 0)
@@ -0,0 +1,131 @@
+diff -urN linux-2.4.32/build.sh linux-2.4.32.new/build.sh
+--- linux-2.4.32/build.sh	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/build.sh	2006-04-28 08:41:16.000000000 +0200
+@@ -0,0 +1 @@
++make AFLAGS_KERNEL=-g CFLAGS_KERNEL=-g
+diff -urN linux-2.4.30/drivers/char/avalanche_vlynq/vlynq_hal.c linux-2.4.30.new/drivers/char/avalanche_vlynq/vlynq_hal.c
+--- linux-2.4.30/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-11-12 23:17:09.000000000 +0100
++++ linux-2.4.30.new/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-11-07 21:10:16.000000000 +0100
+@@ -519,7 +519,9 @@
+     VLYNQ_INT_STAT_REG = interrupts; /* clear the int CR register */
+     clrInterrupts = interrupts;      /* save them for further analysis */
+ 
++#if 0
+     debugPrint("vlynq_root_isr: dev %u. INTCR = 0x%08lx\n", pdev->dev_idx, clrInterrupts,0,0,0,0);
++#endif
+ 
+     /* Scan interrupt bits */
+     source =0;
+diff -urN linux-2.4.30/drivers/mtd/chips/cfi_cmdset_0001.c linux-2.4.30.new/drivers/mtd/chips/cfi_cmdset_0001.c
+--- linux-2.4.30/drivers/mtd/chips/cfi_cmdset_0001.c	2004-11-17 12:54:21.000000000 +0100
++++ linux-2.4.30.new/drivers/mtd/chips/cfi_cmdset_0001.c	2005-11-07 21:10:16.000000000 +0100
+@@ -65,7 +65,7 @@
+ };
+ 
+ /* #define DEBUG_LOCK_BITS */
+-/* #define DEBUG_CFI_FEATURES */
++#define DEBUG_CFI_FEATURES
+ 
+ #ifdef DEBUG_CFI_FEATURES
+ static void cfi_tell_features(struct cfi_pri_intelext *extp)
+diff -urN linux-2.4.30/drivers/mtd/chips/cfi_probe.c linux-2.4.30.new/drivers/mtd/chips/cfi_probe.c
+--- linux-2.4.30/drivers/mtd/chips/cfi_probe.c	2005-11-12 23:17:02.000000000 +0100
++++ linux-2.4.30.new/drivers/mtd/chips/cfi_probe.c	2005-11-07 21:10:16.000000000 +0100
+@@ -18,7 +18,7 @@
+ #include <linux/mtd/cfi.h>
+ #include <linux/mtd/gen_probe.h>
+ 
+-//#define DEBUG_CFI 
++#define DEBUG_CFI 
+ 
+ #ifdef DEBUG_CFI
+ static void print_cfi_ident(struct cfi_ident *);
+diff -urN linux-2.4.30/drivers/net/avalanche_cpmac/cpmacHalLx.c linux-2.4.30.new/drivers/net/avalanche_cpmac/cpmacHalLx.c
+--- linux-2.4.30/drivers/net/avalanche_cpmac/cpmacHalLx.c	2005-11-12 23:17:10.000000000 +0100
++++ linux-2.4.30.new/drivers/net/avalanche_cpmac/cpmacHalLx.c	2005-11-07 21:10:16.000000000 +0100
+@@ -370,10 +370,13 @@
+     int ret_val = 0;
+     int count   = 0;
+ 
++    dbgPrint("%s:%u\n", __FILE__, __LINE__);
++
+     /* Let's setup the TX Channels. */
+     for(;  p_tx_chan_info->opened_chan > 0; 
+         p_tx_chan_info->opened_chan--, count++)
+     {
++	dbgPrint("%s:%u\n", __FILE__, __LINE__);
+         if(p_hal_funcs->ChannelTeardown(p_hal_dev, count, flags) != 0)
+         {
+             errPrint("Error in tearing down channel %d for TX.\n", count);
+diff -urN linux-2.4.30/fs/jffs2/nodemgmt.c linux-2.4.30.new/fs/jffs2/nodemgmt.c
+--- linux-2.4.30/fs/jffs2/nodemgmt.c	2002-08-03 02:39:45.000000000 +0200
++++ linux-2.4.30.new/fs/jffs2/nodemgmt.c	2005-11-07 21:10:16.000000000 +0100
+@@ -87,6 +87,7 @@
+ 			int ret;
+ 
+ 			up(&c->alloc_sem);
++			D1(printk(KERN_DEBUG "free = %u, erasing = %u, needed = %u\n", c->nr_free_blocks, c->nr_erasing_blocks, blocksneeded));
+ 			if (c->dirty_size < c->sector_size) {
+ 				D1(printk(KERN_DEBUG "Short on space, but total dirty size 0x%08x < sector size 0x%08x, so -ENOSPC\n", c->dirty_size, c->sector_size));
+ 				spin_unlock_bh(&c->erase_completion_lock);
+diff -urN linux-2.4.30/fs/jffs2/pushpull.c linux-2.4.30.new/fs/jffs2/pushpull.c
+--- linux-2.4.30/fs/jffs2/pushpull.c	2001-10-05 00:13:18.000000000 +0200
++++ linux-2.4.30.new/fs/jffs2/pushpull.c	2005-11-07 21:10:16.000000000 +0100
+@@ -35,9 +35,10 @@
+  *
+  */
+ 
++#include <linux/errno.h>
++#include <linux/kernel.h>
+ #include <linux/string.h>
+ #include "pushpull.h"
+-#include <linux/errno.h>
+ 
+ void init_pushpull(struct pushpull *pp, char *buf, unsigned buflen, unsigned ofs, unsigned reserve)
+ {
+@@ -51,6 +52,7 @@
+ int pushbit(struct pushpull *pp, int bit, int use_reserved)
+ {
+ 	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve)) {
++		printk("%s:%d no space", __FILE__, __LINE__);
+ 		return -ENOSPC;
+ 	}
+ 
+diff -urN linux-2.4.30/fs/nfs/nfsroot.c linux-2.4.30.new/fs/nfs/nfsroot.c
+--- linux-2.4.30/fs/nfs/nfsroot.c	2003-08-25 13:44:43.000000000 +0200
++++ linux-2.4.30.new/fs/nfs/nfsroot.c	2005-11-07 21:10:16.000000000 +0100
+@@ -86,6 +86,7 @@
+ 
+ /* Define this to allow debugging output */
+ #undef NFSROOT_DEBUG
++#define NFSROOT_DEBUG
+ #define NFSDBG_FACILITY NFSDBG_ROOT
+ 
+ /* Default path we try to mount. "%s" gets replaced by our IP address */
+diff -urN linux-2.4.30/fs/proc/generic.c linux-2.4.30.new/fs/proc/generic.c
+--- linux-2.4.30/fs/proc/generic.c	2005-01-19 15:10:11.000000000 +0100
++++ linux-2.4.30.new/fs/proc/generic.c	2005-11-07 21:10:16.000000000 +0100
+@@ -446,6 +446,12 @@
+ 	ent->mode = mode;
+ 	ent->nlink = nlink;
+  out:
++#if defined(DEBUG) || 1
++	if (ent == 0) {
++		printk("%s:%u failed to create proc entry %s\n",
++				__FILE__, __LINE__, name);
++	}
++#endif
+ 	return ent;
+ }
+ 
+diff -urN linux-2.4.32/fs/squashfs/squashfs.h linux-2.4.32.new/fs/squashfs/squashfs.h
+--- linux-2.4.32/fs/squashfs/squashfs.h	2006-05-20 17:09:17.000000000 +0200
++++ linux-2.4.32.new/fs/squashfs/squashfs.h	2006-05-20 15:21:28.000000000 +0200
+@@ -27,6 +27,7 @@
+ #ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+ #undef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+ #endif
++//~ #define SQUASHFS_TRACE 1
+ #ifdef SQUASHFS_TRACE
+ #define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+ #else
Index: target/linux/ar7-2.4/patches/022-kgdb.patch
===================================================================
--- target/linux/ar7-2.4/patches/022-kgdb.patch	(Revision 0)
+++ target/linux/ar7-2.4/patches/022-kgdb.patch	(Revision 0)
@@ -0,0 +1,140 @@
+diff -urN linux-2.4.32/arch/mips/ar7/gdb_hook.c linux-2.4.32.new/arch/mips/ar7/gdb_hook.c
+--- linux-2.4.32/arch/mips/ar7/gdb_hook.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/gdb_hook.c	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,136 @@
++/*
++ * Carsten Langgaard, carstenl@mips.com
++ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
++ *
++ * ########################################################################
++ *
++ *  This program is free software; you can distribute it and/or modify it
++ *  under the terms of the GNU General Public License (Version 2) as
++ *  published by the Free Software Foundation.
++ *
++ *  This program is distributed in the hope it will be useful, but WITHOUT
++ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ *  for more details.
++ *
++ *  You should have received a copy of the GNU General Public License along
++ *  with this program; if not, write to the Free Software Foundation, Inc.,
++ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
++ *
++ * ########################################################################
++ *
++ * This is the interface to the remote debugger stub.
++ *
++ */
++#include <linux/config.h>
++#include <linux/serialP.h>
++#include <linux/serial_reg.h>
++
++#include <asm/serial.h>
++#include <asm/io.h>
++
++static struct serial_state rs_table[RS_TABLE_SIZE] = {
++	SERIAL_PORT_DFNS	/* Defined in serial.h */
++};
++
++static struct async_struct kdb_port_info = {0};
++
++int (*generic_putDebugChar)(char);
++char (*generic_getDebugChar)(void);
++
++static __inline__ unsigned int serial_in(struct async_struct *info, int offset)
++{
++	return inb(info->port + offset);
++}
++
++static __inline__ void serial_out(struct async_struct *info, int offset,
++				int value)
++{
++	outb(value, info->port+offset);
++}
++
++void rs_kgdb_hook(int tty_no) {
++	int t;
++	struct serial_state *ser = &rs_table[tty_no];
++
++	kdb_port_info.state = ser;
++	kdb_port_info.magic = SERIAL_MAGIC;
++	kdb_port_info.port = ser->port;
++	kdb_port_info.flags = ser->flags;
++
++	/*
++	 * Clear all interrupts
++	 */
++	serial_in(&kdb_port_info, UART_LSR);
++	serial_in(&kdb_port_info, UART_RX);
++	serial_in(&kdb_port_info, UART_IIR);
++	serial_in(&kdb_port_info, UART_MSR);
++
++	/*
++	 * Now, initialize the UART
++	 */
++	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
++	if (kdb_port_info.flags & ASYNC_FOURPORT) {
++		kdb_port_info.MCR = UART_MCR_DTR | UART_MCR_RTS;
++		t = UART_MCR_DTR | UART_MCR_OUT1;
++	} else {
++		kdb_port_info.MCR
++			= UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2;
++		t = UART_MCR_DTR | UART_MCR_RTS;
++	}
++
++	kdb_port_info.MCR = t;		/* no interrupts, please */
++	serial_out(&kdb_port_info, UART_MCR, kdb_port_info.MCR);
++
++	/*
++	 * and set the speed of the serial port
++	 * (currently hardwired to 115200 8N1
++	 */
++
++	/* baud rate is fixed to 115200 (is this sufficient?)*/
++	t = kdb_port_info.state->baud_base / 115200;
++	/* set DLAB */
++	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
++	serial_out(&kdb_port_info, UART_DLL, t & 0xff);/* LS of divisor */
++	serial_out(&kdb_port_info, UART_DLM, t >> 8);  /* MS of divisor */
++	/* reset DLAB */
++	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);
++}
++
++int putDebugChar(char c)
++{
++	return generic_putDebugChar(c);
++}
++
++char getDebugChar(void)
++{
++	return generic_getDebugChar();
++}
++
++int rs_putDebugChar(char c)
++{
++
++	if (!kdb_port_info.state) { 	/* need to init device first */
++		return 0;
++	}
++
++	while ((serial_in(&kdb_port_info, UART_LSR) & UART_LSR_THRE) == 0)
++		;
++
++	serial_out(&kdb_port_info, UART_TX, c);
++
++	return 1;
++}
++
++char rs_getDebugChar(void)
++{
++	if (!kdb_port_info.state) { 	/* need to init device first */
++		return 0;
++	}
++
++	while (!(serial_in(&kdb_port_info, UART_LSR) & 1))
++		;
++
++	return(serial_in(&kdb_port_info, UART_RX));
++}
++
Index: target/linux/ar7-2.4/patches/012-vlynq.patch
===================================================================
--- target/linux/ar7-2.4/patches/012-vlynq.patch	(Revision 0)
+++ target/linux/ar7-2.4/patches/012-vlynq.patch	(Revision 0)
@@ -0,0 +1,353 @@
+diff -urN linux-2.4.32/arch/mips/ar7/irq-vlynq.c linux-2.4.32.new/arch/mips/ar7/irq-vlynq.c
+--- linux-2.4.32/arch/mips/ar7/irq-vlynq.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/irq-vlynq.c	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,269 @@
++/*
++ * Interrupt handling for VLYNQ interrupts.
++ */
++
++#include <linux/config.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/module.h>
++
++#include <asm/irq.h>
++#include <asm/mipsregs.h>
++#include <asm/ar7/ar7.h>
++#include <asm/ar7/avalanche_intc.h>
++#include <asm/ar7/avalanche_types.h>	/* vlynqDevice0 */
++
++#if defined(CONFIG_AR7_VLYNQ)
++# define CONFIG_MIPS_AVALANCHE_VLYNQ
++# include <asm/ar7/vlynq_hal.h>
++#else
++# error This file needs CONFIG_AR7_VLYNQ
++#endif
++
++#if (AVALANCHE_INT_END) != NR_IRQS
++# error unexpected number of interrupts, check size of irq_desc
++#endif
++
++#if 1
++# define dprintk(format, args...) printk(KERN_DEBUG format, ## args)
++# define dprintk(format, args...) printk(format, ## args)
++#else
++# define dprintk(format, args...) ((void)0)
++#endif
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++
++static unsigned int startup_vlynq_irq(unsigned int irq_nr);
++static void shutdown_vlynq_irq(unsigned int irq_nr);
++static void enable_vlynq_irq(unsigned int irq_nr);
++static void disable_vlynq_irq(unsigned int irq_nr);
++#define mask_and_ack_vlynq_irq   disable_vlynq_irq
++static void end_vlynq_irq(unsigned int irq_nr);
++
++static struct hw_interrupt_type vlynq_irq_type = {
++	"VLYNQ",
++	startup_vlynq_irq,
++	shutdown_vlynq_irq,
++	enable_vlynq_irq,
++	disable_vlynq_irq,
++	mask_and_ack_vlynq_irq,
++	end_vlynq_irq,
++	NULL
++};
++
++static void end_vlynq_irq(unsigned int irq)
++{
++	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
++		unsigned long flags;
++		save_and_cli(flags);
++		enable_vlynq_irq(irq);
++		restore_flags(flags);
++	}
++}
++
++static void disable_vlynq_irq(unsigned int irq_nr)
++{
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < AVALANCHE_INTC_END || irq_nr >= AVALANCHE_INT_END) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		vlynq_interrupt_disable(&vlynqDevice1, VLYNQ_REMOTE_DVC,
++					irq_nr - AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		vlynq_interrupt_disable(&vlynqDevice0, VLYNQ_REMOTE_DVC,
++					irq_nr - AVALANCHE_INTC_END);
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (p_vlynq_interrupt_disable == NULL) {
++	} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		(*p_vlynq_interrupt_disable) (p_vlynqDevice1, 1,
++					      irq_nr -
++					      AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		(*p_vlynq_interrupt_disable) (p_vlynqDevice0, 1,
++					      irq_nr - AVALANCHE_INTC_END);
++	}
++#endif
++}
++
++static void enable_vlynq_irq(unsigned int irq_nr)
++{
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < AVALANCHE_INTC_END || irq_nr >= AVALANCHE_INT_END) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		vlynq_interrupt_enable(&vlynqDevice1, VLYNQ_REMOTE_DVC,
++				       irq_nr - AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		vlynq_interrupt_enable(&vlynqDevice0, VLYNQ_REMOTE_DVC,
++				       irq_nr - AVALANCHE_INTC_END);
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (p_vlynq_interrupt_enable == NULL) {
++	} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		(*p_vlynq_interrupt_enable) (p_vlynqDevice1, 1,
++					     irq_nr -
++					     AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		(*p_vlynq_interrupt_enable) (p_vlynqDevice0, 1,
++					     irq_nr - AVALANCHE_INTC_END);
++	}
++#endif
++}
++
++static unsigned int startup_vlynq_irq(unsigned int irq_nr)
++{
++	irq_desc_t *desc;
++	struct irqaction *action;
++	void (*handler) (int, void *, struct pt_regs *) = 0;
++	void *dev_id = 0;
++
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr < AVALANCHE_INTC_END || irq_nr >= AVALANCHE_INT_END) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++
++	desc = irq_desc + irq_nr;
++	action = desc->action;
++	if (action != 0) {
++		handler = action->handler;
++		dev_id = action->dev_id;
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		vlynq_install_isr(&vlynqDevice1,
++				  irq_nr - AVALANCHE_INT_END_LOW_VLYNQ,
++				  (VLYNQ_INTR_CNTRL_ISR) handler,
++				  (void *)irq_nr, dev_id, NULL);
++	} else {
++		/* Vlynq interupts 0-31 */
++		vlynq_install_isr(&vlynqDevice0, irq_nr - AVALANCHE_INTC_END,
++				  (VLYNQ_INTR_CNTRL_ISR) handler,
++				  (void *)irq_nr, dev_id, NULL);
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	if (p_vlynq_install_isr == NULL) {
++		enable_irq(irq_nr);
++		return 1;
++	} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		(*p_vlynq_install_isr) (p_vlynqDevice1,
++					irq_nr - AVALANCHE_INT_END_LOW_VLYNQ,
++					(p_vlynq_intr_cntrl_isr_t) handler,
++					(void *)irq_nr, dev_id, NULL);
++	} else {
++		/* Vlynq interupts 0-31 */
++		(*p_vlynq_install_isr) (p_vlynqDevice0,
++					irq_nr - AVALANCHE_INTC_END,
++					(p_vlynq_intr_cntrl_isr_t) handler,
++					(void *)irq_nr, dev_id, NULL);
++	}
++#endif
++	enable_vlynq_irq(irq_nr);
++	return 0;		/* never anything pending */
++}
++
++static void shutdown_vlynq_irq(unsigned int irq_nr)
++{
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		irq_desc_t *desc = irq_desc + irq_nr;
++		struct irqaction *action = desc->action;
++		void *dev_id = ((action != 0) ? action->dev_id : 0);
++
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			vlynq_uninstall_isr(&vlynqDevice1,
++					    irq_nr -
++					    AVALANCHE_INT_END_LOW_VLYNQ,
++					    (void *)irq_nr, dev_id, NULL);
++		} else {
++			/* Vlynq interupts 0-31 */
++			vlynq_uninstall_isr(&vlynqDevice0,
++					    irq_nr - AVALANCHE_INTC_END,
++					    (void *)irq_nr, dev_id, NULL);
++		}
++
++		// action = irq_desc[irq_nr].action;
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_uninstall_isr == NULL) {
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			(*p_vlynq_uninstall_isr) (p_vlynqDevice1,
++						  irq_nr -
++						  AVALANCHE_INT_END_LOW_VLYNQ,
++						  (void *)irq_nr, dev_id, NULL);
++		} else {
++			/* Vlynq interupts 0-31 */
++			(*p_vlynq_uninstall_isr) (p_vlynqDevice0,
++						  irq_nr - AVALANCHE_INTC_END,
++						  (void *)irq_nr, dev_id, NULL);
++		}
++
++		// action = irq_desc[irq_nr].action;
++	}
++#endif
++}
++
++void __init vlynq_irq_init(int base)
++{
++	unsigned int i;
++
++	//~ ar7_irq_base = base;
++
++	/* Set irq data for VLYNQ interrupts */
++	for (i = AVALANCHE_INTC_END; i < AVALANCHE_INT_END; i++) {
++		irq_desc[i].status = IRQ_DISABLED;
++		irq_desc[i].action = 0;
++		irq_desc[i].depth = 1;
++		irq_desc[i].handler = &vlynq_irq_type;
++	}
++
++	return;
++}
++
++#endif
+diff -urN linux-2.4.32/arch/mips/ar7/Makefile linux-2.4.32.new/arch/mips/ar7/Makefile
+--- linux-2.4.32/arch/mips/ar7/Makefile	2006-05-20 17:09:29.000000000 +0200
++++ linux-2.4.32.new/arch/mips/ar7/Makefile	2006-05-19 21:11:56.000000000 +0200
+@@ -1,14 +1,19 @@
+-.S.s:
+-	$(CPP) $(AFLAGS) $< -o $*.s
++#
++# Makefile for the Linux/MIPS kernel - AR7 specific part.
++#
++# Note! Dependencies are done automagically by 'make dep', which also
++# removes any old dependencies. DON'T put your own dependencies here
++# unless it's something special (ie not a .c file).
++#
+ 
+-.S.o:
+-	$(CC) $(AFLAGS) -c $< -o $*.o
++USE_STANDARD_AS_RULE := true
+ 
+ EXTRA_CFLAGS := -I$(TOPDIR)/include/asm/ar7 -DLITTLE_ENDIAN -D_LINK_KSEG0_
+ O_TARGET := ar7.o
+ 
+ obj-y := tnetd73xx_misc.o misc.o
+ export-objs := misc.o irq.o init.o
+-obj-y += setup.o irq.o int-handler.o reset.o init.o psp_env.o memory.o promlib.o cmdline.o
++obj-y += setup.o irq.o irq-vlynq.o int-handler.o reset.o init.o psp_env.o memory.o promlib.o cmdline.o
++obj-$(CONFIG_KGDB) += gdb_hook.o
+ 
+ include $(TOPDIR)/Rules.make
+diff -urN linux-2.4.32/arch/mips/ar7/setup.c linux-2.4.32.new/arch/mips/ar7/setup.c
+--- linux-2.4.32/arch/mips/ar7/setup.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/setup.c	2005-12-27 21:44:16.000000000 +0100
+@@ -36,6 +36,7 @@
+ 
+ extern void ar7_reboot_setup(void);
+ extern void ar7_irq_init(int);
++extern void vlynq_irq_init(int);
+ extern asmlinkage void ar7IRQ(void);
+ 
+ void ar7_time_init(void)
+@@ -55,6 +56,7 @@
+   init_generic_irq();
+   mips_cpu_irq_init(0);
+   ar7_irq_init(8);
++  vlynq_irq_init(80);
+ 
+   /* Now safe to set the exception vector. */
+   set_except_vector(0, ar7IRQ);
+@@ -124,7 +126,7 @@
+ 		generic_putDebugChar = rs_putDebugChar;
+ 		generic_getDebugChar = rs_getDebugChar;
+ 
+-		prom_printf("KGDB: Using serial line /dev/ttyS%d for session, "
++		printk("KGDB: Using serial line /dev/ttyS%d for session, "
+ 				"please connect your debugger\n", line ? 1 : 0);
+ 
+ 		remote_debug = 1;
+diff -urN linux-2.4.32/arch/mips/ar7/setup.c linux-2.4.32.new/arch/mips/ar7/setup.c
+--- linux-2.4.32/arch/mips/ar7/setup.c	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/arch/mips/ar7/setup.c	2006-05-18 21:13:47.000000000 +0200
+@@ -116,17 +116,17 @@
+ 		int line;
+ 		argptr += strlen("kgdb=ttyS");
+ 		if (*argptr != '0' && *argptr != '1')
+-			printk("KGDB: Unknown serial line /dev/ttyS%c, "
++			printk(KERN_WARNING "KGDB: Unknown serial line /dev/ttyS%c, "
+ 					"falling back to /dev/ttyS1\n", *argptr);
+ 		line = *argptr == '0' ? 0 : 1;
+-		printk("KGDB: Using serial line /dev/ttyS%d for session\n",
++		printk(KERN_WARNING "KGDB: Using serial line /dev/ttyS%d for session\n",
+ 				line ? 1 : 0);
+ 
+ 		rs_kgdb_hook(line);
+ 		generic_putDebugChar = rs_putDebugChar;
+ 		generic_getDebugChar = rs_getDebugChar;
+ 
+-		printk("KGDB: Using serial line /dev/ttyS%d for session, "
++		printk(KERN_ALERT "KGDB: Using serial line /dev/ttyS%d for session, "
+ 				"please connect your debugger\n", line ? 1 : 0);
+ 
+ 		remote_debug = 1;
Index: target/linux/ar7-2.4/patches/004-atm_driver.patch
===================================================================
--- target/linux/ar7-2.4/patches/004-atm_driver.patch	(Revision 3803)
+++ target/linux/ar7-2.4/patches/004-atm_driver.patch	(Arbeitskopie)
@@ -5194,7 +5194,7 @@
 +           {
 +            /* malloc failed, add this RCB to Needs Buffer List */
 +            TempRcb->FragCount = 1;                                             /*MJH+030417*/
-+            (HAL_RCB *)TempRcb->Eop = TempRcb;                                  /* GSG +030430 */
++            TempRcb->Eop = (void *)TempRcb;                                     /* GSG +030430 */
 +
 +            if(HalDev->NeedsCount < MAX_NEEDS)                                  /* +MJH 030410 */
 +              {                                                                 /* +MJH 030410 */
@@ -7714,7 +7714,7 @@
 +
 +/* END OF FILE */
 +
-+#endif _INC_SAR_REG
++#endif /* _INC_SAR_REG */
 diff -urN linux.old/drivers/atm/sangam_atm/cpswhal_cpaal5.h linux.dev/drivers/atm/sangam_atm/cpswhal_cpaal5.h
 --- linux.old/drivers/atm/sangam_atm/cpswhal_cpaal5.h	1970-01-01 01:00:00.000000000 +0100
 +++ linux.dev/drivers/atm/sangam_atm/cpswhal_cpaal5.h	2005-08-23 04:46:50.088845064 +0200
Index: target/linux/ar7-2.4/patches/011-sinus.patch
===================================================================
--- target/linux/ar7-2.4/patches/011-sinus.patch	(Revision 0)
+++ target/linux/ar7-2.4/patches/011-sinus.patch	(Revision 0)
@@ -0,0 +1,5629 @@
+diff -urN linux-2.4.32/arch/mips/ar7/init.c linux-2.4.32.new/arch/mips/ar7/init.c
+--- linux-2.4.32/arch/mips/ar7/init.c	2006-05-19 19:04:47.000000000 +0200
++++ linux-2.4.32.new/arch/mips/ar7/init.c	2006-05-18 19:52:50.000000000 +0200
+@@ -24,10 +24,14 @@
+ #include <linux/module.h>
+ 
+ #include <asm/io.h>
++#include <asm/bootinfo.h>
+ #include <asm/mips-boards/prom.h>
+ #include <asm/mips-boards/generic.h>
+ 
+ #include <asm/ar7/adam2_env.h>
++#if 1
++#include <asm/mipsregs.h>	/* read_c0_config */
++#endif
+ 
+ int prom_argc;
+ int *_prom_argv, *_prom_envp;
+@@ -35,7 +39,93 @@
+ /* max # of Adam2 environment variables */
+ #define MAX_ENV_ENTRY 80
+ 
++#ifndef CONFIG_MIPS_SINUS154
+ static t_env_var local_envp[MAX_ENV_ENTRY];
++#else /* CONFIG_MIPS_SINUS154 */
++static t_env_var local_envp[/*MAX_ENV_ENTRY*/] = {
++	// Ethernet
++        {"ethaddr", "192.168.2.1"},
++        {"maca", "00:30:f1:df:5f:55"},		// !!!
++	{"mac_phy_sel", "int"},			// unused?
++	{"MAC_PORT", "0"},			// internal = 0, external = 1
++	{"threshold", "20"},
++	// ATM
++	{"oam_lb_timeout", "5000"},
++        {"modulation", "MMODE"},
++        {"enable_margin_retrain", 0},
++        {"enable_rate_adapt", 0},
++        {"enable_trellis", 0},
++        {"maximum_bits_per_carrier", 0},
++        {"maximum_interleave_depth", 0},
++        {"pair_selection", 0},
++        {"dgas_polarity", 0},
++        {"los_alarm", 0},
++        {"eoc_vendor_id", 0},
++        {"macc", "00:01:02:03:04:05"},
++        {"sar_ipacemax", "2"},
++        {"TurboDSL", "1"},
++	//
++	{"memsize", "0x01000000"},
++        {"modetty0", "115200,n,8,1,hw"},
++        {"modetty1", "57600,n,8,1,hw"},
++	// MTD partitions
++        {"mtd0", "0x90000000,0x90020000,adam2"},      // Boot
++        {"mtd4", "0x90020000,0x90040000,OpenWrt"},    // Configuration
++#if 1
++        {"mtd5", "0x90040000,0x90050000,pfs"},        // Web Image (reserved)
++        {"mtd2", "0x90050000,0x90110000,rootfs"},     // Web Image (squashfs)
++#else
++        {"mtd2", "0x90040000,0x90110000,rootfs"},     // Web Image
++#endif
++        {"mtd1", "0x90110000,0x901F0000,linux"},      // Code Image (zipped kernel)
++        {"mtd3", "0x901F0000,0x90200000,config"},     // Boot Params
++         //~ {"kernel_args", "root=/dev/nfs rw nfsroot=192.168.0.2:/nfsroot console=ttyS0,115200 init=/etc/preinit noinitrd"},
++ 	// Device br0 does not work (device is not available at boot time).
++        {
++		"kernel_args",
++#if defined(CONFIG_MTD) && defined(CONFIG_SQUASHFS)
++# warning Using_SQUASHFS_boot
++		"root=/dev/mtdblock4 rootfstype=squashfs "
++#elif defined(CONFIG_ROOT_NFS)
++# warning Using_NFS_boot
++		"root=/dev/nfs rw nfsroot=/nfsroot,nolock "
++		"ip=192.168.2.1:192.168.2.2::255.255.255.0:sinus:eth0:off "
++#else
++# error Undefined root filesystem (missing ROOT_NFS or MTD and SQUASHFS)
++#endif
++#if defined(CONFIG_MTD_CMDLINE_PARTS) && defined(CONFIG_MIPS_SINUS154)
++# warning Cmdline defines MTD partitions
++		"mtdparts=sinus154:128k(Boot)ro,128k(Config),832k(Web),896k(Code),64k(Params) "
++#endif
++#if 0 && defined(CONFIG_KGDB)
++		"kgdb=ttyS0,115200 "
++#endif
++#if defined(CONFIG_RUNTIME_DEBUG)
++		//~ "debug "
++#endif
++		"console=ttyS0,115200 init=/etc/preinit.sinus154 noinitrd"
++	},
++        {0}
++#if 0
++flashsize       0x00400000
++modetty1        38400,n,8,1,hw
++bootserport     tty0
++cpufrequency    150000000
++sysfrequency    125000000
++bootloaderVersion       0.22.02
++ProductID       AR7WRD
++HWRevision      Unknown
++SerialNumber    none
++my_ipaddress    10.48.88.66
++prompt  Adam2_AR7RD
++firstfreeaddress        0x9401d328
++req_fullrate_freq       125000000
++autoload        1
++mac_ap  00:0F:3D:98:09:F4
++#endif
++};
++#endif
++
+ static int env_type = 0;
+ int init_debug = 0;
+ 
+@@ -127,7 +217,7 @@
+ 
+ 	ethaddr_str = prom_getenv("ethaddr");
+ 	if (!ethaddr_str) {
+-		printk("ethaddr not set in boot prom\n");
++		printk(KERN_WARNING "ethaddr not set in boot prom\n");
+ 		return -1;
+ 	}
+ 	str2eaddr(ethernet_addr, ethaddr_str);
+@@ -155,6 +245,10 @@
+ 
+ int __init prom_init(int argc, char **argv, char **envp)
+ {
++#ifdef CONFIG_MIPS_SINUS154
++	mips_machgroup = MACH_GROUP_AR7;
++	mips_machtype = MACH_AR7_SINUS154;
++#else
+ 	int i;
+ 
+ 	t_env_var *env = (t_env_var *) envp;
+@@ -165,7 +259,7 @@
+ 	_prom_argv = (int *)argv;
+ 	_prom_envp = (int *)envp;
+ 
+-	if(strcmp(psp_env, psp_env_version) == 0) {
++	if((psp_env != 0) && (strcmp(psp_env, psp_env_version) == 0)) {
+  		/* PSPBOOT */
+ 
+ 		env_type = 1;
+@@ -188,10 +282,23 @@
+ 			}
+ 		}
+ 	}
++#endif
+ 
+ 	set_io_port_base(0);
+ 
++#if !defined(CONFIG_MIPS_SINUS154)
+ 	prom_printf("\nLINUX started...\n");
++#else
++	printk("\nLINUX started...\n");
++	printk(KERN_DEBUG "CP0.config0 = %08x\n", read_c0_config());
++	printk(KERN_DEBUG "CP0.config1 = %08x\n", read_c0_config1());
++	printk(KERN_DEBUG "CP0.config2 = %08x\n", read_c0_config2());
++	printk(KERN_DEBUG "CP0.config3 = %08x\n", read_c0_config3());
++	printk(KERN_DEBUG "CP0.config4 = %08x\n", read_c0_config4());
++	printk(KERN_DEBUG "CP0.config5 = %08x\n", read_c0_config5());
++	printk(KERN_DEBUG "CP0.config6 = %08x\n", read_c0_config6());
++	printk(KERN_DEBUG "CP0.config7 = %08x\n", read_c0_config7());
++#endif
+ 	prom_init_cmdline();
+ 	prom_meminit();
+ 
+diff -urN linux-2.4.32/arch/mips/ar7/irq.c linux-2.4.32.new/arch/mips/ar7/irq.c
+--- linux-2.4.32/arch/mips/ar7/irq.c	2006-05-19 19:04:47.000000000 +0200
++++ linux-2.4.32.new/arch/mips/ar7/irq.c	2006-05-18 20:25:50.000000000 +0200
+@@ -26,20 +26,29 @@
+ 
+ #include <linux/init.h>
+ #include <linux/interrupt.h>
++#include <linux/module.h>
+ 
+ #include <asm/irq.h>
+ #include <asm/mipsregs.h>
+ #include <asm/ar7/ar7.h>
+ #include <asm/ar7/avalanche_intc.h>
+ 
++#if 1
++# define dprintk(format, args...) printk(KERN_DEBUG format, ## args)
++#else
++# define dprintk(format, args...) ((void)0)
++#endif
++
++static void avalanche_int_set(int channel, int line);
++
+ #define shutdown_avalanche_irq	disable_avalanche_irq
+ #define mask_and_ack_avalanche_irq   disable_avalanche_irq
+ 
+-static unsigned int startup_avalanche_irq(unsigned int irq);
+-static void end_avalanche_irq(unsigned int irq);
+-void enable_avalanche_irq(unsigned int irq_nr);
+-void disable_avalanche_irq(unsigned int irq_nr);
+-void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs);
++static unsigned int startup_avalanche_irq(unsigned int irq_nr);
++static void end_avalanche_irq(unsigned int irq_nr);
++static void enable_avalanche_irq(unsigned int irq_nr);
++static void disable_avalanche_irq(unsigned int irq_nr);
++static void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs);
+ 
+ static struct hw_interrupt_type avalanche_irq_type = {
+ 	"AR7",
+@@ -58,10 +67,14 @@
+     ar7_hw0_interrupt, 0, 0, "AR7 on hw0", NULL, NULL
+ };
+ 
+-struct avalanche_ictrl_regs         *avalanche_hw0_icregs;  /* Interrupt control regs (primary)   */
+-struct avalanche_exctrl_regs        *avalanche_hw0_ecregs;  /* Exception control regs (secondary) */
+-struct avalanche_ipace_regs         *avalanche_hw0_ipaceregs;
+-struct avalanche_channel_int_number *avalanche_hw0_chregs;  /* Channel control registers          */
++static volatile struct avalanche_ictrl_regs         * const avalanche_hw0_icregs =
++	((struct avalanche_ictrl_regs *)AVALANCHE_ICTRL_REGS_BASE);  /* Interrupt control regs (primary)   */
++static volatile struct avalanche_exctrl_regs        * const avalanche_hw0_ecregs =
++	((struct avalanche_exctrl_regs *)AVALANCHE_ECTRL_REGS_BASE);  /* Exception control regs (secondary) */
++static volatile struct avalanche_ipace_regs         * const avalanche_hw0_ipaceregs =
++	((struct avalanche_ipace_regs *)AVALANCHE_IPACE_REGS_BASE);
++static volatile struct avalanche_channel_int_number * const avalanche_hw0_chregs =
++	((struct avalanche_channel_int_number *)AVALANCHE_CHCTRL_REGS_BASE);  /* Channel control registers          */
+ 
+ /*
+    This remaps interrupts to exist on other channels than the default
+@@ -75,16 +88,26 @@
+ static void end_avalanche_irq(unsigned int irq)
+ {
+ 	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
++	{
++		unsigned long flags;
++		save_and_cli(flags);
+ 		enable_avalanche_irq(irq);
++		restore_flags(flags);
++	}
+ }
+ 
+-void disable_avalanche_irq(unsigned int irq_nr)
++static void disable_avalanche_irq(unsigned int irq_nr)
+ {
+-	unsigned long flags;
+-	unsigned long chan_nr=0;
++	unsigned long chan_nr;
+ 
+-	save_and_cli(flags);
++	//~ dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
+ 
++	if (irq_nr <  MIPS_EXCEPTION_OFFSET || irq_nr >= AVALANCHE_INTC_END)
++	{
++		printk(KERN_ALERT "whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++ 
+ 	/* irq_nr represents the line number for the interrupt.  We must
+ 	 *  disable the channel number associated with that line number.
+ 	 */
+@@ -109,17 +132,20 @@
+ 
+ 	else  /* secondary interrupt #'s 0-31 */
+ 		avalanche_hw0_ecregs->exiecr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+-
+-	restore_flags(flags);
+ }
+ 
+-void enable_avalanche_irq(unsigned int irq_nr)
++static void enable_avalanche_irq(unsigned int irq_nr)
+ {
+-	unsigned long flags;
+-	unsigned long chan_nr=0;
++	unsigned long chan_nr;
+ 
+-	save_and_cli(flags);
++	//~ dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
+ 
++	if (irq_nr <  MIPS_EXCEPTION_OFFSET || irq_nr >= AVALANCHE_INTC_END)
++	{
++		printk(KERN_ALERT "whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++ 
+ 	/* irq_nr represents the line number for the interrupt.  We must
+ 	 *  disable the channel number associated with that line number.
+ 	 */
+@@ -142,24 +168,18 @@
+ 
+ 	else    /* secondary interrupt #'s 0-31 */
+ 		avalanche_hw0_ecregs->exiesr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+-
+-	restore_flags(flags);
+ }
+ 
+ static unsigned int startup_avalanche_irq(unsigned int irq)
+ {
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq);
+ 	enable_avalanche_irq(irq);
+ 	return 0; /* never anything pending */
+ }
+ 
+ void __init ar7_irq_init(int base)
+ {
+-	int i;
+-
+-	avalanche_hw0_icregs = (struct avalanche_ictrl_regs *)AVALANCHE_ICTRL_REGS_BASE;
+-	avalanche_hw0_ecregs = (struct avalanche_exctrl_regs *)AVALANCHE_ECTRL_REGS_BASE;
+-	avalanche_hw0_ipaceregs = (struct avalanche_ipace_regs *)AVALANCHE_IPACE_REGS_BASE;
+-	avalanche_hw0_chregs = (struct avalanche_channel_int_number *)AVALANCHE_CHCTRL_REGS_BASE;
++	unsigned int i;
+ 
+ 	/*  Disable interrupts and clear pending
+ 	 */
+@@ -174,7 +194,7 @@
+ 
+ 	// avalanche_hw0_ipaceregs->ipacep = (2*get_avalanche_vbus_freq()/1000000)*4;
+ 	/* hack for speeding up the pacing. */
+-	printk("the pacing pre-scalar has been set as 600.\n");
++	printk(KERN_NOTICE "the pacing pre-scalar has been set as 600.\n");
+ 	avalanche_hw0_ipaceregs->ipacep = 600;
+ 	/* Channel to line mapping, Line to Channel mapping */
+ 
+@@ -182,7 +202,8 @@
+ 		avalanche_int_set(i,i);
+ 
+ 	ar7_irq_base = base;
+-	for (i = base; i <= base+40; i++)
++	/* Set irq data for primary interrupts */
++	for (i = base; i <= base + 40; i++)
+ 	{
+ 		irq_desc[i].status	= IRQ_DISABLED;
+ 		irq_desc[i].action	= 0;
+@@ -196,42 +217,35 @@
+ 	return;
+ }
+ 
+-void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs)
++static void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs)
+ {
+ 	int irq;
+ 	unsigned long int_line_number, status;
+-	int i, chan_nr = 0;
++	unsigned i, chan_nr;
+ 
+ 	int_line_number = ((avalanche_hw0_icregs->pintir >> 16) & 0x3F);
+ 	chan_nr = ((avalanche_hw0_icregs->pintir) & 0x3F);
+ 
+-	if(chan_nr < 32) /* primary 0-31 */
+-	{
++	if (chan_nr < 32) {
++		/* primary 0-31 */
+ 		if( chan_nr != uni_secondary_interrupt)
+ 			avalanche_hw0_icregs->intcr1 = (1<<chan_nr);
+ 
+-	}
+-
+-	if((chan_nr < 40) && (chan_nr > 31)) /* primary 32-39 */
+-	{
++	} else if (chan_nr < 40) {
++		/* primary 32-39 */
+ 		avalanche_hw0_icregs->intcr2 = (1<<(chan_nr-32));
+-	}
+-
+-
+-	/* If the Priority Interrupt Index Register returns 40  then no
+-	 * interrupts are pending
+-	 */
+-
+-	if(chan_nr == 40)
++	} else if (chan_nr == 40) {
++		/* If the Priority Interrupt Index Register returns 40 then no
++		 * interrupts are pending.
++		 */
+ 		return;
++	}
+ 
+-	if(chan_nr == uni_secondary_interrupt) /* secondary 0-31 */
+-	{
++	if(chan_nr == uni_secondary_interrupt) {
++		/* secondary 0-31 */
+ 		status = avalanche_hw0_ecregs->exsr;
+-		for(i=0; i < 32; i++)
+-		{
+-			if (status & 1<<i)
+-			{
++		for (i=0; i < 32; i++) {
++			if (status & 1<<i) {
+ 				/* clear secondary interrupt */
+ 				avalanche_hw0_ecregs->excr = 1 << i;
+ 				break;
+@@ -242,15 +256,14 @@
+ 		/* clear the universal secondary interrupt */
+ 		avalanche_hw0_icregs->intcr1 = 1 << uni_secondary_interrupt;
+ 
+-	}
+-	else
++	} else {
+ 		irq = chan_nr;
++	}
+ 
+ 	do_IRQ(irq + ar7_irq_base, regs);
+-	return;
+ }
+ 
+-void avalanche_int_set(int channel, int line)
++static void avalanche_int_set(int channel, int line)
+ {
+ 	switch(channel)
+ 	{
+@@ -375,7 +388,7 @@
+ 			avalanche_hw0_chregs->cintnr39 = line;
+ 			break;
+ 		default:
+-			printk("Error: Unknown Avalanche interrupt channel\n");
++			printk(KERN_ERR "Error: Unknown Avalanche interrupt channel\n");
+ 	}
+ 
+ 	line_to_channel[line] = channel; /* Suraj check */
+@@ -390,38 +403,348 @@
+ #define AVALANCHE_PACING_LOW_VAL   2
+ #define AVALANCHE_PACING_HIGH_VAL 63
+ 
+-int avalanche_request_pacing(int irq_nr, unsigned int blk_num,
++int avalanche_request_pacing(unsigned int irq_nr, unsigned int blk_num,
+                             unsigned int pace_value)
+ {
+-    unsigned int  blk_offset;
+-    unsigned long flags;
++	irq_desc_t *desc;
++	unsigned int  blk_offset;
++	unsigned long flags;
+ 
+-    if(irq_nr < MIPS_EXCEPTION_OFFSET &&
+-       irq_nr >= AVALANCHE_INT_END_PRIMARY)
+-        return (0);
++	if(irq_nr < MIPS_EXCEPTION_OFFSET &&
++	   irq_nr >= AVALANCHE_INT_END_PRIMARY)
++		return (0);
++
++	if (irq_nr >= NR_IRQS)
++		return -1;
++
++	if(blk_num > AVALANCHE_MAX_PACING_BLK)
++		return(-1);
++
++	if(pace_value > AVALANCHE_PACING_HIGH_VAL &&
++	   pace_value < AVALANCHE_PACING_LOW_VAL)
++		return(-1);
++
++	blk_offset = blk_num*8;
++	
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
++	
++	/* disable the interrupt pacing, if enabled previously */
++	avalanche_hw0_ipaceregs->ipacemax &= ~(0xff << blk_offset);
++	
++	/* clear the pacing map */
++	avalanche_hw0_ipaceregs->ipacemap &= ~(0xff << blk_offset);
++	
++	/* setup the new values */
++	avalanche_hw0_ipaceregs->ipacemap |= ((AVINTNUM(irq_nr))   << blk_offset);
++	avalanche_hw0_ipaceregs->ipacemax |= ((0x80 | pace_value)  << blk_offset);
++	
++	spin_unlock_irqrestore(&desc->lock, flags);
++
++	return(0);
++}
++
++int avalanche_intr_polarity_set(unsigned int irq_nr, unsigned long polarity_val)
++{
++	irq_desc_t *desc;
++	unsigned long flags;
++	unsigned long chan_nr = 0;
+ 
+-    if(blk_num > AVALANCHE_MAX_PACING_BLK)
+-        return(-1);
++	dprintk("%s:%u %s(%u,%lu)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr,
++		polarity_val);
+ 
+-    if(pace_value > AVALANCHE_PACING_HIGH_VAL &&
+-       pace_value < AVALANCHE_PACING_LOW_VAL)
+-       return(-1);
++	if (irq_nr < MIPS_EXCEPTION_OFFSET ||
++	    irq_nr >= AVALANCHE_INT_END ||
++	    (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
++	     irq_nr < AVALANCHE_INT_END_SECONDARY)) {
++		printk(KERN_ALERT "whee, invalid irq_nr %u\n", irq_nr);
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++		printk
++		    (KERN_ERR "Not one of the primary or vlynq avalanche interrupts.\n");
++#else
++		printk(KERN_ERR "Not one of the primary avalanche interrupts\n");
++#endif
++		panic("IRQ, you lose...");
++		return (-1);
++	}
+ 
+-    blk_offset = blk_num*8;
++	if (polarity_val > 1) {
++		printk(KERN_ERR "Not a valid polarity value.\n");
++		return (-1);
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts
++	 * managed by the interrupt controller.
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			vlynq_interrupt_set_polarity(&vlynqDevice1,
++						     VLYNQ_REMOTE_DVC,
++						     irq_nr -
++						     AVALANCHE_INT_END_LOW_VLYNQ,
++						     polarity_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			vlynq_interrupt_set_polarity(&vlynqDevice0,
++						     VLYNQ_REMOTE_DVC,
++						     irq_nr -
++						     AVALANCHE_INTC_END,
++						     polarity_val);
++		}
++		goto ret_from_set_polarity;
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_interrupt_set_polarity == NULL) {
++			return 1;
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			(*p_vlynq_interrupt_set_polarity) (p_vlynqDevice1, 1,
++							   irq_nr -
++							   AVALANCHE_INT_END_LOW_VLYNQ,
++							   polarity_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			(*p_vlynq_interrupt_set_polarity) (p_vlynqDevice0, 1,
++							   irq_nr -
++							   AVALANCHE_INTC_END,
++							   polarity_val);
++		}
++		goto ret_from_set_polarity;
++	}
++#endif
+ 
+-    save_and_cli(flags);
++	chan_nr = line_to_channel[AVINTNUM(irq_nr)];
+ 
+-    /* disable the interrupt pacing, if enabled previously */
+-    avalanche_hw0_ipaceregs->ipacemax &= ~(0xff << blk_offset);
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
+ 
+-    /* clear the pacing map */
+-    avalanche_hw0_ipaceregs->ipacemap &= ~(0xff << blk_offset);
++	if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
++		/* primary interrupt #'s 0-31 */
++		if (polarity_val)
++			avalanche_hw0_icregs->intpolr1 |= (1 << chan_nr);
++		else
++			avalanche_hw0_icregs->intpolr1 &= ~(1 << chan_nr);
++	} else {
++		/* primary interrupt #'s 32-39 */
++		if (polarity_val)
++			avalanche_hw0_icregs->intpolr2 |=
++			    (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++		else
++			avalanche_hw0_icregs->intpolr2 &=
++			    ~(1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++	}
+ 
+-    /* setup the new values */
+-    avalanche_hw0_ipaceregs->ipacemap |= ((AVINTNUM(irq_nr))   << blk_offset);
+-    avalanche_hw0_ipaceregs->ipacemax |= ((0x80 | pace_value)  << blk_offset);
++	spin_unlock_irqrestore(&desc->lock, flags);
+ 
+-    restore_flags(flags);
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++      ret_from_set_polarity:
++#endif
+ 
+-    return(0);
++	return (0);
+ }
++
++int avalanche_intr_polarity_get(unsigned int irq_nr)
++{
++	irq_desc_t *desc;
++	unsigned long flags;
++	unsigned long chan_nr = 0;
++	int value;
++
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < MIPS_EXCEPTION_OFFSET ||
++	    irq_nr >= AVALANCHE_INT_END ||
++	    (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
++	     irq_nr < AVALANCHE_INT_END_SECONDARY)) {
++		printk(KERN_ALERT "whee, invalid irq_nr %u\n", irq_nr);
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++		printk
++		    (KERN_ERR "Not one of the primary or vlynq avalanche interrupts.\n");
++#else
++		printk(KERN_ERR "Not one of the primary avalanche interrupts\n");
++#endif
++		panic("IRQ, you lose...");
++		return (-1);
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			value =
++			    vlynq_interrupt_get_polarity(&vlynqDevice1,
++							 VLYNQ_REMOTE_DVC,
++							 irq_nr -
++							 AVALANCHE_INT_END_LOW_VLYNQ);
++		} else {
++			/* Vlynq interupts 0-31 */
++			value =
++			    vlynq_interrupt_get_polarity(&vlynqDevice0,
++							 VLYNQ_REMOTE_DVC,
++							 irq_nr -
++							 AVALANCHE_INTC_END);
++
++			goto ret_from_get_polarity;
++		}
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_interrupt_get_polarity == NULL) {
++			return 0;
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			value =
++			    (*p_vlynq_interrupt_get_polarity) (p_vlynqDevice1,
++							       1,
++							       irq_nr -
++							       AVALANCHE_INT_END_LOW_VLYNQ);
++		} else {
++			/* Vlynq interupts 0-31 */
++			value =
++			    (*p_vlynq_interrupt_get_polarity) (p_vlynqDevice0,
++							       1,
++							       irq_nr -
++							       AVALANCHE_INTC_END);
++		}
++		goto ret_from_get_polarity;
++	}
++#endif
++
++	chan_nr = line_to_channel[AVINTNUM(irq_nr)];
++
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
++
++	if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
++		/* primary interrupt #'s 0-31 */
++		value = avalanche_hw0_icregs->intpolr1;
++		value = (value >> chan_nr) & 0x1;
++	} else {
++		/* primary interrupt #'s 32-39 */
++		value = avalanche_hw0_icregs->intpolr2;
++		value =
++		    (value >> (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1)) & 0x1;
++	}
++
++	spin_unlock_irqrestore(&desc->lock, flags);
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++      ret_from_get_polarity:
++#endif
++
++	return (value);
++}
++
++/* Sets the trigger type: edge or level */
++int avalanche_intr_type_set(unsigned int irq_nr, unsigned long type_val)
++{
++	irq_desc_t *desc;
++	unsigned long flags;
++	unsigned long chan_nr = 0;
++
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < MIPS_EXCEPTION_OFFSET ||
++	    irq_nr >= AVALANCHE_INT_END ||
++	    (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
++	     irq_nr < AVALANCHE_INT_END_SECONDARY)) {
++		printk(KERN_ALERT "whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++		return (-1);
++	}
++
++	if (type_val > 1) {
++		printk(KERN_ERR "Not a valid polarity value.\n");
++		return (-1);
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after
++	 *  the interrupts managed by the interrupt controller.
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		/* Type values for VLYNQ are INTC are different. */
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			vlynq_interrupt_set_type(&vlynqDevice1,
++						 VLYNQ_REMOTE_DVC,
++						 irq_nr -
++						 AVALANCHE_INT_END_LOW_VLYNQ,
++						 !type_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			vlynq_interrupt_set_type(&vlynqDevice0,
++						 VLYNQ_REMOTE_DVC,
++						 irq_nr - AVALANCHE_INTC_END,
++						 !type_val);
++		}
++		goto ret_from_set_type;
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after
++	 *  the interrupts managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_interrupt_set_type == NULL) {
++			return 1;
++			/* Type values for VLYNQ are INTC are different. */
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			(*p_vlynq_interrupt_set_type) (p_vlynqDevice1, 1,
++						       irq_nr -
++						       AVALANCHE_INT_END_LOW_VLYNQ,
++						       !type_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			(*p_vlynq_interrupt_set_type) (p_vlynqDevice0, 1,
++						       irq_nr -
++						       AVALANCHE_INTC_END,
++						       !type_val);
++		}
++		goto ret_from_set_type;
++	}
++#endif
++
++	chan_nr = line_to_channel[AVINTNUM(irq_nr)];
++
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
++
++	if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
++		/* primary interrupt #'s 0-31 */
++		if (type_val) {
++			avalanche_hw0_icregs->inttypr1 |= (1 << chan_nr);
++		} else {
++			avalanche_hw0_icregs->inttypr1 &= ~(1 << chan_nr);
++		}
++	} else {
++		/* primary interrupt #'s 32-39 */
++		if (type_val) {
++			avalanche_hw0_icregs->inttypr2 |=
++			    (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++		} else {
++			avalanche_hw0_icregs->inttypr2 &=
++			    ~(1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++		}
++	}
++
++	spin_unlock_irqrestore(&desc->lock, flags);
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++      ret_from_set_type:
++#endif
++
++	return (0);
++}
++
++EXPORT_SYMBOL(avalanche_intr_type_set);
++EXPORT_SYMBOL(avalanche_intr_polarity_set);
+diff -urN linux-2.4.32/arch/mips/ar7/misc.c linux-2.4.32.new/arch/mips/ar7/misc.c
+--- linux-2.4.32/arch/mips/ar7/misc.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/misc.c	2005-12-27 21:44:16.000000000 +0100
+@@ -12,29 +12,28 @@
+ /*****************************************************************************
+  * Reset Control Module.
+  *****************************************************************************/
+-void avalanche_reset_ctrl(unsigned int module_reset_bit, 
++int avalanche_reset_ctrl(unsigned int module_reset_bit, 
+                           AVALANCHE_RESET_CTRL_T reset_ctrl)
+ {
+     volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+    
+     if(module_reset_bit >= 32 && module_reset_bit < 64)
+-        return;
++        return 0;
+ 
+     if(module_reset_bit >= 64)
+     {
+         if(p_remote_vlynq_dev_reset_ctrl) {
+-            p_remote_vlynq_dev_reset_ctrl(module_reset_bit - 64, reset_ctrl);
+-	    return;
++            return p_remote_vlynq_dev_reset_ctrl(module_reset_bit - 64, reset_ctrl);
+ 	}
+         else
+-            return;
++            return 1;
+     }
+     
+     if(reset_ctrl == OUT_OF_RESET)
+         *reset_reg |= 1 << module_reset_bit;
+     else
+         *reset_reg &= ~(1 << module_reset_bit);
+-    return;
++    return 0;
+ }
+ 
+ AVALANCHE_RESET_CTRL_T avalanche_get_reset_status(unsigned int module_reset_bit)
+diff -urN linux-2.4.32/arch/mips/config-shared.in linux-2.4.32.new/arch/mips/config-shared.in
+--- linux-2.4.32/arch/mips/config-shared.in	2006-05-19 19:04:47.000000000 +0200
++++ linux-2.4.32.new/arch/mips/config-shared.in	2006-04-28 19:05:46.000000000 +0200
+@@ -218,6 +218,7 @@
+    fi
+    define_bool CONFIG_MIPS_RTC y
+ fi
++dep_bool 'Support for Sinus 154 boards  (EXPERIMENTAL)' CONFIG_MIPS_SINUS154 $CONFIG_AR7 $CONFIG_EXPERIMENTAL
+ bool 'Support for SNI RM200 PCI' CONFIG_SNI_RM200_PCI
+ bool 'Support for TANBAC TB0226 (Mbase)' CONFIG_TANBAC_TB0226
+ bool 'Support for TANBAC TB0229 (VR4131DIMM)' CONFIG_TANBAC_TB0229
+@@ -1070,6 +1071,11 @@
+    dep_bool 'Compile for Corelis Debugger' CONFIG_SB1XXX_CORELIS $CONFIG_DEBUG_INFO
+ fi
+ bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
++bool 'Kernel debugging' CONFIG_DEBUG_KERNEL
++if [ "$CONFIG_DEBUG_KERNEL" != "n" ]; then
++bool '  Compile the kernel with frame pointers' CONFIG_FRAME_POINTER
++bool '  Remote GDB kernel debugging' CONFIG_REMOTE_DEBUG
++fi
+ if [ "$CONFIG_SMP" != "y" ]; then
+    bool 'Run uncached' CONFIG_MIPS_UNCACHED
+ else
+diff -urN linux-2.4.32/arch/mips/kernel/head.S linux-2.4.32.new/arch/mips/kernel/head.S
+--- linux-2.4.32/arch/mips/kernel/head.S	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/kernel/head.S	2005-12-27 21:44:16.000000000 +0100
+@@ -33,7 +33,16 @@
+ 		 * Reserved space for exception handlers.
+ 		 * Necessary for machines which link their kernels at KSEG0.
+ 		 */
++#if defined(CONFIG_MIPS_SINUS154)
++		/*
++		 * The firmware loads the unzipped kernel at KSEG0
++		 * and starts it from the beginning of KSEG0, namely here.
++		 */
++		jal	kernel_entry
++		.align	10
++#else
+ 		.fill	0x400
++#endif
+ 
+ 		/* The following two symbols are used for kernel profiling. */
+ 		EXPORT(stext)
+diff -urN linux-2.4.32/arch/mips/kernel/setup.c linux-2.4.32.new/arch/mips/kernel/setup.c
+--- linux-2.4.32/arch/mips/kernel/setup.c	2006-05-19 19:48:58.000000000 +0200
++++ linux-2.4.32.new/arch/mips/kernel/setup.c	2006-05-18 21:18:18.000000000 +0200
+@@ -125,6 +125,18 @@
+ 	/* Determine which MIPS variant we are running on. */
+ 	cpu_probe();
+ 
++#if defined(CONFIG_MIPS_SINUS154)
++	printk(KERN_DEBUG "\n%s:%d\n", __FILE__, __LINE__);
++	printk(KERN_DEBUG "argc = %d\nargv = 0x%p\nenvp = 0x%p\nprom_vec = 0x%p\n",
++		argc, argv, envp, prom_vec);
++#endif
++
++	if (argc < 0 || argc > 10) {
++		argv = 0;
++		envp = 0;
++		prom_vec = 0;
++	}
++
+ 	prom_init(argc, argv, envp, prom_vec);
+ 
+ 	cpu_report();
+@@ -145,7 +157,7 @@
+ 	int x = boot_mem_map.nr_map;
+ 
+ 	if (x == BOOT_MEM_MAP_MAX) {
+-		printk("Ooops! Too many entries in the memory map!\n");
++		printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
+ 		return;
+ 	}
+ 
+@@ -302,11 +314,12 @@
+ 		max_low_pfn = MAXMEM_PFN;
+ #ifndef CONFIG_HIGHMEM
+ 		/* Maximum memory usable is what is directly addressable */
+-		printk(KERN_WARNING "Warning only %ldMB will be used.\n",
++		printk(KERN_WARNING "Warning only %ld MiB will be used.\n",
+ 		       MAXMEM>>20);
+ 		printk(KERN_WARNING "Use a HIGHMEM enabled kernel.\n");
+ #endif
+ 	}
++	printk(KERN_DEBUG "max_low_pfn = 0x%08lx\n", max_low_pfn);
+ 
+ #ifdef CONFIG_HIGHMEM
+ 	/*
+@@ -316,7 +329,7 @@
+ 	highstart_pfn = highend_pfn = max_pfn;
+ 	if (max_pfn > MAXMEM_PFN) {
+ 		highstart_pfn = MAXMEM_PFN;
+-		printk(KERN_NOTICE "%ldMB HIGHMEM available.\n",
++		printk(KERN_NOTICE "%ld MiB HIGHMEM available.\n",
+ 		       (highend_pfn - highstart_pfn) >> (20 - PAGE_SHIFT));
+ 	}
+ #endif
+@@ -391,11 +404,11 @@
+ 	initrd_below_start_ok = 1;
+ 	if (initrd_start) {
+ 		unsigned long initrd_size = ((unsigned char *)initrd_end) - ((unsigned char *)initrd_start);
+-		printk("Initial ramdisk at: 0x%p (%lu bytes)\n",
++		printk(KERN_NOTICE "Initial ramdisk at: 0x%p (%lu bytes)\n",
+ 		       (void *)initrd_start,
+ 		       initrd_size);
+ 		if (PHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
+-			printk("initrd extends beyond end of memory "
++			printk(KERN_ERR "initrd extends beyond end of memory "
+ 			       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
+ 			       (unsigned long) PHYSADDR(initrd_end),
+ 			       PFN_PHYS(max_low_pfn));
+@@ -425,6 +438,7 @@
+ 
+ 		start = boot_mem_map.map[i].addr;
+ 		end = boot_mem_map.map[i].addr + boot_mem_map.map[i].size - 1;
++		printk(KERN_NOTICE "start = 0x%08lx, end = 0x%08lx, maxmem = 0x%08lx\n", start, end, MAXMEM);
+ 		if (start >= MAXMEM)
+ 			continue;
+ 		if (end >= MAXMEM)
+@@ -700,6 +714,7 @@
+                 break;
+ #endif
+ #ifdef CONFIG_AR7
++	case MACH_GROUP_AR7:
+ 	case MACH_GROUP_UNKNOWN:
+ 		ar7_setup();
+ 		break;
+diff -urN linux-2.4.32/arch/mips/Makefile linux-2.4.32.new/arch/mips/Makefile
+--- linux-2.4.32/arch/mips/Makefile	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/arch/mips/Makefile	2006-04-28 19:06:22.000000000 +0200
+@@ -135,7 +135,9 @@
+ 		   -Wa,--trap
+ endif
+ ifdef CONFIG_CPU_MIPS32
+-GCCFLAGS	+= $(call set_gccflags,mips32,mips32,r4600,mips3,mips2) \
++#~ GCCFLAGS	+= $(call set_gccflags,mips32,mips32,r4600,mips3,mips2) \
++		   #~ -Wa,--trap
++GCCFLAGS	+= $(call set_gccflags,mips32r2,mips32r2,r4600,mips3,mips2) \
+ 		   -Wa,--trap
+ endif
+ ifdef CONFIG_CPU_MIPS64
+@@ -374,8 +376,12 @@
+ ifdef CONFIG_AR7
+ LIBS		+= arch/mips/ar7/ar7.o
+ SUBDIRS		+= arch/mips/ar7
++ifdef CONFIG_MIPS_SINUS154
++LOADADDR	+= 0x94000000
++else
+ LOADADDR	+= 0x94020000
+ endif
++endif
+ 
+ #
+ # DECstation family
+diff -urN linux-2.4.32/drivers/atm/Makefile linux-2.4.32.new/drivers/atm/Makefile
+--- linux-2.4.32/drivers/atm/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/atm/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -8,38 +8,15 @@
+ export-objs := uPD98402.o suni.o idt77105.o
+ 
+ obj-y := atmdev_init.o
++obj-m :=
+ 
+ obj-$(CONFIG_ATM_ENI) += eni.o suni.o
+ obj-$(CONFIG_ATM_ZATM) += zatm.o uPD98402.o
+ obj-$(CONFIG_ATM_NICSTAR) += nicstar.o
+ obj-$(CONFIG_ATM_IDT77252) += idt77252.o
+ 
+-ifeq ($(CONFIG_AR7),y)
+-
+ subdir-$(CONFIG_MIPS_SANGAM_ATM) += sangam_atm
+ 
+-EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
+-#EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP
+-
+-ifeq ($(ANNEX),B)
+-EXTRA_CFLAGS += -DANNEX_B -DB
+-else
+-ifeq ($(ANNEX),C)
+-EXTRA_CFLAGS += -DANNEX_C -DC
+-else
+-EXTRA_CFLAGS += -DANNEX_A -DP
+-endif
+-endif
+-
+-list-multi	:= tiatm.o
+-tiatm-objs	:= sangam_atm/tn7atm.o sangam_atm/tn7dsl.o sangam_atm/tn7sar.o \
+-	sangam_atm/dsl_hal_api.o sangam_atm/dsl_hal_support.o sangam_atm/cpsar.o \
+-	sangam_atm/aal5sar.o
+-
+-obj-$(CONFIG_MIPS_SANGAM_ATM) += sangam_atm/tiatm.o
+-
+-endif
+-
+ ifeq ($(CONFIG_ATM_NICSTAR_USE_SUNI),y)
+   obj-$(CONFIG_ATM_NICSTAR) += suni.o
+ endif
+diff -urN linux-2.4.32/drivers/atm/sangam_atm/Makefile linux-2.4.32.new/drivers/atm/sangam_atm/Makefile
+--- linux-2.4.32/drivers/atm/sangam_atm/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/atm/sangam_atm/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -3,14 +3,21 @@
+ # Makefile for the Linux network (CPMAC) device drivers.
+ #
+ 
+-
+ O_TARGET := tiatm.o
+-obj-$(CONFIG_MIPS_SANGAM_ATM) += tiatm.o
+-list-multi      := tiatm.o
+ 
+-tiatm-objs	:= tn7atm.o tn7dsl.o tn7sar.o dsl_hal_api.o dsl_hal_support.o cpsar.o aal5sar.o
++obj-y :=
++obj-m :=
++
++#~ list-multi := tiatm.o
+ 
+-EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
++tiatm-objs := tn7atm.o tn7dsl.o tn7sar.o
++tiatm-objs += dsl_hal_api.o dsl_hal_support.o
++tiatm-objs += cpsar.o aal5sar.o
++
++obj-$(CONFIG_MIPS_SANGAM_ATM) += tiatm.o
++
++EXTRA_CFLAGS += -DEL -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
++#EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP
+ 
+ ifeq ($(ANNEX),B)
+ EXTRA_CFLAGS += -DANNEX_B -DB
+@@ -22,14 +29,7 @@
+ endif
+ endif
+ 
+-
+ include $(TOPDIR)/Rules.make
+ 
+-tiatm.o:      $(tiatm-objs)
++tiatm.o: $(tiatm-objs)
+ 	$(LD) -r -o $@ $(tiatm-objs)
+-
+-#avalanche_cpmac.o:      $(avalanche_cpmac-objs)
+-#	$(LD) -r -o $@ $(avalanche_cpmac-objs)
+-
+-clean:
+-	rm -f core *.o *.a *.s
+diff -urN linux-2.4.32/drivers/atm/sangam_atm/tn7dsl.c linux-2.4.32.new/drivers/atm/sangam_atm/tn7dsl.c
+--- linux-2.4.32/drivers/atm/sangam_atm/tn7dsl.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/atm/sangam_atm/tn7dsl.c	2005-12-27 21:44:16.000000000 +0100
+@@ -496,7 +496,7 @@
+       ptr = kmalloc(size, GFP_KERNEL|GFP_DMA);
+     }
+   }
+-  printk("size=%d\n", size);
++  printk("%s:%u size = %u\n", __FILE__, __LINE__, size);
+   return ptr;
+ 
+ }
+diff -urN linux-2.4.32/drivers/char/avalanche_led/gpio.c linux-2.4.32.new/drivers/char/avalanche_led/gpio.c
+--- linux-2.4.32/drivers/char/avalanche_led/gpio.c	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/char/avalanche_led/gpio.c	2006-05-18 21:19:37.000000000 +0200
+@@ -1,3 +1,139 @@
++/*
++ * Todo:
++ * - missing calls (only needed for clean shutdown of driver):
++ *   remove_proc_entry(AR7_RESET_FILE, NULL)
++ *   remove_proc_entry(AR7_VERSION_FILE, NULL)
++# cat /proc/avalanche/led_cfg
++Module:adsl
++    Instance:0
++        State: 0
++            mode: LED OFF
++            gpio: 7
++            param1: 0
++            param2: 0
++        State: 1
++            mode: LED_FLASH
++            gpio: 7
++            on-time [ms]: 250
++            off-time [ms]: 250
++        State: 2
++            mode: LED_BLINK_CODE0
++            gpio: 7
++            on-time [ms]: 250
++            blink code: 2
++        State: 3
++            mode: LED_ON
++            gpio: 7
++            param1: 0
++            param2: 0
++Module:adsl
++    Instance:1
++        State: 0
++            mode: LED OFF
++            gpio: 7
++            param1: 0
++            param2: 0
++        State: 1
++            mode: LED_ON
++            gpio: 7
++            param1: 0
++            param2: 0
++        State: 2
++            mode: LED_FLASH
++            gpio: 7
++            on-time [ms]: 250
++            off-time [ms]: 250
++        State: 3
++            mode: LED_FLASH
++            gpio: 7
++            on-time [ms]: 1000
++            off-time [ms]: 1000
++Module:internet
++    Instance:0
++        State: 0
++            mode: LED OFF
++            gpio: 13
++            param1: 0
++            param2: 0
++        State: 1
++            mode: LED_ON
++            gpio: 13
++            param1: 0
++            param2: 0
++        State: 2
++            mode: LED_FLASH
++            gpio: 13
++            on-time [ms]: 250
++            off-time [ms]: 250
++        State: 3
++            mode: LED_FLASH
++            gpio: 13
++            on-time [ms]: 1000
++            off-time [ms]: 1000
++Module:internet
++    Instance:1
++        State: 0
++            mode: LED OFF
++            gpio: 13
++            param1: 0
++            param2: 0
++        State: 1
++            mode: LED_ON
++            gpio: 13
++            param1: 0
++            param2: 0
++        State: 2
++            mode: LED_FLASH
++            gpio: 13
++            on-time [ms]: 250
++            off-time [ms]: 250
++        State: 3
++            mode: LED_FLASH
++            gpio: 13
++            on-time [ms]: 125
++            off-time [ms]: 125
++        State: 4
++            mode: LED_BLINK_CODE0
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 1
++        State: 5
++            mode: LED_BLINK_CODE0
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 2
++        State: 6
++            mode: LED_BLINK_CODE0
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 3
++        State: 7
++            mode: LED_BLINK_CODE1
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 1
++        State: 8
++            mode: LED_BLINK_CODE1
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 2
++        State: 9
++            mode: LED_BLINK_CODE1
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 3
++        State: 10
++            mode: LED_BLINK_CODE2
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 1
++        State: 11
++            mode: LED_BLINK_CODE2
++            gpio: 13
++            on-time [ms]: 250
++            blink code: 2
++# */
++
+ #include <linux/kernel.h>
+ #include <asm/uaccess.h>
+ #include <linux/spinlock.h>
+@@ -10,62 +146,64 @@
+ #include <asm/ar7/tnetd73xx_misc.h>
+ #include <asm/ar7/ledapp.h>
+ 
++#include "led.h"
++
+ #define TRUE 1
+ #define FALSE 0
+ 
+ #if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+ 
++#define AR7_PROC_DIRECTORY "led_mod"
+ #define AR7_RESET_FILE "led_mod/ar7reset"
+ #define AR7_VERSION_FILE "led_mod/hardware_version"
+ #define AR7_RESET_GPIO 11
+ #define RESET_POLL_TIME 1
+ #define RESET_HOLD_TIME 4
+-#define NO_OF_LEDS	
+ 
+ static struct proc_dir_entry *reset_file;
+-static int res_state = 0;
+-static int count;
+-static struct timer_list *pTimer = NULL;
++static struct proc_dir_entry *hardware_version_file;
++static int res_state;
++static struct timer_list *pTimer;
++
+ static ssize_t proc_read_reset_fops(struct file *filp,
+-                                    char *buf,size_t count , loff_t *offp);
++				    char *buf, size_t count, loff_t * offp);
+ 
+ static ssize_t proc_read_hwversion_fops(struct file *filp,
+-                                    char *buf,size_t count , loff_t *offp);
++					char *buf, size_t count, loff_t * offp);
+ 
+ struct file_operations reset_fops = {
+-                                     read: proc_read_reset_fops
+-                                   };
++      read:proc_read_reset_fops
++};
+ struct file_operations hardware_version_fops = {
+-                                     read: proc_read_hwversion_fops
+-                                   };
++      read:proc_read_hwversion_fops
++};
+ #endif
+ 
+-static spinlock_t	device_lock;
+-led_reg_t temp[15];
++static spinlock_t device_lock;
+ 
+-static void gpio_led_on( unsigned long param )
++static void gpio_led_on(unsigned long param)
+ {
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&device_lock, flags);
+ 
+-	tnetd73xx_gpio_out(param,FALSE);
++	tnetd73xx_gpio_out(param, FALSE);
+ 	spin_unlock_irqrestore(&device_lock, flags);
+ }
+ 
+-static void gpio_led_off ( unsigned long param )
++static void gpio_led_off(unsigned long param)
+ {
+ 	unsigned int flags = 0x00;
+ 
+- 	spin_lock_irqsave(&device_lock, flags);
++	spin_lock_irqsave(&device_lock, flags);
+ 
+-	tnetd73xx_gpio_out(param,TRUE);
++	tnetd73xx_gpio_out(param, TRUE);
+ 	spin_unlock_irqrestore(&device_lock, flags);
+ }
+ 
+-static void gpio_led_init( unsigned long param)
++static void gpio_led_init(unsigned long param)
+ {
+-	tnetd73xx_gpio_ctrl(param,GPIO_PIN,GPIO_OUTPUT_PIN);
++	tnetd73xx_gpio_ctrl(param, GPIO_PIN, GPIO_OUTPUT_PIN);
+ }
+ 
+ static void board_gpio_reset(void)
+@@ -77,110 +215,101 @@
+ 
+ #if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+ 
+-static ssize_t proc_read_hwversion_fops(struct file *filp, char *buf, 
+-					size_t count, loff_t *offp)
++static ssize_t proc_read_hwversion_fops(struct file *filp, char *buf,
++					size_t count, loff_t * offp)
+ {
+ 	char line[8];
+-  	int len = 0;
+-  	if( *offp != 0 )
+-  		return 0;
+-
+-	len = sprintf(line,  "%d%d.%d%d%d%d\n", tnetd73xx_gpio_in(20),
+-			tnetd73xx_gpio_in(21), tnetd73xx_gpio_in(22),
+-			tnetd73xx_gpio_in(23), tnetd73xx_gpio_in(24),
+-		        tnetd73xx_gpio_in(25));
+-  	
++	int len = 0;
++	if (*offp != 0)
++		return 0;
++
++	len = sprintf(line, "%d%d.%d%d%d%d\n", tnetd73xx_gpio_in(20),
++		      tnetd73xx_gpio_in(21), tnetd73xx_gpio_in(22),
++		      tnetd73xx_gpio_in(23), tnetd73xx_gpio_in(24),
++		      tnetd73xx_gpio_in(25));
++
+ 	copy_to_user(buf, line, len);
+ 	*offp = len;
+ 	return len;
+-}	
++}
+ 
+ static ssize_t proc_read_reset_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				    char *buf, size_t count, loff_t * offp)
+ {
+-  char * pdata = NULL;
+-  char line[3];
+-  int len = 0;
+-  if( *offp != 0 )
+-  	return 0;
++	char *pdata = NULL;
++	char line[3];
++	int len = 0;
++	if (*offp != 0)
++		return 0;
+ 
+-  pdata = buf;
+-	len = sprintf(line,"%d\n", res_state );
++	pdata = buf;
++	len = sprintf(line, "%d\n", res_state);
+ //wwzh
+ //  res_state = 0;
+-  copy_to_user(buf,line,len );
++	copy_to_user(buf, line, len);
+ 	*offp = len;
+ 	return len;
+ }
+ 
+ static void reset_timer_func(unsigned long data)
+ {
+-//wwzh
+ #if 0
+-  	count = (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0) ? count + 1: 0;
+-        if( count >= RESET_HOLD_TIME/RESET_POLL_TIME )
+-#endif
++	static int count;
++	count = (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0) ? count + 1 : 0;
++	if (count >= RESET_HOLD_TIME / RESET_POLL_TIME)
++		res_state = 1;
++	else
++		res_state = 0;
++#else
+ 	if (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0)
+-    		res_state = 1;
++		res_state = 1;
+ 	else
+ 		res_state = 0;
+-	pTimer->expires = jiffies + HZ*RESET_POLL_TIME;
+-	add_timer (pTimer);
+-  return;
++#endif
++	pTimer->expires = jiffies + HZ * RESET_POLL_TIME;
++	add_timer(pTimer);
+ }
+ 
+ static void hardware_version_init(void)
+ {
+-   	static struct proc_dir_entry *hardware_version_file;
+-  	hardware_version_file = create_proc_entry(AR7_VERSION_FILE, 0777, NULL);
+-  	if(hardware_version_file == NULL)
+-   		 return;
+-  	
+-	hardware_version_file->owner = THIS_MODULE;
+-  	hardware_version_file->proc_fops = &hardware_version_fops;
+-
+-  	tnetd73xx_gpio_ctrl(20,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(21,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(22,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(23,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(24,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(25,GPIO_PIN,GPIO_INPUT_PIN);
+-	
+-	return;
++	hardware_version_file = create_proc_entry(AR7_VERSION_FILE, 0777, NULL);
++	if (hardware_version_file != NULL) {
++		hardware_version_file->owner = THIS_MODULE;
++		hardware_version_file->proc_fops = &hardware_version_fops;
++	}
++	tnetd73xx_gpio_ctrl(20, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(21, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(22, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(23, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(24, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(25, GPIO_PIN, GPIO_INPUT_PIN);
+ }
+ 
+ static void reset_init(void)
+ {
+-  /* Create board reset proc file */
+-  reset_file = create_proc_entry( AR7_RESET_FILE, 0777, NULL);
+-  if( reset_file == NULL)
+-    goto reset_file;
+-  reset_file->owner = THIS_MODULE;
+-  reset_file->proc_fops = &reset_fops;
+-
+-  /* Initialise GPIO 11 for input */
+-  tnetd73xx_gpio_ctrl(AR7_RESET_GPIO,GPIO_PIN,GPIO_INPUT_PIN);
+-
+-  /* Create a timer which fires every seconds */
+-  pTimer = kmalloc(sizeof(struct timer_list),GFP_KERNEL);
+-	init_timer( pTimer );
++	/* Create board reset proc file */
++	reset_file = create_proc_entry(AR7_RESET_FILE, 0777, NULL);
++	if (reset_file != NULL) {
++		reset_file->owner = THIS_MODULE;
++		reset_file->proc_fops = &reset_fops;
++	}
++
++	/* Initialise GPIO 11 for input */
++	tnetd73xx_gpio_ctrl(AR7_RESET_GPIO, GPIO_PIN, GPIO_INPUT_PIN);
++
++	/* Create a timer which fires every seconds */
++	pTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++	init_timer(pTimer);
+ 	pTimer->function = reset_timer_func;
+ 	pTimer->data = 0;
+-  /* Start the timer */
+-  reset_timer_func(0);
+-  return ;
+ 
+-  reset_file:
+-    remove_proc_entry("AR7_RESET_FILE",NULL);
+-	return;
++	/* Start the timer */
++	reset_timer_func(0);
+ }
+ #endif
+-/*************wwzh****************/
++
+ #if 1
+-extern unsigned int sys_mod_state;
+-extern unsigned int  wan_mod_state;
+-extern unsigned int wlan_mod_state;
+-void sys_led_init(void)
++static void sys_led_init(void)
+ {
+ 	tnetd73xx_gpio_ctrl(4, GPIO_PIN, GPIO_OUTPUT_PIN);
+ 	tnetd73xx_gpio_ctrl(5, GPIO_PIN, GPIO_OUTPUT_PIN);
+@@ -189,33 +318,30 @@
+ 	tnetd73xx_gpio_out(4, FALSE);
+ 	tnetd73xx_gpio_out(5, TRUE);
+ 	tnetd73xx_gpio_out(8, TRUE);
+-	
+ 
+ 	sys_mod_state = 2;
+-
+ }
+-void wan_led_init(void)
++
++static void wan_led_init(void)
+ {
+-	
+ 	tnetd73xx_gpio_ctrl(2, GPIO_PIN, GPIO_OUTPUT_PIN);
+ 	tnetd73xx_gpio_ctrl(3, GPIO_PIN, GPIO_OUTPUT_PIN);
+-	
++
+ 	tnetd73xx_gpio_out(2, FALSE);
+ 	tnetd73xx_gpio_out(3, FALSE);
+ 
+ 	wan_mod_state = 1;
+ }
+-//wwzh wireless
+-#if 0
+-void wlan_led_init(void)
++
++#if defined(CONFIG_AR7_VLYNQ)
++static void wlan_led_init(void)
+ {
+-	//unsigned long i = 0;	
+ 	tnetd73xx_gpio_ctrl(12, GPIO_PIN, GPIO_OUTPUT_PIN);
+ 	tnetd73xx_gpio_ctrl(13, GPIO_PIN, GPIO_OUTPUT_PIN);
+-	
++
+ 	tnetd73xx_gpio_out(12, FALSE);
+ 	tnetd73xx_gpio_out(13, TRUE);
+-	//for (i = 0; i < 0x20000000; i++);
++
+ 	wlan_mod_state = 1;
+ }
+ #endif
+@@ -225,158 +351,200 @@
+ 
+ void board_gpio_init(void)
+ {
++	printk(KERN_DEBUG "%s:%u %s\n", __FILE__, __LINE__, __FUNCTION__);
+ 
+ 	board_gpio_reset();
+-/**************wwzh*************/
+ 	sys_led_init();
+ 	wan_led_init();
++#if defined(CONFIG_AR7_VLYNQ)
++	wlan_led_init();
++#endif
+ 
+-	//junzhao 2004.3.15
+-	hardware_version_init();
+-	
+-	//wlan_led_init();
++	proc_mkdir(AR7_PROC_DIRECTORY, NULL);
+ 
+-  	/* Register Device MAX_LED_ID + 1 for reset to factory default */
+-	 temp[0].param = 0;
+- 	 temp[0].init = reset_init;
+-  	 temp[0].onfunc = 0;
+- 	 temp[0].offfunc = 0;
+-	 register_led_drv( MAX_LED_ID + 1 , &temp[0]);
+-//wwzh for wireless led  
+-#if 1
+-  /* Register led 12 WiFi 6 */
+-  temp[1].param = 6;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-  register_led_drv( 12 , &temp[1]);
++	hardware_version_init();
+ 
++	/* Register Device MAX_LED_ID for reset to factory default */
++	{
++		static led_reg_t info;
++		info.param = 0;
++		info.init = reset_init;
++		info.onfunc = 0;
++		info.offfunc = 0;
++		register_led_drv(MAX_LED_ID, &info);
++	}
++
++#if defined(CONFIG_MIPS_SINUS154)
++	/* Register led 5 Green PPPOE GPIO 13 */
++	{
++		static led_reg_t info;
++		info.param = 13;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(5, &info);
++	}
++
++	/* Register led 12 WiFi 6 */
++	{
++		static led_reg_t info;
++		info.param = 6;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(12, &info);
++	}
+ #endif
+ 
+ #if 0
+ /**************end ************/
+ #if defined(CONFIG_AR5D01)
+-  /* Register led 1 GPIO0 */
+-  temp[0].param = GPIO_0;
+-  temp[0].init = gpio_led_init;
+-  temp[0].onfunc = gpio_led_on;
+-  temp[0].offfunc = gpio_led_off;
+-	register_led_drv( 1 , &temp[0]);
+-
+-  /* Register led 2 EINT1 */
+-  temp[1].param = EINT_1;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-	register_led_drv( 2 , &temp[1]);
+-
+-  /* Register led 5 EINT1 */
+-  temp[2].param = GPIO_1;
+-  temp[2].init = gpio_led_init;
+-  temp[2].onfunc = gpio_led_on;
+-  temp[2].offfunc = gpio_led_off;
+-	register_led_drv( 5 , &temp[2]);
++	/* Register led 1 GPIO0 */
++	{
++		static led_reg_t info;
++		info.param = GPIO_0;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(1, &info);
++	}
++
++	/* Register led 2 EINT1 */
++	{
++		static led_reg_t info;
++		info.param = EINT_1;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(2, &info);
++	}
++
++	/* Register led 5 EINT1 */
++	{
++		static led_reg_t info;
++		info.param = GPIO_1;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(5, &info);
++	}
+ #endif
+ 
+ #if defined(CONFIG_AR5W01)
+-  /* Register led 5 GPIO_1 */
+-  temp[0].param = GPIO_1;
+-  temp[0].init = gpio_led_init;
+-  temp[0].onfunc = gpio_led_on;
+-  temp[0].offfunc = gpio_led_off;
+-	register_led_drv( 5 , &temp[0]);
+-
+-  /* Register led 7 GPIO_0 */
+-  temp[1].param = GPIO_0;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-	register_led_drv( 7 , &temp[1]);
++	/* Register led 5 GPIO_1 */
++	{
++		static led_reg_t info;
++		info.param = GPIO_1;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(5, &info);
++	}
++
++	/* Register led 7 GPIO_0 */
++	{
++		static led_reg_t info;
++		info.param = GPIO_0;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(7, &info);
++	}
+ #endif
+ 
+-//wwzh #if defined(CONFIG_AR7RD)
+ #if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+-  /* Register led 5 Green PPPOE GPIO 13 */
+-  temp[0].param = 13;
+-  temp[0].init = gpio_led_init;
+-  temp[0].onfunc = gpio_led_on;
+-  temp[0].offfunc = gpio_led_off;
+-	register_led_drv( 5 , &temp[0]);
+-
+-  /* Register led 7 Green USB GPIO 12 */
+-  temp[1].param = 12;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-	register_led_drv( 7 , &temp[1]);
+-
+-  /* Register Device MAX_LED_ID + 1 for reset to factory default */
+-  temp[2].param = 0;
+-  temp[2].init = reset_init;
+-  temp[2].onfunc = 0;
+-  temp[2].offfunc = 0;
+-	register_led_drv( MAX_LED_ID + 1 , &temp[2]);
+-
+-  /* Register led 8 RED DSL GPIO 10 */
+-  temp[3].param = 10;
+-  temp[3].init = gpio_led_init;
+-  temp[3].onfunc = gpio_led_on;
+-  temp[3].offfunc = gpio_led_off;
+-	register_led_drv( 8 , &temp[3]);
+-
+-  /* Register led 9 RED PPPoE down GPIO 9 */
+-  temp[4].param = 9;
+-  temp[4].init = gpio_led_init;
+-  temp[4].onfunc = gpio_led_on;
+-  temp[4].offfunc = gpio_led_off;
+-	register_led_drv( 9 , &temp[4]);
+-
+-  /* Register led 10 DSL down GPIO 8 */
+-  temp[5].param = 8;
+-  temp[5].init = gpio_led_init;
+-  temp[5].onfunc = gpio_led_on;
+-  temp[5].offfunc = gpio_led_off;
+-	register_led_drv( 10 , &temp[5]);
+-
+-  /* Register led 11 Power GPIO 7 */
+-  temp[6].param = 7;
+-  temp[6].init = gpio_led_init;
+-  temp[6].onfunc = gpio_led_on;
+-  temp[6].offfunc = gpio_led_off;
+-	register_led_drv( 11 , &temp[6]);
+-
+-  /* Register led 12 WiFi 6 */
+-  temp[7].param = 6;
+-  temp[7].init = gpio_led_init;
+-  temp[7].onfunc = gpio_led_on;
+-  temp[7].offfunc = gpio_led_off;
+-	register_led_drv( 12 , &temp[7]);
+-
+-  /* Register led 13 ELINK(AA1313) GPIO 15 */
+-  temp[8].param = 15;
+-  temp[8].init = gpio_led_init;
+-  temp[8].onfunc = gpio_led_on;
+-  temp[8].offfunc = gpio_led_off;
+-	register_led_drv( 13 , &temp[8]);
+-
+-  /* Register led 14 EACT(Y13) GPIO 16 */
+-  temp[9].param = 16;
+-  temp[9].init = gpio_led_init;
+-  temp[9].onfunc = gpio_led_on;
+-  temp[9].offfunc = gpio_led_off;
+-	register_led_drv( 14 , &temp[9]);
++	/* Register led 5 Green PPPOE GPIO 13 */
++	{
++		static led_reg_t info;
++		info.param = 13;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(5, &info);
++	}
++
++	/* Register led 7 Green USB GPIO 12 */
++	{
++		static led_reg_t info;
++		info.param = 12;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(7, &info);
++	}
++
++	/* Register led 8 RED DSL GPIO 10 */
++	{
++		static led_reg_t info;
++		info.param = 10;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(8, &info);
++	}
++
++	/* Register led 9 RED PPPoE down GPIO 9 */
++	{
++		static led_reg_t info;
++		info.param = 9;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(9, &info);
++	}
++
++	/* Register led 10 DSL down GPIO 8 */
++	{
++		static led_reg_t info;
++		info.param = 8;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(10, &info);
++	}
++
++	/* Register led 11 Power GPIO 7 */
++	{
++		static led_reg_t info;
++		info.param = 7;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(11, &info);
++	}
++
++	/* Register led 12 WiFi 6 */
++	{
++		static led_reg_t info;
++		info.param = 6;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(12, &info);
++	}
++
++	/* Register led 13 ELINK(AA1313) GPIO 15 */
++	{
++		static led_reg_t info;
++		info.param = 15;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(13, &info);
++	}
++
++	/* Register led 14 EACT(Y13) GPIO 16 */
++	{
++		static led_reg_t info;
++		info.param = 16;
++		info.init = gpio_led_init;
++		info.onfunc = gpio_led_on;
++		info.offfunc = gpio_led_off;
++		register_led_drv(14, &info);
++	}
+ 
+ #endif
+-/**************wwzh**************/
+-#endif
+-/**************end **************/
+-  return;
+-}
+-
+-
+-
+-
+-
+-
+-
++#endif				// 0
+ 
++	return;
++}
+diff -urN linux-2.4.32/drivers/char/avalanche_led/led.h linux-2.4.32.new/drivers/char/avalanche_led/led.h
+--- linux-2.4.32/drivers/char/avalanche_led/led.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/led.h	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,15 @@
++/* ledmod.c */
++extern unsigned int sys_mod_state;
++extern unsigned int wan_mod_state;
++extern unsigned int wlan_mod_state;
++void led_operation(int mod, int state);
++void register_led_drv(int device, led_reg_t * pInfo);
++
++/* gpio.c */
++void board_gpio_init(void);
++
++/* leds.c */
++void avalanche_leds_init(void);
++
++/* uartled.c */
++void uart_led_init(void);
+diff -urN linux-2.4.32/drivers/char/avalanche_led/ledmod.c linux-2.4.32.new/drivers/char/avalanche_led/ledmod.c
+--- linux-2.4.32/drivers/char/avalanche_led/ledmod.c	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/char/avalanche_led/ledmod.c	2006-05-18 20:09:59.000000000 +0200
+@@ -1,3 +1,10 @@
++/*
++ * Check:
++ * pTimer->data is unsigned long, pState is a pointer.
++ * What is the use of these assignments:
++ * led_arr[pState->led].pTimer->data = pState;
++ */
++
+ #include <linux/config.h>
+ #include <linux/init.h>
+ #include <linux/kernel.h>
+@@ -9,8 +16,11 @@
+ #include <linux/spinlock.h>
+ #include <asm/ar7/avalanche_regs.h>
+ #include <asm/ar7/ledapp.h>
++#include <asm/ar7/tnetd73xx_misc.h>	/* tnetd73xx_gpio_out */
+ #include <linux/module.h>
+ 
++#include "led.h"
++
+ #define LED_ON  		1
+ #define LED_OFF 		2
+ #define LED_BLINK   3
+@@ -19,189 +29,183 @@
+ #define LED_BLINK_UP   		5
+ #define LED_BLINK_DOWN   	6
+ 
+-extern void avalanche_leds_init(void);
++#if 1
++# define DPRINTK(format, args...) printk(KERN_DEBUG format, ## args)
++#else
++# define DPRINTK(format, args...) ((void)0)
++#endif
+ 
+ /***********wwzh**************/
+ unsigned int sys_mod_state;
+ unsigned int wan_mod_state;
+ unsigned int wlan_mod_state;
+ 
+-struct timer_list *pWanTimer = NULL;
+-struct timer_list *pWlanTimer = NULL;
++#if defined(CONFIG_AR7_VLYNQ) && 0 // never called with mod == 4
++static struct timer_list *pWanTimer;
++static struct timer_list *pWlanTimer;
++#endif
+ /***********end **************/
+ 
+-typedef struct state_entry{
+-  unsigned char mode;
+-  unsigned char led;
+-	void (*handler)(struct state_entry *pState);
+-  unsigned long param;
+-}state_entry_t;
+-
+-typedef struct mod_entry{
+-  state_entry_t *states[MAX_STATE_ID];
+-}mod_entry_t;
++typedef struct state_entry {
++	unsigned char mode;
++	unsigned char led;
++	void (*handler) (struct state_entry * pState);
++	unsigned long param;
++} state_entry_t;
++
++typedef struct mod_entry {
++	state_entry_t *states[MAX_STATE_ID];
++} mod_entry_t;
+ 
+ static mod_entry_t *modArr[MAX_MOD_ID];
+-static struct proc_dir_entry *led_proc_dir,*led_file;
++static struct proc_dir_entry *led_proc_dir, *led_file;
+ 
+ /* index of the array is the led number HARDWARE SPECIFIC*/
+-typedef struct led_data{
++typedef struct led_data {
+ 	led_reg_t *led;
+-  int				state;
++	int state;
+ 	struct timer_list *pTimer;
+ 	unsigned char timer_running;
+-  unsigned long param;
+-}led_data_t;
++	unsigned long param;
++} led_data_t;
+ 
+-led_data_t led_arr[MAX_LED_ID + 1];
++static led_data_t led_arr[MAX_LED_ID + 1];
+ /*!!! The last device is actually being used for ar7 reset to factory default */
+ 
++static spinlock_t config_lock;
+ 
+-static spinlock_t	config_lock;
+-
+-static void board_led_link_up( state_entry_t *pState );
+-static void board_led_link_down( state_entry_t *pState );
+-static void board_led_activity_on( state_entry_t *pState );
+-static void board_led_activity_off( state_entry_t *pState );
++static void board_led_link_up(state_entry_t * pState);
++static void board_led_link_down(state_entry_t * pState);
++static void board_led_activity_on(state_entry_t * pState);
++static void board_led_activity_off(state_entry_t * pState);
+ static void led_timer_func(unsigned long data);
+ 
+-extern void board_gpio_init(void);
+-extern void uart_led_init(void);
+-
+ static ssize_t proc_read_led_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp);
+-static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+-                                                      size_t count , loff_t *offp);
+-static int config_led( unsigned long y);
++				  char *buf, size_t count, loff_t * offp);
++static ssize_t proc_write_led_fops(struct file *filp, const char *buffer,
++				   size_t count, loff_t * offp);
++static int config_led(unsigned long y);
+ 
+ struct file_operations led_fops = {
+-                                     read: proc_read_led_fops,
+-                                     write: proc_write_led_fops,
+-                                   };
++      read:proc_read_led_fops,
++      write:proc_write_led_fops,
++};
+ 
+-static int led_atoi( char *name)
++static int led_atoi(char *name)
+ {
+ 	int val = 0;
+-  for(;;name++)
+-	{
+-		switch(*name)
+-		{
+-			case '0'...'9':
+-				val = val*10+(*name - '0');
+-				break;
+-			default:
+-				return val;
++	for (;; name++) {
++		switch (*name) {
++		case '0'...'9':
++			val = val * 10 + (*name - '0');
++			break;
++		default:
++			return val;
+ 		}
+ 	}
+ }
+ 
+ static int free_memory(void)
+ {
+-  int i, j;
++	int i, j;
+ 
+-  for( i = 0; i < MAX_MOD_ID ; i++)
+-	{
+-		if( modArr[i] != NULL )
+-		{
+-			for( j = 0; j < MAX_STATE_ID ; j++ )
+-			{
+-				if( modArr[i]->states[j] != NULL )
+-					kfree( modArr[i]->states[j]);
++	for (i = 0; i < MAX_MOD_ID; i++) {
++		if (modArr[i] != NULL) {
++			for (j = 0; j < MAX_STATE_ID; j++) {
++				if (modArr[i]->states[j] != NULL)
++					kfree(modArr[i]->states[j]);
+ 			}
+ 			kfree(modArr[i]);
+-      modArr[i] = NULL;
++			modArr[i] = NULL;
+ 		}
+ 	}
+-  return 0;
++	return 0;
+ }
+ 
+-static int led_on( state_entry_t *pState )
++static int led_on(state_entry_t * pState)
+ {
+-	if( led_arr[pState->led].led == NULL)
++	if (led_arr[pState->led].led == NULL)
+ 		return -1;
+-  led_arr[pState->led].led->onfunc( led_arr[pState->led].led->param);
+-  return 0;
++	led_arr[pState->led].led->onfunc(led_arr[pState->led].led->param);
++	return 0;
+ }
+ 
+-static int led_off( state_entry_t *pState )
++static int led_off(state_entry_t * pState)
+ {
+-	if( led_arr[pState->led].led == NULL)
++	if (led_arr[pState->led].led == NULL)
+ 		return -1;
+-  led_arr[pState->led].led->offfunc( led_arr[pState->led].led->param);
+-  return 0;
++	led_arr[pState->led].led->offfunc(led_arr[pState->led].led->param);
++	return 0;
+ }
+ 
+-static void board_led_link_up( state_entry_t *pState )
++static void board_led_link_up(state_entry_t * pState)
+ {
+-  led_arr[pState->led].state = LED_ON;
+-  if( led_arr[pState->led].timer_running == 0 )
+-  	led_on(pState);
+-  return;
++	led_arr[pState->led].state = LED_ON;
++	if (led_arr[pState->led].timer_running == 0)
++		led_on(pState);
++	return;
+ }
+ 
+-static void board_led_link_down( state_entry_t *pState )
++static void board_led_link_down(state_entry_t * pState)
+ {
+ 	led_arr[pState->led].state = LED_OFF;
+-  if( led_arr[pState->led].timer_running == 0 )
+-  	led_off(pState);
+-  return;
++	if (led_arr[pState->led].timer_running == 0)
++		led_off(pState);
++	return;
+ }
+ 
+-static void add_led_timer(state_entry_t *pState)
++static void add_led_timer(state_entry_t * pState)
+ {
+-	led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+-  led_arr[pState->led].param = pState->param;
+-  led_arr[pState->led].pTimer->data = pState;
+-	add_timer (led_arr[pState->led].pTimer);
++	led_arr[pState->led].pTimer->expires =
++	    jiffies + HZ * (pState->param) / 1000;
++	led_arr[pState->led].param = pState->param;
++	led_arr[pState->led].pTimer->data = pState;
++	add_timer(led_arr[pState->led].pTimer);
+ }
+ 
+-static void board_led_activity_on(state_entry_t *pState)
++static void board_led_activity_on(state_entry_t * pState)
+ {
+-  if(led_arr[pState->led].timer_running == 0)
+-	{
++	if (led_arr[pState->led].timer_running == 0) {
+ 		led_on(pState);
+ 		add_led_timer(pState);
+-	  led_arr[pState->led].timer_running = 1;
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-	}
+-	else if( led_arr[pState->led].timer_running > 0xF0)
+-	{
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-		led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+-  	led_arr[pState->led].param = pState->param;
+-  	led_arr[pState->led].pTimer->data = pState;
++		led_arr[pState->led].timer_running = 1;
++		led_arr[pState->led].state = LED_BLINK_UP;
++	} else if (led_arr[pState->led].timer_running > 0xF0) {
++		led_arr[pState->led].state = LED_BLINK_UP;
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (pState->param) / 1000;
++		led_arr[pState->led].param = pState->param;
++		led_arr[pState->led].pTimer->data = pState;
+ 	}
+ 	return;
+ }
+ 
+-static void board_led_activity_off(state_entry_t *pState)
++static void board_led_activity_off(state_entry_t * pState)
+ {
+-  if(led_arr[pState->led].timer_running == 0)
+-	{
++	if (led_arr[pState->led].timer_running == 0) {
+ 		led_off(pState);
+ 		add_led_timer(pState);
+-	  led_arr[pState->led].timer_running = 1;
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-	}
+-	else if( led_arr[pState->led].timer_running > 0xF0)
+-	{
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-		led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+-  	led_arr[pState->led].param = pState->param;
+-  	led_arr[pState->led].pTimer->data = pState;
++		led_arr[pState->led].timer_running = 1;
++		led_arr[pState->led].state = LED_BLINK_UP;
++	} else if (led_arr[pState->led].timer_running > 0xF0) {
++		led_arr[pState->led].state = LED_BLINK_UP;
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (pState->param) / 1000;
++		led_arr[pState->led].param = pState->param;
++		led_arr[pState->led].pTimer->data = pState;
+ 	}
+ 	return;
+ }
+ 
+-static void board_led_link_flash(state_entry_t *pState)
++static void board_led_link_flash(state_entry_t * pState)
+ {
+-  if(led_on(pState))
++	if (led_on(pState))
+ 		return;
+-  if(led_arr[pState->led].timer_running == 0)
++	if (led_arr[pState->led].timer_running == 0)
+ 		add_led_timer(pState);
+ 	else
+-    led_arr[pState->led].param = pState->param;
+-  led_arr[pState->led].timer_running = 0xFF;
++		led_arr[pState->led].param = pState->param;
++	led_arr[pState->led].timer_running = 0xFF;
+ 	led_arr[pState->led].state = LED_FLASH;
+ 	return;
+ }
+@@ -209,235 +213,237 @@
+ static void led_timer_func(unsigned long data)
+ {
+ 	state_entry_t *pState = NULL;
+-  mod_entry_t *pMod = NULL;
++	// mod_entry_t *pMod = NULL;
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+-  pState = (state_entry_t *)data;
++	pState = (state_entry_t *) data;
+ 
+-  if( led_arr[pState->led].state == LED_BLINK_DOWN )
+-	{
++	if (led_arr[pState->led].state == LED_BLINK_DOWN) {
+ 		led_arr[pState->led].timer_running = 0;
+-		if( pState->mode == 2 )
++		if (pState->mode == 2)
+ 			led_arr[pState->led].state = LED_OFF;
+ 		else
+ 			led_arr[pState->led].state = LED_ON;
+-	}
+-  else if( led_arr[pState->led].state == LED_BLINK_UP )
+-	{
+-    led_arr[pState->led].pTimer->expires = jiffies + HZ*(led_arr[pState->led].param)/1000;
+-  	led_arr[pState->led].pTimer->data = pState;
+-		add_timer (led_arr[pState->led].pTimer);
+-		if( pState->mode == 2 )
+-		{
+-  		led_off(pState);
++	} else if (led_arr[pState->led].state == LED_BLINK_UP) {
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (led_arr[pState->led].param) / 1000;
++		led_arr[pState->led].pTimer->data = pState;
++		add_timer(led_arr[pState->led].pTimer);
++		if (pState->mode == 2) {
++			led_off(pState);
+ 			led_arr[pState->led].state = LED_BLINK_DOWN;
+-		}
+-		else
+-		{
+-  		led_on(pState);
++		} else {
++			led_on(pState);
+ 			led_arr[pState->led].state = LED_BLINK_DOWN;
+ 		}
+ 		led_arr[pState->led].timer_running = 1;
+-	}
+-  else if( led_arr[pState->led].state == LED_FLASH )
+-	{
+-    led_arr[pState->led].pTimer->expires = jiffies + HZ*(led_arr[pState->led].param)/1000;
+-  	led_arr[pState->led].pTimer->data = pState;
+-		add_timer (led_arr[pState->led].pTimer);
+-
+-		if( led_arr[pState->led].timer_running == 0xFF )
+-		{
+-  		led_off(pState);
++	} else if (led_arr[pState->led].state == LED_FLASH) {
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (led_arr[pState->led].param) / 1000;
++		led_arr[pState->led].pTimer->data = pState;
++		add_timer(led_arr[pState->led].pTimer);
++
++		if (led_arr[pState->led].timer_running == 0xFF) {
++			led_off(pState);
+ 			led_arr[pState->led].timer_running--;
+-		}
+-		else
+-		{
+-  		led_on(pState);
++		} else {
++			led_on(pState);
+ 			led_arr[pState->led].timer_running++;
+ 		}
+ 		spin_unlock_irqrestore(&config_lock, flags);
+-    return;
+-	}
+-  else if(led_arr[pState->led].state == LED_OFF)
+-	{
+-  	led_off(pState);
+-    led_arr[pState->led].timer_running = 0;
+-	}
+-	else if( led_arr[pState->led].state == LED_ON )
+-	{
+-  	led_on(pState);
+-    led_arr[pState->led].timer_running = 0;
++		return;
++	} else if (led_arr[pState->led].state == LED_OFF) {
++		led_off(pState);
++		led_arr[pState->led].timer_running = 0;
++	} else if (led_arr[pState->led].state == LED_ON) {
++		led_on(pState);
++		led_arr[pState->led].timer_running = 0;
+ 	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+-  return;
++	return;
+ }
++
+ /************wwzh*****************/
+ #if 0
+ /************end *****************/
+ static ssize_t proc_read_led_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				  char *buf, size_t count, loff_t * offp)
+ {
+-  char * pdata = NULL;
+-  int i = 0, j = 0, len = 0, totallen = 0;
+-  char line[255];
+-
+-  if( *offp != 0 )
+-  	return 0;
+-
+-  pdata = buf;
+-  len += sprintf(line,"LEDS Registered for use are:");
+-  for( i = 0; i< MAX_LED_ID; i++)
+-		if( led_arr[i].led != NULL )
+-			len += sprintf(&line[len]," %d ", i );
+-  line[len++] = '\n';
+-
+-  copy_to_user(pdata, line,len );
+-  pdata += len;
+-  totallen += len;
+-  len = 0;
+-  len = sprintf(line,"USER MODULE INFORMATION:\n");
+-  copy_to_user(pdata, line,len );
+-  pdata += len;
+-  totallen += len;
+-  len = 0;
+-  for( i = 0; i< MAX_MOD_ID; i++)
+-	{
+-		if( modArr[i] != NULL )
+-		{
+-			len = sprintf(line,"  Module ID = %d \n" , i);
+-  		copy_to_user(pdata, line,len );
+-      pdata += len;
+-  		totallen += len;
+-  		len = 0;
+- 			for( j = 0; j < MAX_STATE_ID; j++)
+-			{
+-				if( modArr[i]->states[j] != NULL)
+-				{
+-					len = sprintf(line ,
+-                		"    State = %d , Led = %d," , j , modArr[i]->states[j]->led);
+-  				copy_to_user(pdata, line,len );
+-          pdata += len;
+-  				totallen += len;
+-
+-  				len = 0;
+-          switch( modArr[i]->states[j]->mode )
+-					{
+-						case 1:
+-									len = sprintf(line ," Mode = OFF\n");
+-									break;
+-						case 2:
+-									len = sprintf(line ," Mode = BLINK_ON , On Time(ms) = %d\n" ,
+-                                       (unsigned int)modArr[i]->states[j]->param);
+-									break;
+-						case 3:
+-									len = sprintf(line ," Mode = BLINK_OFF , Off Time(ms) = %d\n" ,
+-                                       (unsigned int)modArr[i]->states[j]->param);
+-									break;
+-						case 4:
+-									len = sprintf(line ," Mode = ON \n");
+-									break;
+-						case 5:
+-									len = sprintf(line ," Mode = FLASH , Time Period(ms) = %d\n" ,
+-                                       (unsigned int)modArr[i]->states[j]->param);
+-									break;
+-						default:
+-							break;
++	char *pdata = NULL;
++	int i = 0, j = 0, len = 0, totallen = 0;
++	char line[255];
++
++	if (*offp != 0)
++		return 0;
++
++	if (count < 4096) {
++		printk(KERN_WARNING
++			"%s might destroy user data (buffer size %u too small\n",
++		       __FUNCTION__, count);
++	}
++
++	pdata = buf;
++	len += sprintf(line, "LEDS Registered for use are:");
++	for (i = 0; i < MAX_LED_ID; i++)
++		if (led_arr[i].led != NULL)
++			len += sprintf(&line[len], " %d ", i);
++	line[len++] = '\n';
++
++	copy_to_user(pdata, line, len);
++	pdata += len;
++	totallen += len;
++	len = 0;
++	len = sprintf(line, "USER MODULE INFORMATION:\n");
++	copy_to_user(pdata, line, len);
++	pdata += len;
++	totallen += len;
++	len = 0;
++	for (i = 0; i < MAX_MOD_ID; i++) {
++		if (modArr[i] != NULL) {
++			len = sprintf(line, "  Module ID = %d \n", i);
++			copy_to_user(pdata, line, len);
++			pdata += len;
++			totallen += len;
++			len = 0;
++			for (j = 0; j < MAX_STATE_ID; j++) {
++				if (modArr[i]->states[j] != NULL) {
++					len = sprintf(line,
++						      "    State = %d , Led = %d,",
++						      j,
++						      modArr[i]->states[j]->
++						      led);
++					copy_to_user(pdata, line, len);
++					pdata += len;
++					totallen += len;
++
++					len = 0;
++					switch (modArr[i]->states[j]->mode) {
++					case 1:
++						len =
++						    sprintf(line,
++							    " Mode = OFF\n");
++						break;
++					case 2:
++						len =
++						    sprintf(line,
++							    " Mode = BLINK_ON , On Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 3:
++						len =
++						    sprintf(line,
++							    " Mode = BLINK_OFF , Off Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 4:
++						len =
++						    sprintf(line,
++							    " Mode = ON \n");
++						break;
++					case 5:
++						len =
++						    sprintf(line,
++							    " Mode = FLASH , Time Period(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					default:
++						len =
++						    sprintf(line, "Mode = %u\n",
++							    modArr[i]->
++							    states[j]->mode);
++						break;
+ 
+ 					}
+-  				copy_to_user(pdata, line,len );
+-          pdata += len;
+-  				totallen += len;
++					copy_to_user(pdata, line, len);
++					pdata += len;
++					totallen += len;
+ 
+-  				len = 0;
++					len = 0;
+ 				}
+ 			}
+ 		}
+ 	}
+-  /* Return with configuration information for LEDs */
++	/* Return with configuration information for LEDs */
+ 	*offp = totallen;
+ 	return totallen;
+ }
+-static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+-                                                      size_t count , loff_t *offp)
++static ssize_t proc_write_led_fops(struct file *filp, const char *buffer,
++				   size_t count, loff_t * offp)
+ {
+-  char *pdata = NULL, *ptemp = NULL;
+-  char line[10],temp[10];
+-  int i = 0;
+-  int mod = 0xFFFF , state = 0xFFFF;
+-  int flag = 0;
+-
+-  /* Check if this write is for configuring stuff */
+-  if( *(int *)(buffer) == 0xFFEEDDCC )
+-	{
+-    printk("<1>proc write:Calling Configuration\n");
+-		config_led((unsigned long)(buffer + sizeof(int)) );
++	char *pdata = NULL, *ptemp = NULL;
++	char line[10], temp[10];
++	int i = 0;
++	int mod = 0xFFFF, state = 0xFFFF;
++	int flag = 0;
++
++	/* Check if this write is for configuring stuff */
++	if (*(int *)(buffer) == 0xFFEEDDCC) {
++		printk(KERN_ALERT "proc write:Calling Configuration\n");
++		config_led((unsigned long)(buffer + sizeof(int)));
+ 		return count;
+ 	}
+ 
+-  if( count >= 10)
+-	{
+-    printk("<1>proc write:Input too long,max length = %d\n",10);
+-    return count;
+-	}
+-  memset( temp, 0x00 , 10);
+-  memset( line, 0x00 , 10);
+-  copy_from_user(line,buffer,count);
+-  line[count] = 0x00;
+-  pdata = line;
+-  ptemp = temp;
+-  while( flag == 0)
+-  {
+-		if( i > 10 )
+-			break;
+-		if( ((*pdata) >= '0' ) && ((*pdata) <= '9') )
+-		{	
+-			*ptemp = *pdata ;
++	if (count >= 10) {
++		printk(KERN_ALERT "proc write:Input too long,max length = %d\n", 10);
++		return count;
++	}
++	memset(temp, 0x00, 10);
++	memset(line, 0x00, 10);
++	copy_from_user(line, buffer, count);
++	line[count] = 0x00;
++	pdata = line;
++	ptemp = temp;
++	while (flag == 0) {
++		if (i > 10)
++			break;
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
++			*ptemp = *pdata;
+ 			ptemp++;
+-		}	
+-		else if( (*pdata) == ',' )
+-		{
+-      *ptemp = 0x00;
++		} else if ((*pdata) == ',') {
++			*ptemp = 0x00;
+ 			flag = 1;
+-		}	
++		}
+ 		pdata++;
+ 		i++;
+-  };
+-	if( flag == 1)
+-  	mod = led_atoi( temp);
++	};
++	if (flag == 1)
++		mod = led_atoi(temp);
+ 	else
+ 		return count;
+-		
+-  ptemp = temp;
+-  *ptemp = 0x00;
+-  flag = 0;
+-  while( flag == 0)
+-  {
+-		if( i > 10 )
+-			break;
+-		if( ((*pdata) >= '0' ) && ((*pdata) <= '9') )
+-		{	
+-			*ptemp = *pdata ;
++
++	ptemp = temp;
++	*ptemp = 0x00;
++	flag = 0;
++	while (flag == 0) {
++		if (i > 10)
++			break;
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
++			*ptemp = *pdata;
+ 			ptemp++;
+-		}	
+-		else if( (*pdata) == 0x00 )
+-		{
+-      *ptemp = 0x00;
++		} else if ((*pdata) == 0x00) {
++			*ptemp = 0x00;
+ 			flag = 1;
+-		}	
++		}
+ 		pdata++;
+-    i++;
+-  };
+-	if( flag == 1)
+-  	state = led_atoi( temp);
++		i++;
++	};
++	if (flag == 1)
++		state = led_atoi(temp);
+ 	else
+ 		return count;
+-  if( (mod == 0xFFFF) || (state == 0xFFFF))
++	if ((mod == 0xFFFF) || (state == 0xFFFF))
+ 		return count;
+-  else
+-    led_operation( mod , state );
+-  return count;
++	else
++		led_operation(mod, state);
++	return count;
+ }
+ 
+ /************wwzh*******************/
+@@ -446,47 +452,41 @@
+ #define TRUE 1
+ #define FALSE 0
+ #define FLICK_TIME (HZ*100/1000)
+-static unsigned int wan_txrx_state = 0;
+-static unsigned int wlan_txrx_state = 0;
++#if defined(CONFIG_AR7_VLYNQ) && 0 // never called with mod == 4
++static unsigned int wan_txrx_state;
++static unsigned int wlan_txrx_state;
++#endif
+ 
+-void led_operation( int mod , int state)
++void led_operation(int mod, int state)
+ {
+-
+ 	unsigned int flags;
+ 
++	printk(KERN_DEBUG "%s:%u %s(%d,%d)\n", __FILE__, __LINE__, __FUNCTION__, mod, state);
++
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+-	if( (mod >= MAX_MOD_ID) || ( state >= MAX_STATE_ID) )
+-	{
+-	  spin_unlock_irqrestore(&config_lock, flags);
+-		return;
++	if ((mod >= MAX_MOD_ID) || (state >= MAX_STATE_ID)) {
++		printk(KERN_ERR "%s:%u %s illegal module or state\n", __FILE__, __LINE__, __FUNCTION__);
++	} else if (modArr[mod] == NULL) {
++		printk(KERN_ERR "%s:%u %s unknown module\n", __FILE__, __LINE__, __FUNCTION__);
++	} else if (modArr[mod]->states[state] == NULL) {
++		printk(KERN_ERR "%s:%u %s unknown state\n", __FILE__, __LINE__, __FUNCTION__);
++	} else {
++		/* Call the function handler  */
++		modArr[mod]->states[state]->handler(modArr[mod]->states[state]);
+ 	}
+- 	if ( modArr[mod] == NULL )
+-	{
+-	  spin_unlock_irqrestore(&config_lock, flags);
+-		return;
+-	}
+-	if( modArr[mod]->states[state] == NULL )
+-	{
+-	  spin_unlock_irqrestore(&config_lock, flags);
+-		return;
+-	}
+-  /* Call the function handler  */
+-  modArr[mod]->states[state]->handler(modArr[mod]->states[state]);
+ 
+ 	spin_unlock_irqrestore(&config_lock, flags);
+ }
+ 
++#if defined(CONFIG_AR7_VLYNQ) && 0 // never called with mod == 4
+ static void wan_led_func(unsigned long data)
+ {
+-	if (wan_txrx_state == 0)
+-	{
++	if (wan_txrx_state == 0) {
+ 		tnetd73xx_gpio_out(2, TRUE);
+ 		tnetd73xx_gpio_out(3, FALSE);
+ 		wan_txrx_state = 1;
+-	}
+-	else
+-	{
++	} else {
+ 		tnetd73xx_gpio_out(2, FALSE);
+ 		tnetd73xx_gpio_out(3, FALSE);
+ 		wan_txrx_state = 0;
+@@ -494,338 +494,356 @@
+ 	pWanTimer->expires = jiffies + FLICK_TIME;
+ 	add_timer(pWanTimer);
+ }
++#endif
++
+ //wwzh for wireless
+-#if 0
++#if defined(CONFIG_AR7_VLYNQ) && 0 // never called with mod == 4
+ static void wlan_led_func(unsigned long data)
+ {
+-	if (wlan_txrx_state == 0)
+-	{
++	if (wlan_txrx_state == 0) {
+ 		tnetd73xx_gpio_out(12, TRUE);
+ 		tnetd73xx_gpio_out(13, FALSE);
+ 		wlan_txrx_state = 1;
+-	}
+-	else
+-	{
++	} else {
+ 		tnetd73xx_gpio_out(12, FALSE);
+ 		tnetd73xx_gpio_out(13, FALSE);
+ 		wlan_txrx_state = 0;
+-		
++
+ 	}
+ 	pWlanTimer->expires = jiffies + FLICK_TIME;
+ 	add_timer(pWlanTimer);
+ }
+ #endif
+ 
+-void led_active(int mod, int state)
++#if 0 // unused code
++static void led_active(int mod, int state)
+ {
+ 	unsigned int flags = 0;
+ 
+-//printk("mod = %d state = %d\n", mod, state);
++//printk(KERN_DEBUG "mod = %d state = %d\n", mod, state);
+ 	spin_lock_irqsave(&config_lock, flags);
+-	if ((mod >= 5) || (state >= 5))
+-	{
++	if ((mod >= 5) || (state >= 5)) {
+ 		spin_unlock_irqrestore(&config_lock, flags);
+ 		return;
+ 	}
+-	
+-	switch (mod)
+-	{
+-		case 2: /*system led */
+-			sys_mod_state = state;
+-			switch (state)
+-			{
+-				case 1:	
+-					break;
+-				case 2:  /*sys led flashing green */
+-					tnetd73xx_gpio_out(4, FALSE);
+-					tnetd73xx_gpio_out(5, TRUE);
+-					tnetd73xx_gpio_out(8, TRUE);
+-					break;
+-				case 3: /*sys led solid green */
+-					tnetd73xx_gpio_out(4, TRUE);
+-					tnetd73xx_gpio_out(5, TRUE);
+-					tnetd73xx_gpio_out(8, TRUE);
+-					
+-					break;
+-				case 4: /*sys fail red */
+-					tnetd73xx_gpio_out(4, TRUE);
+-					tnetd73xx_gpio_out(5, FALSE);
+-					tnetd73xx_gpio_out(8, FALSE);
+-					break;
+-				default:
+-					break;
++
++	switch (mod) {
++	case 2:		/*system led */
++		sys_mod_state = state;
++		switch (state) {
++		case 1:
++			break;
++		case 2:	/*sys led flashing green */
++			tnetd73xx_gpio_out(4, FALSE);
++			tnetd73xx_gpio_out(5, TRUE);
++			tnetd73xx_gpio_out(8, TRUE);
++			break;
++		case 3:	/*sys led solid green */
++			tnetd73xx_gpio_out(4, TRUE);
++			tnetd73xx_gpio_out(5, TRUE);
++			tnetd73xx_gpio_out(8, TRUE);
++
++			break;
++		case 4:	/*sys fail red */
++			tnetd73xx_gpio_out(4, TRUE);
++			tnetd73xx_gpio_out(5, FALSE);
++			tnetd73xx_gpio_out(8, FALSE);
++			break;
++		default:
++			break;
++		}
++		break;
++	case 3:		/*wan led */
++		wan_mod_state = state;
++		switch (state) {
++		case 1:	/*no wan interface */
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
+ 			}
++			tnetd73xx_gpio_out(2, FALSE);
++			tnetd73xx_gpio_out(3, FALSE);
+ 			break;
+-		case 3: /*wan led */
+-			wan_mod_state = state;
+-			switch (state)
+-			{
+-				case 1: /*no wan interface*/
+-					if (pWanTimer)
+-					{
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(2, FALSE);
+-					tnetd73xx_gpio_out(3, FALSE);
+-					break;
+-				case 2: /*wan connected */
+-					if (pWanTimer)
+-					{
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(2, TRUE);
+-					tnetd73xx_gpio_out(3, FALSE);
+-					break;
+-				case 3: /*rx/tx activity */
+-					if (pWanTimer != NULL)
+-						break;	
+-				
+-					pWanTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+-					init_timer(pWanTimer);
+-					
+-					pWanTimer->function = wan_led_func;
+-					pWanTimer->data = 0;
+-					pWanTimer->expires = jiffies + FLICK_TIME;
+-					tnetd73xx_gpio_out(2, FALSE);
+-					tnetd73xx_gpio_out(3, FALSE);
+-					wan_txrx_state = 0;
+-					add_timer(pWanTimer);
+-
+-					break;
+-				case 4: /*no ipaddress */
+-					if (pWanTimer)
+-					{
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(2, FALSE);
+-					tnetd73xx_gpio_out(3, TRUE);
+-					break;
+-				default:
+-					if (pWanTimer)
+-					{	
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					break;
++		case 2:	/*wan connected */
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
+ 			}
++			tnetd73xx_gpio_out(2, TRUE);
++			tnetd73xx_gpio_out(3, FALSE);
+ 			break;
+-	//wwzh for wireless 
+-	#if 0
+-		case 4: /*wlan led */
+-			wlan_mod_state = state;
+-			switch (state)
+-			{
+-				case 1: /* wlan off */
+-					if (pWlanTimer)
+-					{
+-						del_timer(pWlanTimer);
+-						kfree(pWlanTimer);
+-						pWlanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(12, FALSE);
+-					tnetd73xx_gpio_out(13, FALSE);
+-					break;
+-				case 2: /* wlan ready */
+-					if (pWlanTimer)
+-					{
+-						del_timer(pWlanTimer);
+-						kfree(pWlanTimer);
+-						pWlanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(12, TRUE);
+-					tnetd73xx_gpio_out(13, FALSE);
+-					break;
+-				case 3: /* wlan rx/tx activity */
+-					if (pWlanTimer != NULL)
+-						break;
+-					
+-					pWlanTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+-					init_timer(pWlanTimer);
+-					
+-					pWlanTimer->function = wlan_led_func;
+-					pWlanTimer->data = 0;
+-					pWlanTimer->expires = jiffies + FLICK_TIME;
+-					tnetd73xx_gpio_out(12, FALSE);
+-					tnetd73xx_gpio_out(13, FALSE);
+-					wlan_txrx_state = 0;
+-					add_timer(pWlanTimer);
+-					
+-					break;
+-				default:
+-					if (pWlanTimer)
+-					{
+-						del_timer(pWlanTimer);
+-						kfree(pWlanTimer);
+-						pWlanTimer = NULL;
+-					}
+-					
+-					break;
++		case 3:	/*rx/tx activity */
++			if (pWanTimer != NULL)
++				break;
++
++			pWanTimer =
++			    kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++			init_timer(pWanTimer);
++
++			pWanTimer->function = wan_led_func;
++			pWanTimer->data = 0;
++			pWanTimer->expires = jiffies + FLICK_TIME;
++			tnetd73xx_gpio_out(2, FALSE);
++			tnetd73xx_gpio_out(3, FALSE);
++			wan_txrx_state = 0;
++			add_timer(pWanTimer);
++
++			break;
++		case 4:	/*no ipaddress */
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
+ 			}
++			tnetd73xx_gpio_out(2, FALSE);
++			tnetd73xx_gpio_out(3, TRUE);
++			break;
++		default:
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
++			}
++			break;
++		}
++		break;
++		//wwzh for wireless 
++#if defined(CONFIG_AR7_VLYNQ) && 0 // never called with mod == 4
++	case 4:		/*wlan led */
++		wlan_mod_state = state;
++		switch (state) {
++		case 1:	/* wlan off */
++			if (pWlanTimer) {
++				del_timer(pWlanTimer);
++				kfree(pWlanTimer);
++				pWlanTimer = NULL;
++			}
++			tnetd73xx_gpio_out(12, FALSE);
++			tnetd73xx_gpio_out(13, FALSE);
++			break;
++		case 2:	/* wlan ready */
++			if (pWlanTimer) {
++				del_timer(pWlanTimer);
++				kfree(pWlanTimer);
++				pWlanTimer = NULL;
++			}
++			tnetd73xx_gpio_out(12, TRUE);
++			tnetd73xx_gpio_out(13, FALSE);
++			break;
++		case 3:	/* wlan rx/tx activity */
++			if (pWlanTimer != NULL)
++				break;
++
++			pWlanTimer =
++			    kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++			init_timer(pWlanTimer);
++
++			pWlanTimer->function = wlan_led_func;
++			pWlanTimer->data = 0;
++			pWlanTimer->expires = jiffies + FLICK_TIME;
++			tnetd73xx_gpio_out(12, FALSE);
++			tnetd73xx_gpio_out(13, FALSE);
++			wlan_txrx_state = 0;
++			add_timer(pWlanTimer);
++
+ 			break;
+-	#endif //for wireless
+ 		default:
++			if (pWlanTimer) {
++				del_timer(pWlanTimer);
++				kfree(pWlanTimer);
++				pWlanTimer = NULL;
++			}
++
+ 			break;
++		}
++		break;
++#endif				//for wireless
++	default:
++		break;
+ 	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+ }
++#endif
++
+ static ssize_t proc_read_led_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				  char *buf, size_t count, loff_t * offp)
+ {
+-	char *pdata = NULL;
+-	int i = 0, j = 0, len = 0, totallen = 0;
++	char *pdata = buf;
++	int i, j, len, totallen = 0;
+ 	char line[255];
+-	
++
++	DPRINTK("%s:%u %s(...,%u,...)\n", __FILE__, __LINE__, __FUNCTION__,
++		count);
++
+ 	if (*offp != 0)
+ 		return 0;
+-	pdata = buf;
++
++	if (count < 4096) {
++		printk(KERN_WARNING
++			"%s might destroy user data (buffer size %u too small\n",
++		       __FUNCTION__, count);
++	}
++
+ 	len = sprintf(line, "USER MODULE INFORMATION:\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+-	
++
+ 	//*******add Module 1 , this Module is ADSL ********/
+-	for (i = 0; i < MAX_MOD_ID; i++)
+-	{
+-		if (modArr[i] != NULL)
+-		{
++	for (i = 0; i < MAX_MOD_ID; i++) {
++		if (modArr[i] != NULL) {
+ 			len = sprintf(line, " Module ID = %d\n", i);
+ 			copy_to_user(pdata, line, len);
+ 			pdata += len;
+ 			totallen += len;
+ 			len = 0;
+-			for(j = 0; j < MAX_STATE_ID; j++)
+-			{
+-				if (modArr[i]->states[j] != NULL)
+-				{
+-					len = sprintf(line, "State =%d, Led = %d,", j, modArr[i]->states[j]->led);
++			for (j = 0; j < MAX_STATE_ID; j++) {
++				if (modArr[i]->states[j] != NULL) {
++					len =
++					    sprintf(line,
++						    "State =%d, Led = %d,", j,
++						    modArr[i]->states[j]->led);
+ 					copy_to_user(pdata, line, len);
+ 					pdata += len;
+ 					totallen += len;
+ 					len = 0;
+-					switch(modArr[i]->states[j]->mode)
+-					{
+-					  case 1:
+-				            len = sprintf(line, "Mode = OFF\n");
+-					    break;
+-					  case 2:
+-					    len = sprintf(line, "Mode = BLINK_ON, On Time(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);	
+-					    break;
+-					  case 3:
+-					    len = sprintf(line, "Mode = BLINK_OFF, Off Time(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);
+-					    break;
+-					  case 4:
+-					    len = sprintf(line, "Mode = On\n");
+-					    break;
+-					  case 5:
+-					    len = sprintf(line, "Mode = FLASH, Time Period(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);
+-					    break;
+-					  default:
+-					    break;		
++					switch (modArr[i]->states[j]->mode) {
++					case 1:
++						len =
++						    sprintf(line,
++							    "Mode = OFF\n");
++						break;
++					case 2:
++						len =
++						    sprintf(line,
++							    "Mode = BLINK_ON, On Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 3:
++						len =
++						    sprintf(line,
++							    "Mode = BLINK_OFF, Off Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 4:
++						len =
++						    sprintf(line,
++							    "Mode = On\n");
++						break;
++					case 5:
++						len =
++						    sprintf(line,
++							    "Mode = FLASH, Time Period(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					default:
++						len =
++						    sprintf(line, "Mode = %u\n",
++							    modArr[i]->
++							    states[j]->mode);
++						break;
+ 					}
+ 					copy_to_user(pdata, line, len);
+ 					pdata += len;
+ 					totallen += len;
+ 					len = 0;
+ 				}
+-			} 
++			}
+ 		}
+ 
+ 	}
+ 
+-	len = sprintf(line, "Module ID = 2(system led)\n");
++	len = sprintf(line, "Module ID = 2 (system led)\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+ 	len = 0;
+-	switch(sys_mod_state)
+-	{
+-		case 1:
+-			len = sprintf(line, "State = OFF\n");
+-			break;
+-		case 2:	
+-			len = sprintf(line, "State = Booting\n");
+-			break;
+-		case 3:
+-			len = sprintf(line, "State = System Ready\n");
+-			break;
+-		case 4:
+-			len = sprintf(line, "State = System Failure\n");
+-			break;
+-		default:
+-			break;
++	switch (sys_mod_state) {
++	case 1:
++		len = sprintf(line, "State = OFF\n");
++		break;
++	case 2:
++		len = sprintf(line, "State = Booting\n");
++		break;
++	case 3:
++		len = sprintf(line, "State = System Ready\n");
++		break;
++	case 4:
++		len = sprintf(line, "State = System Failure\n");
++		break;
++	default:
++		len = sprintf(line, "State = %u\n", sys_mod_state);
++		break;
+ 	}
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+-	
+-	len = sprintf(line, "Module ID = 3(WAN led)\n");
++
++	len = sprintf(line, "Module ID = 3 (WAN led)\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+ 	len = 0;
+-	switch(wan_mod_state)
+-	{
+-		case 1:
+-			len = sprintf(line, "State = OFF\n");
+-			break;
+-		case 2:
+-			len = sprintf(line, "State = Wan Connected\n");
+-			break;
+-		case 3:
+-			len = sprintf(line, "State = Wan Tx/Rx Activity\n");
+-			break;
+-		case 4:
+-			len = sprintf(line, "State = Wan Connect Failure\n");
+-			break;
+-		default:
+-			break;
++	switch (wan_mod_state) {
++	case 1:
++		len = sprintf(line, "State = OFF\n");
++		break;
++	case 2:
++		len = sprintf(line, "State = Wan Connected\n");
++		break;
++	case 3:
++		len = sprintf(line, "State = Wan Tx/Rx Activity\n");
++		break;
++	case 4:
++		len = sprintf(line, "State = Wan Connect Failure\n");
++		break;
++	default:
++		len = sprintf(line, "State = %u\n", wan_mod_state);
++		break;
+ 	}
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+ 
+ //wwzh for wireless
+-#if 0
+-	len = sprintf(line, "Module ID = 4(WLAN led)\n");
++#if defined(CONFIG_AR7_VLYNQ)
++	len = sprintf(line, "Module ID = 4 (WLAN led)\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+ 	len = 0;
+-	switch(wlan_mod_state)
+-	{
+-		case 1:
+-			len = sprintf(line, "State = OFF\n");
+-			break;
+-		case 2:
+-			len = sprintf(line, "State = wlan Ready\n");
+-			break;
+-		case 3:
+-			len = sprintf(line, "State = wlan rx/tx activity\n");
+-			break;
+-		default:
+-			break; 
++	switch (wlan_mod_state) {
++	case 1:
++		len = sprintf(line, "State = OFF\n");
++		break;
++	case 2:
++		len = sprintf(line, "State = wlan Ready\n");
++		break;
++	case 3:
++		len = sprintf(line, "State = wlan rx/tx activity\n");
++		break;
++	default:
++		len = sprintf(line, "State = %u\n", wlan_mod_state);
++		break;
+ 	}
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+-#endif //for wireless
+-	
++#endif				//for wireless
++
+ 	*offp = totallen;
+ 	return totallen;
+ }
+-static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+-                                               size_t count , loff_t *offp)
++static ssize_t proc_write_led_fops(struct file *filp, const char *buffer,
++				   size_t count, loff_t * offp)
+ {
+ 	char *pdata = NULL, *ptemp = NULL;
+ 	char line[10], temp[10];
+@@ -833,37 +851,34 @@
+ 	int mod = 0xffff, state = 0xffff;
+ 	int flag = 0;
+ 
+- 	 /* Check if this write is for configuring ADSL */
+-  	if( *(int *)(buffer) == 0xFFEEDDCC )
+-	{
+-   		 printk("<1>proc write:Calling Configuration\n");
+-		 config_led((unsigned long)(buffer + sizeof(int)) );
+-		 return count;
++	/* Check if this write is for configuring ADSL */
++	if (*(int *)(buffer) == 0xFFEEDDCC) {
++		printk(KERN_ALERT "proc write:Calling Configuration\n");
++		config_led((unsigned long)(buffer + sizeof(int)));
++		return count;
+ 	}
+ 
+-	if (count > 10)
+-	{
+-		printk("<1> proc write: Input too long, max length = 10\n");
++	if (count > 9) {
++		printk(KERN_ALERT "proc write: Input too long, max length = 9\n");
+ 		return count;
+ 	}
+-	memset(temp, 0x00, 10);
+-	memset(line, 0x00, 10);
++	memset(temp, 0x00, sizeof(temp));
++	memset(line, 0x00, sizeof(line));
+ 	copy_from_user(line, buffer, count);
+ 	line[count] = 0x00;
+ 	pdata = line;
+-	ptemp = temp;	
+-	
+-	while (flag == 0)
+-	{
++	ptemp = temp;
++
++	printk(KERN_DEBUG "%s:%u %s, got string %s\n",
++		__FILE__, __LINE__, __FUNCTION__, line);
++
++	while (flag == 0) {
+ 		if (i > 10)
+ 			break;
+-		if (((*pdata) >= '0') && ((*pdata) <= '9'))
+-		{
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
+ 			*ptemp = *pdata;
+ 			ptemp++;
+-		}
+-		else if ((*pdata) == ',')
+-		{
++		} else if ((*pdata) == ',') {
+ 			*ptemp = 0x00;
+ 			flag = 1;
+ 		}
+@@ -874,22 +889,17 @@
+ 		mod = led_atoi(temp);
+ 	else
+ 		return count;
+-	
++
+ 	ptemp = temp;
+-	*ptemp = 0x00;
+ 	flag = 0;
+-	
+-	while(flag == 0)
+-	{
++
++	while (flag == 0) {
+ 		if (i > 10)
+ 			break;
+-		if (((*pdata) >= '0') && ((*pdata) <= '9'))
+-		{
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
+ 			*ptemp = *pdata;
+ 			ptemp++;
+-		}
+-		else if ((*pdata) == 0x00)
+-		{
++		} else if ((*pdata) == 0x00) {
+ 			*ptemp = 0x00;
+ 			flag = 1;
+ 		}
+@@ -900,217 +910,214 @@
+ 		state = led_atoi(temp);
+ 	else
+ 		return count;
+-	if ((mod == 0xFFFF) || (state == 0xFFFF))
++	if ((mod == 0xFFFF) || (state == 0xFFFF)) {
+ 		return count;
+-	else
+-	{
+-		if (mod != 4)
+-			led_active(mod, state);	
+-		else 
+-			led_operation(mod, state);
+-	} 
+-	return 1;
++	//~ } else if (mod != 4) {
++		//~ led_active(mod, state);
++	} else {
++		led_operation(mod, state);
++	}
++	return count;
+ }
+ #endif
+ /************end *******************/
+ static int config_led(unsigned long y)
+ {
+-  config_elem_t *pcfg = NULL;
+-  char *pdata = NULL;
+-  int i;
+-  int length = 0 , number = 0;
++	config_elem_t *pcfg;
++	int i;
++	int length = 0, number = 0;
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+-    /* ioctl to configure */
+-    length =  *((int*)y);
+-    pdata = (char *)y + sizeof(int);
+-    number =  (length - sizeof(int))/sizeof(config_elem_t);
+-    pcfg = (config_elem_t *)(pdata);
+-
+-    /* Check if an earlier configuration exists IF yes free it up */
+-    free_memory();
+-
+-    for ( i = 0 ; i < number ; i++ )
+-    {
+-			/* If no structure has been allocated for the module do so */
+-      if ( modArr[pcfg->name] == NULL )
+-			{
+-					printk("<1>module =  %d\n",pcfg->name);
+-        if( pcfg->name >= MAX_MOD_ID)
+-				{
+-					printk("<1>Exiting Configuration: Module ID too large %d\n",pcfg->name);
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-        modArr[pcfg->name] = kmalloc(sizeof(mod_entry_t),GFP_KERNEL);
+-        if(modArr[pcfg->name] == NULL)
+-				{
+-					printk("<1>Exiting Configuration: Error in allocating memory\n");
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-				memset( modArr[pcfg->name], 0x00, sizeof(mod_entry_t));
++	/* ioctl to configure */
++	length = *((int *)y);
++	pcfg = (config_elem_t *)((char *)y + sizeof(int));
++	number = (length - sizeof(int)) / sizeof(config_elem_t);
++
++	/* Check if an earlier configuration exists IF yes free it up */
++	free_memory();
++
++	for (i = 0; i < number; i++) {
++		/* If no structure has been allocated for the module do so */
++		if (modArr[pcfg->name] == NULL) {
++			printk(KERN_ALERT "module =  %d\n", pcfg->name);
++			if (pcfg->name >= MAX_MOD_ID) {
++				printk
++				    ("<1>Exiting Configuration: Module ID too large %d\n",
++				     pcfg->name);
++				free_memory();
++				spin_unlock_irqrestore(&config_lock, flags);
++				return -1;
+ 			}
+-
+-      /* if no structure is allocated previously for this state
+-         allocate a structure, if it's already there fill it up */
+-			if( modArr[pcfg->name]->states[pcfg->state] == NULL)
+-			{
+-					printk("<1>STATE =  %d\n",pcfg->state);
+-				if( pcfg->state >= MAX_STATE_ID)
+-				{
+-					printk("<1>Exiting Configuration: State ID too large\n");
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-				modArr[pcfg->name]->states[pcfg->state] =
+-                        kmalloc(sizeof(state_entry_t),GFP_KERNEL);
+-				if( modArr[pcfg->name]->states[pcfg->state] == NULL)
+-				{
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-				memset( modArr[pcfg->name]->states[pcfg->state], 0x00, sizeof(state_entry_t));
++			modArr[pcfg->name] =
++			    kmalloc(sizeof(mod_entry_t), GFP_KERNEL);
++			if (modArr[pcfg->name] == NULL) {
++				printk
++				    ("<1>Exiting Configuration: Error in allocating memory\n");
++				free_memory();
++				spin_unlock_irqrestore(&config_lock, flags);
++				return -1;
+ 			}
+-			/* Fill up the fields of the state */
+-      if( pcfg->led >= MAX_LED_ID)
+-			{
+-				printk("<1>led =  %d\n",pcfg->led);
++			memset(modArr[pcfg->name], 0x00, sizeof(mod_entry_t));
++		}
++
++		/* if no structure is allocated previously for this state
++		   allocate a structure, if it's already there fill it up */
++		if (modArr[pcfg->name]->states[pcfg->state] == NULL) {
++			printk(KERN_ALERT "STATE =  %d\n", pcfg->state);
++			if (pcfg->state >= MAX_STATE_ID) {
++				printk
++				    ("<1>Exiting Configuration: State ID too large\n");
+ 				free_memory();
+ 				spin_unlock_irqrestore(&config_lock, flags);
+ 				return -1;
+ 			}
+-      modArr[pcfg->name]->states[pcfg->state]->led = pcfg->led;
+-      modArr[pcfg->name]->states[pcfg->state]->mode = pcfg->mode;
+-      modArr[pcfg->name]->states[pcfg->state]->param = pcfg->param;
+-			switch(pcfg->mode)
+-			{
+-				case 1:
+-      		modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_down;
+-					break;
+-				case 2:
+-				case 3:
+-				case 5:
+-					if( pcfg->mode == 2 )
+-						modArr[pcfg->name]->states[pcfg->state]->handler = board_led_activity_on;
+-					else if( pcfg->mode == 3)
+-      			modArr[pcfg->name]->states[pcfg->state]->handler = board_led_activity_off;
+-					else
+-		        modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_flash;
+-					break;
+-				case 4:
+-      		modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_up;
+-					break;
+-				default:
+-				  printk("<1>Exiting Configuration: Unknown LED Mode\n");
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
++			modArr[pcfg->name]->states[pcfg->state] =
++			    kmalloc(sizeof(state_entry_t), GFP_KERNEL);
++			if (modArr[pcfg->name]->states[pcfg->state] == NULL) {
++				free_memory();
++				spin_unlock_irqrestore(&config_lock, flags);
++				return -1;
+ 			}
+-			pcfg++;			
+-    }
++			memset(modArr[pcfg->name]->states[pcfg->state], 0x00,
++			       sizeof(state_entry_t));
++		}
++		/* Fill up the fields of the state */
++		if (pcfg->led >= MAX_LED_ID) {
++			printk(KERN_ALERT "led =  %d\n", pcfg->led);
++			free_memory();
++			spin_unlock_irqrestore(&config_lock, flags);
++			return -1;
++		}
++		modArr[pcfg->name]->states[pcfg->state]->led = pcfg->led;
++		modArr[pcfg->name]->states[pcfg->state]->mode = pcfg->mode;
++		modArr[pcfg->name]->states[pcfg->state]->param = pcfg->param;
++		switch (pcfg->mode) {
++		case 1:
++			modArr[pcfg->name]->states[pcfg->state]->handler =
++			    board_led_link_down;
++			break;
++		case 2:
++		case 3:
++		case 5:
++			if (pcfg->mode == 2)
++				modArr[pcfg->name]->states[pcfg->state]->
++				    handler = board_led_activity_on;
++			else if (pcfg->mode == 3)
++				modArr[pcfg->name]->states[pcfg->state]->
++				    handler = board_led_activity_off;
++			else
++				modArr[pcfg->name]->states[pcfg->state]->
++				    handler = board_led_link_flash;
++			break;
++		case 4:
++			modArr[pcfg->name]->states[pcfg->state]->handler =
++			    board_led_link_up;
++			break;
++		default:
++			printk(KERN_ALERT "Exiting Configuration: Unknown LED Mode\n");
++			free_memory();
++			spin_unlock_irqrestore(&config_lock, flags);
++			return -1;
++		}
++		pcfg++;
++	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+-  return 0;
++	return 0;
+ }
+ 
+-
+ int __init led_init(void)
+ {
++	printk(KERN_DEBUG "%s:%u %s\n", __FILE__, __LINE__, __FUNCTION__);
+ 
+-  /* Clear our memory */
+-  memset(modArr,0x00,sizeof(mod_entry_t *)*MAX_MOD_ID);
+-  memset(led_arr,0x00,sizeof(led_data_t *)*MAX_LED_ID);
++	/* Clear our memory */
++	memset(modArr, 0x00, sizeof(modArr));
++	memset(led_arr, 0x00, sizeof(led_arr));
+ 
+ 	/* Create spin lock for config data structure */
+-	config_lock=SPIN_LOCK_UNLOCKED;
++	config_lock = SPIN_LOCK_UNLOCKED;
+ 
+-  /* Create directory */
+-  led_proc_dir = proc_mkdir("led", NULL);
+-  if( led_proc_dir == NULL )
+-    goto out;
+-
+-  /* Create adsl file */
+-  led_file = create_proc_entry("led", 0777, led_proc_dir);
+-  if( led_file == NULL)
+-    goto led_file;
+-  led_file->owner = THIS_MODULE;
+-  led_file->proc_fops = &led_fops;
++	/* Create directory */
++	led_proc_dir = proc_mkdir("led", NULL);
++	if (led_proc_dir == NULL)
++		goto out;
++
++	/* Create adsl file */
++	led_file = create_proc_entry("led", 0777, led_proc_dir);
++	if (led_file == NULL)
++		goto led_file;
++	led_file->owner = THIS_MODULE;
++	led_file->proc_fops = &led_fops;
+ 
+-  memset( modArr , 0x00 , sizeof(mod_entry_t *) * MAX_MOD_ID);
+ 	/* Reset the GPIO pins  */
+-  board_gpio_init();
++	board_gpio_init();
+ 
+ 	/* Register the UART controlled LEDS  */
+-  uart_led_init();
+-  /* Create the usb proc file */
++	uart_led_init();
++	/* Create the usb proc file */
+ 	avalanche_leds_init();
+-  return 0;
++	return 0;
+ 
+-  led_file:
+-    remove_proc_entry("led",led_proc_dir);
+-  out:
+-    return 0;
++      led_file:
++	remove_proc_entry("led", led_proc_dir);
++      out:
++	return 0;
+ 
+ }
+ 
+-void led_exit()
++void led_exit(void)
+ {
++	printk(KERN_DEBUG "%s:%u %s\n", __FILE__, __LINE__, __FUNCTION__);
+ 	remove_proc_entry("led", led_proc_dir);
+ }
+ 
+ module_init(led_init);
+ module_exit(led_exit);
+ 
+-void register_led_drv( int device , led_reg_t *pInfo)
++void register_led_drv(int device, led_reg_t * pInfo)
+ {
+-	unsigned int flags;
+-	struct timer_list *pTimer = NULL;
++	printk(KERN_DEBUG "%s:%u %s(%d,...)\n", __FILE__, __LINE__, __FUNCTION__, device);
++	if (device < ARRAY_SIZE(led_arr)) {
++		unsigned int flags;
++		struct timer_list *pTimer;
++
++		spin_lock_irqsave(&config_lock, flags);
++
++		led_arr[device].led = pInfo;
++		if (led_arr[device].led->init != 0x00)
++			led_arr[device].led->init(led_arr[device].led->param);
++		if (led_arr[device].led->offfunc != 0x00)
++			led_arr[device].led->offfunc(led_arr[device].led->param);
++
++		/* Create a timer for blinking   */
++		pTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++		init_timer(pTimer);
++		pTimer->function = led_timer_func;
++		pTimer->data = 0;
++		led_arr[device].pTimer = pTimer;
++		led_arr[device].timer_running = 0;
+ 
+-	spin_lock_irqsave(&config_lock, flags);
+-
+-	led_arr[device].led = pInfo;
+-	if( led_arr[device].led->init != 0x00)
+-      led_arr[device].led->init(led_arr[device].led->param);
+-	if( led_arr[device].led->offfunc != 0x00)
+-      led_arr[device].led->offfunc(led_arr[device].led->param);
+-
+-	/* Create a timer for blinking   */
+-  pTimer = kmalloc(sizeof(struct timer_list),GFP_KERNEL);
+-	init_timer( pTimer );
+-	pTimer->function = led_timer_func;
+-	pTimer->data = 0;
+-  led_arr[device].pTimer = pTimer;
+-  led_arr[device].timer_running = 0;
+-
+-	spin_unlock_irqrestore(&config_lock, flags);
+-
+-  return;
++		spin_unlock_irqrestore(&config_lock, flags);
++	}
+ }
+ 
+-void deregister_led_drv( int device)
++void deregister_led_drv(int device)
+ {
+-	unsigned int flags;
+-
+-	spin_lock_irqsave(&config_lock, flags);
+-	led_arr[device].led = NULL;
+-
+-	if( led_arr[device].pTimer != NULL)
+-	{
+-		del_timer(led_arr[device].pTimer);
+-		kfree(led_arr[device].pTimer);
++	printk(KERN_DEBUG "%s:%u %s\n", __FILE__, __LINE__, __FUNCTION__);
++	if (device < ARRAY_SIZE(led_arr)) {
++		unsigned int flags;
++		spin_lock_irqsave(&config_lock, flags);
++		led_arr[device].led = NULL;
++
++		if (led_arr[device].pTimer != NULL) {
++			del_timer(led_arr[device].pTimer);
++			kfree(led_arr[device].pTimer);
++		}
++		spin_unlock_irqrestore(&config_lock, flags);
+ 	}
+-	spin_unlock_irqrestore(&config_lock, flags);
+-
+-  return;
+ }
+ 
+ EXPORT_SYMBOL_NOVERS(led_operation);
+ EXPORT_SYMBOL_NOVERS(register_led_drv);
+ EXPORT_SYMBOL_NOVERS(deregister_led_drv);
+-
+diff -urN linux-2.4.32/drivers/char/avalanche_led/leds.c linux-2.4.32.new/drivers/char/avalanche_led/leds.c
+--- linux-2.4.32/drivers/char/avalanche_led/leds.c	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/char/avalanche_led/leds.c	2006-05-18 20:28:07.000000000 +0200
+@@ -1,3 +1,7 @@
++/*
++ *
++ */
++
+ #include <linux/config.h>
+ #include <linux/init.h>
+ #include <linux/delay.h>
+@@ -12,109 +16,114 @@
+ 
+ #include <asm/ar7/ledapp.h>
+ 
++#include "led.h"
++
+ #if defined(CONFIG_AR5D01) || defined(CONFIG_AR5W01) || defined(CONFIG_AR7)
+ 
+ #define ETH_MASK 0x01
+ #define USB_MASK 0x02
+ 
+-static struct proc_dir_entry *usb_file;
+-static ssize_t proc_read_usb_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp);
+-struct file_operations usb_fops = {read: proc_read_usb_fops};
+-
+-typedef struct mod_states{
+-  int module;
+-  int activity;
+-  int linkup;
+-  int idle;
+-}mod_states_t;
+-
+-mod_states_t state_arr[] = {
+-                          	{ MOD_ETH,DEF_ETH_ACTIVITY,DEF_ETH_LINK_UP,DEF_ETH_IDLE },
+-                          	{ MOD_USB,DEF_USB_ACTIVITY,DEF_USB_LINK_UP,DEF_USB_IDLE },
+-                          	{ MOD_LAN,DEF_LAN_ACTIVITY,DEF_LAN_LINK_UP,DEF_LAN_IDLE }
+-                        	};
+-
+-unsigned char	device_links = 0;	/* Bitmask with the devices that are up */
++typedef struct mod_states {
++	int module;
++	int activity;
++	int linkup;
++	int idle;
++} mod_states_t;
++
++static mod_states_t state_arr[] = {
++	{MOD_ETH, DEF_ETH_ACTIVITY, DEF_ETH_LINK_UP, DEF_ETH_IDLE},
++	{MOD_USB, DEF_USB_ACTIVITY, DEF_USB_LINK_UP, DEF_USB_IDLE},
++	{MOD_LAN, DEF_LAN_ACTIVITY, DEF_LAN_LINK_UP, DEF_LAN_IDLE}
++};
+ 
++static unsigned char device_links;	/* Bitmask with the devices that are up */
+ 
+-void avalanche_led_activity_pulse(unsigned long device)
++static void avalanche_led_activity_pulse(unsigned long device)
+ {
++	printk(KERN_DEBUG "%s(%lu)\n", __FUNCTION__, device);
++
+ 	/* If device link is not up return */
+-  if( !(device_links & (unsigned char)(1 << device)))
++	if (!(device_links & (unsigned char)(1 << device)))
+ 		return;
+ #ifdef MULTIPLEX_LED
+-	led_operation( state_arr[2].module, state_arr[2].activity);
++	led_operation(state_arr[2].module, state_arr[2].activity);
+ #else
+-	led_operation( state_arr[device].module, state_arr[device].activity);
++	led_operation(state_arr[device].module, state_arr[device].activity);
+ #endif
+ }
+ 
+-void avalanche_led_link_up( unsigned long device )
++static void avalanche_led_link_up(unsigned long device)
+ {
+-	
+-  /* If already UP ignore */
+-  if( device_links & (unsigned char)(1 << device))
++	printk(KERN_DEBUG "%s(%lu)\n", __FUNCTION__, device);
++
++	/* If already UP ignore */
++	if (device_links & (unsigned char)(1 << device))
+ 		return;
+-  /* Turn on the bit for the device */
++	/* Turn on the bit for the device */
+ 	device_links |= (unsigned char)(1 << device);
+ #ifdef MULTIPLEX_LED
+-	led_operation( state_arr[2].module, state_arr[2].linkup);
++	led_operation(state_arr[2].module, state_arr[2].linkup);
+ #else
+-	led_operation( state_arr[device].module, state_arr[device].linkup);
++	led_operation(state_arr[device].module, state_arr[device].linkup);
+ #endif
+ }
+ 
+-void avalanche_led_link_down ( unsigned long device )
++static void avalanche_led_link_down(unsigned long device)
+ {
++	printk(KERN_DEBUG "%s(%lu)\n", __FUNCTION__, device);
+ 
+-  /* If already DOWN ignore */
+-  if( !(device_links & (unsigned char)(1 << device)))
++	/* If already DOWN ignore */
++	if (!(device_links & (unsigned char)(1 << device)))
+ 		return;
+ 
+ 	/* Turn off the bit for the device */
+ 	device_links &= ~(unsigned char)(1 << device);
+ #ifdef MULTIPLEX_LED
+ 	/* If no links, then shut the LED off  */
+-	if(!device_links)
+-		led_operation( state_arr[2].module, state_arr[2].idle);
++	if (!device_links)
++		led_operation(state_arr[2].module, state_arr[2].idle);
+ #else
+-	led_operation( state_arr[device].module, state_arr[device].idle);
++	led_operation(state_arr[device].module, state_arr[device].idle);
+ #endif
+ }
+ 
+ static ssize_t proc_read_usb_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				  char *buf, size_t count, loff_t * offp)
+ {
+-  char * pdata = NULL;
+-  char line[3];
+-  if( *offp != 0 )
+-  	return 0;
+-  pdata = buf;
+-  if( device_links & USB_MASK)
+-  	sprintf(line,"%s\n","1");
+-  else
+-  	sprintf(line,"%s\n","0");
+-  copy_to_user(pdata,line,2);
++	char *pdata = NULL;
++	char line[3];
++	if (*offp != 0)
++		return 0;
++	pdata = buf;
++	if (device_links & USB_MASK)
++		sprintf(line, "%s\n", "1");
++	else
++		sprintf(line, "%s\n", "0");
++	copy_to_user(pdata, line, 2);
+ 	*offp = 2;
+ 	return 2;
+ }
+ 
++static struct proc_dir_entry *usb_file;
++
++struct file_operations usb_fops = { read:proc_read_usb_fops };
+ 
+ void avalanche_leds_init(void)
+ {
+-  /* Create usb link proc file */
+-  usb_file = create_proc_entry("avalanche/usb_link", 0444, NULL);
+-  if( usb_file == NULL)
+-    return;
+-  usb_file->owner = THIS_MODULE;
+-  usb_file->proc_fops = &usb_fops;
++	proc_mkdir("avalanche", NULL);
++
++	/* Create usb link proc file */
++	usb_file = create_proc_entry("avalanche/usb_link", 0444, NULL);
++	if (usb_file == NULL)
++		return;
++	usb_file->owner = THIS_MODULE;
++	usb_file->proc_fops = &usb_fops;
+ 	return;
+ }
+ 
+-EXPORT_SYMBOL(avalanche_led_activity_pulse);
+-EXPORT_SYMBOL(avalanche_led_link_up);
+-EXPORT_SYMBOL(avalanche_led_link_down);
++//~ EXPORT_SYMBOL(avalanche_led_activity_pulse);
++//~ EXPORT_SYMBOL(avalanche_led_link_up);
++//~ EXPORT_SYMBOL(avalanche_led_link_down);
+ 
+ #else
+ /* We make a dummy init routine for the platforms that do not support this led
+@@ -127,7 +136,94 @@
+ 
+ #endif
+ 
++#if defined(CONFIG_AR7_LED)
+ 
++#include <asm/ar7/led_hal.h>	/* avalanche_led_action, ... */
+ 
++/*
++cpmac
++CPMAC_LINK_OFF		0
++CPMAC_LINK_ON		1
++CPMAC_RX_ACTIVITY	2
++CPMAC_TX_ACTIVITY	3
+ 
++wlan
++*/
++
++typedef void (*device_action_t)(unsigned long device);
+ 
++typedef struct {
++	const char name[8];
++	unsigned long id;
++	unsigned short counter;
++	device_action_t action[4];
++} device_t;
++
++
++static device_t devices[] = {
++	{
++		name:"cpmac",
++		id:0,
++		action: {
++			avalanche_led_link_down,
++			avalanche_led_link_up,
++			avalanche_led_activity_pulse,
++			avalanche_led_activity_pulse
++		}
++	},
++	{
++		name:"wlan",
++		id:1,
++		action: {
++			avalanche_led_link_down,
++			avalanche_led_link_up,
++			avalanche_led_activity_pulse,
++			avalanche_led_activity_pulse
++		}
++	}
++};
++
++void avalanche_led_action(void *handle, int state_id)
++{
++	if (handle != 0) {
++		device_t *device = (device_t *)handle;
++		if (state_id < 0 || state_id > 3) {
++		} else {
++			if (device->counter++ < 10) {
++				printk(KERN_DEBUG "%s(%s,%d)\n", __FUNCTION__,
++					device->name, state_id);
++				if (device->counter == 10) {
++					printk(KERN_DEBUG "%s log output disabled\n", __FUNCTION__);
++				}
++				device->action[state_id](device->id);
++			}
++		}
++	}
++}
++
++void *avalanche_led_register(const char *module_name, int instance_num)
++{
++	device_t *device = 0;
++	printk(KERN_DEBUG "%s(%s,%d)\n", __FUNCTION__, module_name, instance_num);
++	if (strcmp(module_name, devices[0].name) == 0) {
++		device = &devices[0];
++	} else if (strcmp(module_name, devices[1].name) == 0) {
++		device = &devices[1];
++	}
++	return (void *)device;
++}
++
++int avalanche_led_unregister(void *handle)
++{
++	if (handle != 0) {
++		device_t *device = (device_t *)handle;
++		printk(KERN_DEBUG "%s(%s)\n", __FUNCTION__, device->name);
++	}
++	return 0;
++}
++
++EXPORT_SYMBOL(avalanche_led_action);
++EXPORT_SYMBOL(avalanche_led_register);
++EXPORT_SYMBOL(avalanche_led_unregister);
++
++#endif
+diff -urN linux-2.4.32/drivers/char/avalanche_led/Makefile linux-2.4.32.new/drivers/char/avalanche_led/Makefile
+--- linux-2.4.32/drivers/char/avalanche_led/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -3,21 +3,11 @@
+ # Makefile for the Linux LED device driver.
+ #
+ 
+-
+ O_TARGET := avalanche_led.o
+-obj-m := avalanche_led.o
+-list-multi      := avalanche_led.o
++obj-$(CONFIG_AR7_LED) := ledmod.o gpio.o uartled.o leds.o
+ 
+ EXTRA_CFLAGS := -I$(TOPDIR)/include/asm/ar7
+ 
+ export-objs := ledmod.o leds.o
+ 
+-avalanche_led-objs := ledmod.o gpio.o uartled.o leds.o
+-
+ include $(TOPDIR)/Rules.make
+-
+-avalanche_led.o:      $(avalanche_led-objs)
+-	$(LD) -r -o $@ $(avalanche_led-objs)
+-
+-clean:
+-	rm -f core *.o *.a *.s
+diff -urN linux-2.4.32/drivers/char/avalanche_led/uartled.c linux-2.4.32.new/drivers/char/avalanche_led/uartled.c
+--- linux-2.4.32/drivers/char/avalanche_led/uartled.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/uartled.c	2005-12-27 21:44:16.000000000 +0100
+@@ -9,6 +9,7 @@
+ static spinlock_t	device_lock;
+ led_reg_t temp1[2];
+ 
++#if defined(CONFIG_AR5D01) || defined(CONFIG_AR5W01)
+ static void uart_led_on(unsigned long param)
+ {
+   unsigned long flags;
+@@ -25,6 +26,7 @@
+    UART_LED_REG |= 0x02;
+ 	spin_unlock_irqrestore(&device_lock, flags);
+ }
++#endif
+ 
+ void uart_led_init(void)
+ {
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_board.c linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_board.c
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_board.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_board.c	2005-12-27 21:44:16.000000000 +0100
+@@ -21,15 +21,16 @@
+ #include <linux/module.h>
+ #include <asm/ar7/sangam.h>  
+ #include <asm/ar7/avalanche_misc.h>  
+-#include <asm/ar7/vlynq_hal.h>  
++#include <asm/ar7/vlynq_hal.h>  
+    
++#include "vlynq_drv.h"
++
+ #define SYS_VLYNQ_LOCAL_INTERRUPT_VECTOR	30 	/* MSB - 1 bit */
+ #define SYS_VLYNQ_REMOTE_INTERRUPT_VECTOR	31 	/* MSB bit */
+ #define SYS_VLYNQ_OPTIONS 		        0x7F; 	/* all options*/
+ 
+ /* These defines are board specific */
+ 
+-
+ #define VLYNQ0_REMOTE_WINDOW1_OFFSET           (0x0C000000)
+ #define VLYNQ0_REMOTE_WINDOW1_SIZE             (0x500)
+ 
+@@ -38,12 +39,11 @@
+ #define VLYNQ1_REMOTE_WINDOW1_SIZE             (0x500)
+ 
+ 
+-extern VLYNQ_DEV vlynqDevice0, vlynqDevice1;
+ int    vlynq_init_status[2] = {0, 0};
+ EXPORT_SYMBOL(vlynq_init_status);
+ static int reset_hack = 1;
+ 
+-void vlynq_ar7wrd_dev_init()
++void vlynq_ar7wrd_dev_init(void)
+ {
+     *(unsigned long*) AVALANCHE_GPIO_ENBL    |= (1<<18);
+     vlynq_delay(20000);
+@@ -148,6 +148,9 @@
+ void remote_vlynq_dev_reset_ctrl(unsigned int module_reset_bit,
+                                  AVALANCHE_RESET_CTRL_T reset_ctrl)
+ {
++    printk("%s:%u %s(%u,%u)\n", __FILE__, __LINE__, __FUNCTION__,
++	module_reset_bit, reset_ctrl);
++
+     if(module_reset_bit >= 32)
+         return;
+ 
+@@ -182,3 +185,52 @@
+     }
+ }
+ 
++void vlynq_set_function_pointers(void) {
++#if 0
++        p_vlynq_interrupt_vector_set    = (p_vlynq_interrupt_vector_set_t) vlynq_interrupt_vector_set;
++        p_vlynq_interrupt_vector_cntl   = (p_vlynq_interrupt_vector_cntl_t) vlynq_interrupt_vector_cntl;
++        p_vlynq_interrupt_get_count     = (p_vlynq_interrupt_get_count_t) vlynq_interrupt_get_count;
++        p_vlynq_install_isr             = (p_vlynq_install_isr_t) vlynq_install_isr;
++        p_vlynq_uninstall_isr           = (p_vlynq_uninstall_isr_t) vlynq_uninstall_isr;
++        p_vlynq_root_isr                = (p_vlynq_root_isr_t) vlynq_root_isr;
++        p_vlynq_delay                   = (p_vlynq_delay_t) vlynq_delay;
++        p_vlynq_interrupt_vector_map    = (p_vlynq_interrupt_vector_map_t) vlynq_interrupt_vector_map;
++        p_vlynq_interrupt_set_polarity  = (p_vlynq_interrupt_set_polarity_t) vlynq_interrupt_set_polarity;
++        p_vlynq_interrupt_get_polarity  = (p_vlynq_interrupt_get_polarity_t) vlynq_interrupt_get_polarity;
++        p_vlynq_interrupt_set_type      = (p_vlynq_interrupt_set_type_t) vlynq_interrupt_set_type;
++        p_vlynq_interrupt_get_type      = (p_vlynq_interrupt_get_type_t) vlynq_interrupt_get_type;
++        p_vlynq_interrupt_enable        = (p_vlynq_interrupt_enable_t) vlynq_interrupt_enable;
++        p_vlynq_interrupt_disable       = (p_vlynq_interrupt_disable_t) vlynq_interrupt_disable;
++#endif
++        p_remote_vlynq_dev_reset_ctrl   = remote_vlynq_dev_reset_ctrl;
++
++#if 0
++        p_vlynqDevice0 = &vlynqDevice0;
++        p_vlynqDevice1 = &vlynqDevice1;
++#endif
++}
++
++void vlynq_clear_function_pointers(void) {
++#if 0
++        p_vlynq_interrupt_vector_set    = NULL;
++        p_vlynq_interrupt_vector_cntl   = NULL;
++        p_vlynq_interrupt_get_count     = NULL;
++        p_vlynq_install_isr             = NULL;
++        p_vlynq_uninstall_isr           = NULL;
++        p_vlynq_root_isr                = NULL;
++        p_vlynq_delay                   = NULL;
++        p_vlynq_interrupt_vector_map    = NULL;
++        p_vlynq_interrupt_set_polarity  = NULL;
++        p_vlynq_interrupt_get_polarity  = NULL;
++        p_vlynq_interrupt_set_type      = NULL;
++        p_vlynq_interrupt_get_type      = NULL;
++        p_vlynq_interrupt_enable        = NULL;
++        p_vlynq_interrupt_disable       = NULL;
++#endif
++        p_remote_vlynq_dev_reset_ctrl   = NULL;
++
++#if 0
++        p_vlynqDevice0 = NULL;
++        p_vlynqDevice1 = NULL;
++#endif
++}
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.c linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.c
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.c	2005-12-27 21:44:16.000000000 +0100
+@@ -26,22 +26,23 @@
+ #include <linux/capability.h>
+ #include <asm/ar7/avalanche_intc.h>
+ #include <asm/ar7/sangam.h>
+-#include <asm/ar7/vlynq_hal.h>
++#include <asm/ar7/vlynq_hal.h>
+ 
++#include "vlynq_drv.h"
+ 
+ #define    TI_VLYNQ_VERSION                 "0.2"
+ 
+-/* debug on ? */
+-#define VLYNQ_DEBUG 
++/* debug on? Macro is set in vlynq_hal.h. */
++/* #define VLYNQ_DEBUG */
+ 
+ /* Macro for debug and error printf's */
+ #ifdef VLYNQ_DEBUG
+-#define DBGPRINT  printk
++# define DBGPRINT(format, args...) printk(format, ## args)
+ #else
+-#define DBGPRINT(x)  
++# define DBGPRINT(format, args...)  
+ #endif
+ 
+-#define ERRPRINT  printk
++#define ERRPRINT(format, args...) printk(format, ##args)
+ 
+ /* Define the max vlynq ports this driver will support. 
+    Device name strings are statically added here */
+@@ -54,8 +55,6 @@
+     VLYNQ_DEV *vlynqDevice;
+ }VLYNQ_PRIV;
+ 
+-extern int vlynq_init_status[2];
+-
+ /* Extern Global variable for vlynq devices used in initialization of the vlynq device
+  * These variables need to be populated/initialized by the system as part of initialization
+  * process. The vlynq enumerator can run at initialization and populate these globals
+@@ -80,8 +79,6 @@
+     { LNXINTNUM(AVALANCHE_HIGH_VLYNQ_INT),&vlynqDevice1},
+ };
+ 
+-extern void vlynq_dev_init(void);
+-
+ 
+ /* =================================== all the operations */
+ 
+@@ -139,10 +136,9 @@
+ static int                                                                                     
+ vlynq_read_ver_proc(char *buf, char **start, off_t offset, int count, int *eof, void *data)        
+ {                                                                                              
+-	int instance;                                                                              
+-	int len=0;                                                                                 
+-                                                                                               
+-	len += sprintf(buf +len,"\nTI Linux VLYNQ Driver Version %s\n",TI_VLYNQ_VERSION);         
++	int len;
++	// may cause buffer overflow!!!
++	len = sprintf(buf, "\nTI Linux VLYNQ Driver Version %s\n", TI_VLYNQ_VERSION);
+ 	return len;                                                                                
+ }                                                                                              
+ 
+@@ -162,7 +158,10 @@
+     int ret;
+     int unit = 0;
+     int instance_count = CONFIG_AR7_VLYNQ_PORTS;
+-    volatile int *ptr;
++
++    vlynq_set_function_pointers();
++    memset(&vlynqDevice0, 0, sizeof (VLYNQ_DEV));
++    memset(&vlynqDevice1, 0, sizeof (VLYNQ_DEV));
+ 
+     vlynq_dev_init();
+ 
+@@ -171,6 +170,7 @@
+     if (instance_count > MAX_VLYNQ_PORTS)
+     {
+         ERRPRINT("ERROR: vlynq_init_module(): Max %d supported\n", MAX_VLYNQ_PORTS);
++        vlynq_clear_function_pointers();
+         return (-1);
+     }
+ 
+@@ -184,16 +184,16 @@
+             ERRPRINT("ERROR:Could not register vlynq device:%d\n",unit);
+             continue;
+         }
+-        else 
+-            DBGPRINT("Vlynq Device %s registered with minor no %d as misc device. Result=%d\n", 
++	DBGPRINT("Vlynq Device %s registered with minor no %d as misc device. Result=%d\n", 
+                 vlynq_dev[unit].name, vlynq_dev[unit].minor, ret);
+-#if 0
+             
+-        DBGPRINT("Calling vlynq init\n");
++        if(vlynq_init_status[unit] == 0)
++	{
++		DBGPRINT("Calling vlynq init\n");
+ 
+-        /* Read the global variable for VLYNQ device structure and initialize vlynq driver */
+-        ret = vlynq_init(vlynq_priv[unit].vlynqDevice,VLYNQ_INIT_PERFORM_ALL );
+-#endif
++		/* Read the global variable for VLYNQ device structure and initialize vlynq driver */
++		ret = vlynq_init(vlynq_priv[unit].vlynqDevice,VLYNQ_INIT_PERFORM_ALL );
++	}
+ 
+         if(vlynq_init_status[unit] == 0)
+         {
+@@ -215,7 +215,6 @@
+         } 
+     }
+ 
+-    proc_mkdir("avalanche", NULL);
+     /* Creating proc entry for the devices */
+     create_proc_read_entry("avalanche/vlynq_link", 0, NULL, vlynq_read_link_proc, NULL);
+     create_proc_read_entry("avalanche/vlynq_ver", 0, NULL, vlynq_read_ver_proc, NULL);
+@@ -227,6 +226,8 @@
+ {
+     int unit = 0;
+     
++    vlynq_clear_function_pointers();
++
+     for (unit = 0; unit < CONFIG_AR7_VLYNQ_PORTS; unit++)
+     {
+         DBGPRINT("vlynq_cleanup_module(): Unregistring misc device %s\n",vlynq_dev[unit].name);
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.h linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.h
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.h	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,10 @@
++/* 
++ */
++
++extern void vlynq_set_function_pointers(void);
++extern void vlynq_clear_function_pointers(void);
++
++/* vlynq_board.h */
++extern int vlynq_init_status[2];
++extern void vlynq_dev_init(void);
++
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_hal.c linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_hal.c
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-12-29 11:23:34.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-12-27 21:44:16.000000000 +0100
+@@ -36,7 +36,8 @@
+ 
+ #include <linux/stddef.h>
+ #include <linux/types.h>
+-#include <asm/ar7/vlynq_hal.h>
++#include <linux/kernel_stat.h> /* kstat */
++#include <asm/ar7/vlynq_hal.h>
+ 
+ /**** Local Function prototypes *******/
+ static int vlynqInterruptInit(VLYNQ_DEV *pdev);
+@@ -128,7 +129,7 @@
+ int vlynq_init(VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options)
+ {
+     unsigned int map;
+-    unsigned int val=0,cnt,tmp;
++    unsigned int val = 0, tmp;
+     unsigned int counter=0;
+     VLYNQ_INTERRUPT_CNTRL *intSetting=NULL;
+ 
+@@ -538,7 +539,8 @@
+                 {
+                     pdev->isrCount++;   /* update isr invocation count */    
+                     /* Call the user ISR and update the count for ISR */
+-		    entry->isrCount++;   
++		    entry->isrCount++;
++		    kstat.irqs[0][80]++;
+                     entry->isr(entry->arg1, entry->arg2, entry->arg3);
+                     if (entry->next == NULL) break;
+                     entry = entry->next;
+diff -urN linux-2.4.32/drivers/char/Makefile linux-2.4.32.new/drivers/char/Makefile
+--- linux-2.4.32/drivers/char/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -191,7 +191,7 @@
+ endif
+ 
+ #
+-# Texas Intruments LED driver
++# Texas Instruments LED driver
+ # 
+ obj-$(CONFIG_AR7_LED) += avalanche_led/avalanche_led.o
+ subdir-$(CONFIG_AR7_LED) += avalanche_led
+diff -urN linux-2.4.32/drivers/mtd/maps/ar7-flash.c linux-2.4.32.new/drivers/mtd/maps/ar7-flash.c
+--- linux-2.4.32/drivers/mtd/maps/ar7-flash.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/mtd/maps/ar7-flash.c	2005-12-27 21:44:16.000000000 +0100
+@@ -21,58 +21,55 @@
+ #include <asm/mips-boards/prom.h>
+ extern char *prom_getenv(char *name);
+ 
+-static int create_mtd_partitions(void);
+-static void __exit ar7_mtd_cleanup(void);
+-	
+ #define MAX_NUM_PARTITIONS 5
+ static struct mtd_partition ar7_partinfo[MAX_NUM_PARTITIONS];
+ 
+ static struct mtd_info *ar7_mtd_info;
+ 
+-__u8 ar7_read8(struct map_info *map, unsigned long ofs)
++static __u8 ar7_read8(struct map_info *map, unsigned long ofs)
+ {
+ 	return __raw_readb(map->map_priv_1 + ofs);
+ }
+ 
+-__u16 ar7_read16(struct map_info *map, unsigned long ofs)
++static __u16 ar7_read16(struct map_info *map, unsigned long ofs)
+ {
+ 	return __raw_readw(map->map_priv_1 + ofs);
+ }
+ 
+-__u32 ar7_read32(struct map_info *map, unsigned long ofs)
++static __u32 ar7_read32(struct map_info *map, unsigned long ofs)
+ {
+ 	return __raw_readl(map->map_priv_1 + ofs);
+ }
+ 
+-void ar7_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
++static void ar7_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+ {
+ 	memcpy_fromio(to, map->map_priv_1 + from, len);
+ }
+ 
+-void ar7_write8(struct map_info *map, __u8 d, unsigned long adr)
++static void ar7_write8(struct map_info *map, __u8 d, unsigned long adr)
+ {
+ 	__raw_writeb(d, map->map_priv_1 + adr);
+ 	mb();
+ }
+ 
+-void ar7_write16(struct map_info *map, __u16 d, unsigned long adr)
++static void ar7_write16(struct map_info *map, __u16 d, unsigned long adr)
+ {
+ 	__raw_writew(d, map->map_priv_1 + adr);
+ 	mb();
+ }
+ 
+-void ar7_write32(struct map_info *map, __u32 d, unsigned long adr)
++static void ar7_write32(struct map_info *map, __u32 d, unsigned long adr)
+ {
+ 	__raw_writel(d, map->map_priv_1 + adr);
+ 	mb();
+ }
+ 
+-void ar7_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
++static void ar7_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+ {
+ 	memcpy_toio(map->map_priv_1 + to, from, len);
+ }
+ 
+-struct map_info ar7_map = {
++static struct map_info ar7_map = {
+ 	name: "Physically mapped flash",
+ 	size: WINDOW_SIZE,
+ 	buswidth: BUSWIDTH,
+@@ -86,44 +83,6 @@
+ 	copy_to: ar7_copy_to
+ };
+ 
+-int __init ar7_mtd_init(void)
+-{
+-	int partitions;
+-	
+-       	printk(KERN_NOTICE "ar7 flash device: 0x%lx at 0x%lx.\n", (unsigned long)WINDOW_SIZE, (unsigned long)WINDOW_ADDR);
+-	ar7_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
+-
+-	if (!ar7_map.map_priv_1) {
+-		printk("Failed to ioremap\n");
+-		return -EIO;
+-	}
+-	
+-	ar7_mtd_info = do_map_probe("cfi_probe", &ar7_map);
+-	if (!ar7_mtd_info)
+-	{
+-		ar7_mtd_cleanup();
+-		return -ENXIO;
+-	}
+-	
+-	ar7_mtd_info->module = THIS_MODULE;
+-
+-	if (!(partitions = create_mtd_partitions()))
+-		add_mtd_device(ar7_mtd_info);
+-	else		
+-		add_mtd_partitions(ar7_mtd_info, ar7_partinfo, partitions);
+-
+-	return 0;
+-}
+-
+-static char *strdup(char *str)
+-{
+-	int n = strlen(str)+1;
+-	char *s = kmalloc(n, GFP_KERNEL);
+-	if (!s) return NULL;
+-	return strcpy(s, str);
+-}
+-
+-
+ static int create_mtd_partitions(void)
+ {
+ 	unsigned int offset;
+@@ -190,12 +149,12 @@
+ 	
+ 	p = 0;
+ 	
+-	ar7_partinfo[p].name = strdup("adam2");
++	ar7_partinfo[p].name = "adam2";
+ 	ar7_partinfo[p].offset = 0;
+ 	ar7_partinfo[p].size = adam2_size;
+ 	ar7_partinfo[p++].mask_flags = 0;
+ 
+-	ar7_partinfo[p].name = strdup("linux");
++	ar7_partinfo[p].name = "linux";
+ 	ar7_partinfo[p].offset = adam2_size;
+ 	ar7_partinfo[p].size = config_offset - adam2_size;
+ 	ar7_partinfo[p++].mask_flags = 0;
+@@ -205,13 +164,13 @@
+ 		printk("Setting new rootfs offset to %08x\n", rootfs_start);
+ 	}
+ 	
+-	ar7_partinfo[p].name = strdup("rootfs");
++	ar7_partinfo[p].name = "rootfs";
+ 	ar7_partinfo[p].offset = rootfs_start;
+ 	ar7_partinfo[p].size = config_offset - rootfs_start;
+ 	
+ 	ar7_partinfo[p++].mask_flags = 0;
+ 
+-	ar7_partinfo[p].name = strdup("config");
++	ar7_partinfo[p].name = "config";
+ 	ar7_partinfo[p].offset = config_offset;
+ 	ar7_partinfo[p].size = WINDOW_SIZE - config_offset;
+ 	ar7_partinfo[p++].mask_flags = 0;
+@@ -222,7 +181,7 @@
+ 
+ 		ar7_copy_from(&ar7_map, &sb, rootfs_start, sizeof(sb));
+ 		printk("Squashfs detected (size = 0x%08x)\n", sb.bytes_used);
+-		
++
+ 		newoffset = rootfs_start + sb.bytes_used;
+ 
+ 		if ((newoffset % ar7_mtd_info->erasesize) > 0)
+@@ -230,7 +189,7 @@
+ 		
+ 		ar7_partinfo[p - 2].size = newoffset - rootfs_start;
+ 		
+-		ar7_partinfo[p].name = strdup("OpenWrt");
++		ar7_partinfo[p].name = "OpenWrt";
+ 		ar7_partinfo[p].offset = newoffset;
+ 		ar7_partinfo[p].size = config_offset - newoffset;
+ 		ar7_partinfo[p++].mask_flags = 0;
+@@ -245,6 +204,36 @@
+ 	return p;
+ }
+ 
++static int __init ar7_mtd_init(void)
++{
++	int partitions;
++	
++       	printk(KERN_NOTICE "ar7 flash device: 0x%lx at 0x%lx.\n", (unsigned long)WINDOW_SIZE, (unsigned long)WINDOW_ADDR);
++	ar7_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
++
++	if (!ar7_map.map_priv_1) {
++		printk("Failed to ioremap\n");
++		return -EIO;
++	}
++	
++	ar7_mtd_info = do_map_probe("cfi_probe", &ar7_map);
++	if (!ar7_mtd_info)
++	{
++		iounmap((void *)ar7_map.map_priv_1);
++		ar7_map.map_priv_1 = 0;
++		return -ENXIO;
++	}
++	
++	ar7_mtd_info->module = THIS_MODULE;
++
++	if (!(partitions = create_mtd_partitions()))
++		add_mtd_device(ar7_mtd_info);
++	else		
++		add_mtd_partitions(ar7_mtd_info, ar7_partinfo, partitions);
++
++	return 0;
++}
++
+ static void __exit ar7_mtd_cleanup(void)
+ {
+ 	if (ar7_mtd_info) {
+diff -urN linux-2.4.32/drivers/mtd/maps/Config.in linux-2.4.32.new/drivers/mtd/maps/Config.in
+--- linux-2.4.32/drivers/mtd/maps/Config.in	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/mtd/maps/Config.in	2006-05-12 21:49:16.000000000 +0200
+@@ -49,12 +49,13 @@
+ 
+ if [ "$CONFIG_MIPS" = "y" ]; then
+     if [ "$CONFIG_AR7" = "y" ]; then
++      dep_tristate '  Flash chip mapping on Sinus 154' CONFIG_MTD_SINUS154 $CONFIG_MTD_CFI $CONFIG_MTD_PARTITIONS
+       dep_tristate '  Flash chip mapping on Texas Instruments AR7' CONFIG_MTD_AR7 $CONFIG_MTD_CFI $CONFIG_MTD_PARTITIONS
+       dep_bool     '    Use defaults for Texas Instruments AR7' CONFIG_MTD_AR7_DEFAULTS $CONFIG_MTD_AR7
+       if [ "$CONFIG_MTD_AR7" = "y" -o "$CONFIG_MTD_AR7" = "m" ]; then
+          if [ "$CONFIG_MTD_AR7_DEFAULTS" = "y" ]; then
+             define_hex CONFIG_MTD_AR7_START 0x10000000
+-            define_hex CONFIG_MTD_AR7_LEN 0x400000
++            define_hex CONFIG_MTD_AR7_LEN 0x00400000
+             define_int CONFIG_MTD_AR7_BUSWIDTH 2
+          else
+             hex '      Physical start address of flash mapping' CONFIG_MTD_AR7_START 0x10000000
+diff -urN linux-2.4.32/drivers/mtd/maps/Makefile linux-2.4.32.new/drivers/mtd/maps/Makefile
+--- linux-2.4.32/drivers/mtd/maps/Makefile	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/mtd/maps/Makefile	2006-05-12 21:49:52.000000000 +0200
+@@ -11,6 +11,7 @@
+ 
+ # Chip mappings
+ obj-$(CONFIG_MTD_AR7)		+= ar7-flash.o
++obj-$(CONFIG_MTD_SINUS154)	+= sinus154-flash.o
+ obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
+ obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
+ obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
+diff -urN linux-2.4.32/drivers/mtd/maps/sinus154-flash.c linux-2.4.32.new/drivers/mtd/maps/sinus154-flash.c
+--- linux-2.4.32/drivers/mtd/maps/sinus154-flash.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/drivers/mtd/maps/sinus154-flash.c	2006-05-18 19:47:50.000000000 +0200
+@@ -0,0 +1,225 @@
++/*
++ * $Id: 011-sinus.patch,v 1.11 2005/12/29 10:26:15 stefan Exp stefan $
++ *
++ * Normal mappings of chips in physical memory
++ */
++
++#include <linux/module.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <asm/io.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/map.h>
++#include <linux/config.h>
++#include <linux/mtd/partitions.h>
++#include <linux/squashfs_fs.h>
++
++#define WINDOW_ADDR 0x10000000
++#define WINDOW_SIZE 0x00200000
++#define BUSWIDTH 2
++
++// AR7 internal PROM at physical address 0xbfc00000, 4 KiB
++#define AR7_WINDOW_ADDR 0x1fc00000
++#define AR7_WINDOW_SIZE 0x1000
++
++static struct mtd_partition ar7_partinfo[] = {
++	{
++		name: "Boot PROM",
++		offset: 0,
++		size: AR7_WINDOW_SIZE,
++		mask_flags: MTD_WRITEABLE, /* force read-only */
++	}
++};
++
++static struct mtd_info *ar7_mtd_info;
++
++static struct mtd_partition sinus154_partinfo[] = {
++	{
++		name: "Boot",
++		offset: 0,
++		size: 0x20000,
++		mask_flags: MTD_WRITEABLE, /* force read-only */
++	},
++	{
++		name: "Configuration",
++		offset: MTDPART_OFS_APPEND,
++		size: 0x20000,
++		mask_flags: 0,
++	},
++	{
++		name: "Web Prefix",
++		offset: MTDPART_OFS_APPEND,
++		size: 0x10000,
++		mask_flags: 0,
++	},
++	{
++		name: "Web Image",
++		offset: MTDPART_OFS_APPEND,
++		size: 0xc0000,
++		mask_flags: 0,
++	},
++	{
++		name: "Code Image",
++		offset: MTDPART_OFS_APPEND,
++		size: 0xe0000,
++		mask_flags: 0,
++	},
++	{
++		name: "Boot Params",
++		offset: MTDPART_OFS_APPEND,
++		size: 0x10000,
++		mask_flags: 0,
++	},
++};
++
++static struct mtd_info *sinus154_mtd_info;
++
++static __u8 ar7_read8(struct map_info *map, unsigned long ofs)
++{
++	return __raw_readb(map->map_priv_1 + ofs);
++}
++
++static __u16 ar7_read16(struct map_info *map, unsigned long ofs)
++{
++	__u16 d = __raw_readw(map->map_priv_1 + ofs);
++	printk(KERN_DEBUG "%s(%p,0x%04x,0x%08x)\n", __FUNCTION__, map, d, map->map_priv_1 + ofs);
++	return d;
++}
++
++static __u32 ar7_read32(struct map_info *map, unsigned long ofs)
++{
++	__u32 d = __raw_readl(map->map_priv_1 + ofs);
++	printk(KERN_DEBUG "%s(%p,0x%04x,0x%08x)\n", __FUNCTION__, map, d, map->map_priv_1 + ofs);
++	return d;
++}
++
++static void ar7_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
++{
++	//~ printk(KERN_DEBUG "%s(%p,%p,0x%08x,%u)\n", __FUNCTION__, map, to, map->map_priv_1 + from, len);
++	memcpy_fromio(to, map->map_priv_1 + from, len);
++}
++
++static void ar7_write8(struct map_info *map, __u8 d, unsigned long adr)
++{
++	printk(KERN_DEBUG "%s(%p,0x%04x,0x%08x)\n", __FUNCTION__, map, d, map->map_priv_1 + adr);
++	__raw_writeb(d, map->map_priv_1 + adr);
++	mb();
++}
++
++static void ar7_write16(struct map_info *map, __u16 d, unsigned long adr)
++{
++	printk(KERN_DEBUG "%s(%p,0x%04x,0x%08x)\n", __FUNCTION__, map, d, map->map_priv_1 + adr);
++	__raw_writew(d, map->map_priv_1 + adr);
++	mb();
++}
++
++static void ar7_write32(struct map_info *map, __u32 d, unsigned long adr)
++{
++	printk(KERN_DEBUG "%s(%p,0x%04x,0x%08x)\n", __FUNCTION__, map, d, map->map_priv_1 + adr);
++	__raw_writel(d, map->map_priv_1 + adr);
++	mb();
++}
++
++static void ar7_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
++{
++	//~ printk(KERN_DEBUG "%s(%p,0x%08x,%p,%u)\n", __FUNCTION__, map, map->map_priv_1 + to, from, len);
++	memcpy_toio(map->map_priv_1 + to, from, len);
++}
++
++static struct map_info ar7_map = {
++	name: "Boot PROM",
++	size: AR7_WINDOW_SIZE,
++	buswidth: BUSWIDTH,
++	read8: ar7_read8,
++	read16: ar7_read16,
++	read32: ar7_read32,
++	copy_from: ar7_copy_from,
++	write8: ar7_write8,
++	write16: ar7_write16,
++	write32: ar7_write32,
++	copy_to: ar7_copy_to
++};
++
++static struct map_info sinus154_map = {
++	name: "Sinus 154 Flash",
++	size: WINDOW_SIZE,
++	buswidth: BUSWIDTH,
++	read8: ar7_read8,
++	read16: ar7_read16,
++	read32: ar7_read32,
++	copy_from: ar7_copy_from,
++	write8: ar7_write8,
++	write16: ar7_write16,
++	write32: ar7_write32,
++	copy_to: ar7_copy_to
++};
++
++static int __init sinus_mtd_init(void)
++{
++       	printk(KERN_NOTICE "ar7 flash device: 0x%lx at 0x%lx.\n", (unsigned long)AR7_WINDOW_SIZE, (unsigned long)AR7_WINDOW_ADDR);
++	ar7_map.map_priv_1 = (unsigned long)ioremap_nocache(AR7_WINDOW_ADDR, AR7_WINDOW_SIZE);
++
++	if (!ar7_map.map_priv_1) {
++		printk(KERN_ERR "Failed to ioremap\n");
++		return -EIO;
++	}
++	
++	ar7_mtd_info = do_map_probe("map_rom", &ar7_map);
++
++	if (!ar7_mtd_info)
++	{
++		printk(KERN_NOTICE "Sinus154 rom device: no ROM found.\n");
++		iounmap((void *)ar7_map.map_priv_1);
++		ar7_map.map_priv_1 = 0;
++		return -ENXIO;
++	}
++	
++	ar7_mtd_info->module = THIS_MODULE;
++
++	//~ add_mtd_device(ar7_mtd_info);
++	add_mtd_partitions(ar7_mtd_info, ar7_partinfo, 1);
++
++       	printk(KERN_NOTICE "Sinus154 flash device: 0x%lx at 0x%lx.\n", (unsigned long)WINDOW_SIZE, (unsigned long)WINDOW_ADDR);
++	sinus154_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
++	sinus154_mtd_info = do_map_probe("cfi_probe", &sinus154_map);
++	if (!sinus154_mtd_info) {
++		printk(KERN_WARNING "Sinus154 flash device: no flash found, using fallback to ROM map.\n");
++		sinus154_mtd_info = do_map_probe("map_rom", &sinus154_map);
++	}
++	sinus154_mtd_info->module = THIS_MODULE;
++	add_mtd_partitions(sinus154_mtd_info, sinus154_partinfo, 6);
++
++	return 0;
++}
++
++static void __exit sinus_mtd_cleanup(void)
++{
++	if (ar7_mtd_info) {
++		del_mtd_partitions(ar7_mtd_info);
++		//~ del_mtd_device(ar7_mtd_info);
++		map_destroy(ar7_mtd_info);
++	}
++
++	if (ar7_map.map_priv_1) {
++		iounmap((void *)ar7_map.map_priv_1);
++		ar7_map.map_priv_1 = 0;
++	}
++
++	if (sinus154_mtd_info) {
++		del_mtd_partitions(sinus154_mtd_info);
++		//~ del_mtd_device(sinus154_mtd_info);
++		map_destroy(sinus154_mtd_info);
++	}
++
++	if (sinus154_map.map_priv_1) {
++		iounmap((void *)sinus154_map.map_priv_1);
++		sinus154_map.map_priv_1 = 0;
++	}
++}
++
++module_init(sinus_mtd_init);
++module_exit(sinus_mtd_cleanup);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Stefan Weil");
++MODULE_DESCRIPTION("AR7 CFI map driver");
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.c linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.c
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.c	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.c	2006-05-18 20:32:20.000000000 +0200
+@@ -33,13 +33,17 @@
+ #include <asm/uaccess.h>
+ #include <linux/config.h>
+ #include <asm/ar7/if_port.h>
++#include <asm/ar7/led_hal.h>	/* avalanche_led_action, ... */
+ 
+-extern void build_psp_config(void);
+-extern void psp_config_cleanup(void);
++#include "psp_config_mgr.h"	/* build_psp_config, psp_config_cleanup */
+ 
+ #include "cpmacHalLx.h"
+ #include "cpmac.h"
+ 
++#if defined(CONFIG_AR7_LED)
++# define CONFIG_MIPS_AVALANCHE_LED
++#endif
++
+ static struct net_device *last_cpmac_device = NULL;
+ static int    cpmac_devices_installed = 0;
+ 
+@@ -158,6 +162,7 @@
+ static struct net_device_stats *cpmac_dev_get_net_stats (struct net_device *dev);
+ 
+ static int cpmac_p_dev_enable( struct net_device *p_dev);
++static void cpmac_hal_isr(int irq, void *p_param, struct pt_regs *p_cb_param);
+ 
+ 
+ 
+@@ -793,8 +798,8 @@
+ 
+ 	if(count > 30)
+ 	{
+-		printk("Error : Buffer Overflow\n");
+-		printk("Use \"echo 0 > cpmac_stat\" to reset the statistics\n");
++		printk(KERN_ERR "Error : Buffer Overflow\n");
++		printk(KERN_ERR "Use \"echo 0 > cpmac_stat\" to reset the statistics\n");
+ 		return -EFAULT;
+ 	}
+ 
+@@ -810,7 +815,7 @@
+             CPMAC_PRIVATE_INFO_T  *p_cpmac_priv;
+ 
+             /* Valid command */
+-	    printk("Resetting statistics for CPMAC interface.\n");
++	    printk(KERN_DEBUG "Resetting statistics for CPMAC interface.\n");
+ 
+             /* Reverse the the device link list to list eth0,eth1...in correct order */
+             for(i=0; i< cpmac_devices_installed; i++)
+@@ -834,8 +839,8 @@
+ 	}
+ 	else
+ 	{
+-		printk("Error: Unknown operation on cpmac statistics\n");
+-		printk("Use \"echo 0 > cpmac_stats\" to reset the statistics\n");
++		printk(KERN_ERR "Error: Unknown operation on cpmac statistics\n");
++		printk(KERN_ERR "Use \"echo 0 > cpmac_stats\" to reset the statistics\n");
+ 		return -EFAULT;
+ 	}
+ 	
+@@ -955,9 +960,9 @@
+         dbgPrint("Maintaining the link up loopback for %s.\n", p_dev->name);
+ 	netif_carrier_on(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
++#endif
+ 
+         return(0);
+     }
+@@ -972,9 +977,9 @@
+ 	{
+             netif_carrier_on(p_cpmac_priv->owner);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
++#endif
+ 	    dbgPrint("Found the Link for the CPMAC instance %s.\n", p_dev->name);
+         }
+ 
+@@ -997,9 +1002,9 @@
+ 
+ 	    netif_carrier_off(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
++#endif
+ 
+ 	    dbgPrint("Lost the Link for the CPMAC for %s.\n", p_dev->name);
+ 	}
+@@ -1318,9 +1323,9 @@
+     }
+     
+     if (p_tx_chan_info->tx_int_disable)
+-       printk("Cpmac driver Disable TX complete interrupt setting threshold to %d.\n",threshold);
++       printk(KERN_DEBUG "Cpmac driver Disable TX complete interrupt setting threshold to %d.\n",threshold);
+     else
+-       printk("Cpmac driver Enable TX complete interrupt\n");
++       printk(KERN_DEBUG "Cpmac driver Enable TX complete interrupt\n");
+ 
+     
+     /* Assuming just one rx channel for now */
+@@ -1406,7 +1411,7 @@
+     /* Read the version id of the device to check if the device really exists */
+     if( VERSION(temp_base_address[p_cpmac_priv->instance_num]) == 0)
+     {
+-        printk(" CPMAC:Device not found\n");
++        printk(KERN_WARNING "CPMAC: Device not found\n");
+ 	RESET_REG_PRCR = prev_reset_val;
+         return -ENODEV;
+     }
+@@ -1467,13 +1472,13 @@
+     if(!mac_string)
+     {
+         mac_string="08.00.28.32.06.02";
+-        printk("Error getting mac from Boot enviroment for %s\n",p_dev->name);
+-        printk("Using default mac address: %s\n",mac_string);
++        printk(KERN_WARNING "Error getting mac from Boot environment for %s\n",p_dev->name);
++        printk(KERN_WARNING "Using default mac address: %s\n",mac_string);
+         if(mac_name)
+         {
+-            printk("Use Bootloader command:\n");
+-            printk("    setenv %s xx.xx.xx.xx.xx.xx\n","<env_name>");
+-            printk("to set mac address\n");
++            printk(KERN_INFO "Use Bootloader command:\n");
++            printk(KERN_INFO "    setenv %s xx.xx.xx.xx.xx.xx\n","<env_name>");
++            printk(KERN_INFO "to set mac address\n");
+         }
+     }
+ 
+@@ -1488,13 +1493,13 @@
+     p_cpmac_priv->set_to_close          = 1;
+     p_cpmac_priv->non_data_irq_expected = 0;
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    if((p_cpmac_priv->led_handle = avalanche_led_register("cpmac", instance_num)) == NULL)
+-//   {
+-//        errPrint("Could not allocate handle for CPMAC[%d] LED.\n", instance_num);
+-//       goto cpmac_init_mod_error;
+-//    }
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    if((p_cpmac_priv->led_handle = avalanche_led_register("cpmac", instance_num)) == NULL)
++    {
++       errPrint("Could not allocate handle for CPMAC[%d] LED.\n", instance_num);
++       // goto cpmac_init_mod_error;
++    }
++#endif
+ 
+     if(cpmac_drv_init_module(p_drv_hal, p_dev, instance_num) != 0)
+     {
+@@ -1546,11 +1551,11 @@
+ 
+     netif_carrier_off(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
++#endif
+ 
+-    /* Tasklet is initialized at the isr registeration time. */
++    /* Tasklet is initialized at the isr registration time. */
+     p_drv_hal->hal_funcs->Control(p_drv_hal->hal_dev, "CpmacBase", "Get", &p_dev->base_addr);
+     p_drv_hal->hal_funcs->Control(p_drv_hal->hal_dev, "CpmacSize", "Get", &p_cpmac_priv->dev_size);
+ 
+@@ -1698,9 +1703,9 @@
+         p_cpmac_priv->link_mode         = 1;
+         netif_carrier_off(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
++#endif
+ 
+         clear_bit(0, &p_cpmac_priv->non_data_irq_expected);
+ 
+@@ -1751,10 +1756,10 @@
+     int                     val           = 1;
+     int                     channel       = 0;
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)    
+-//    if(netif_carrier_ok(p_dev))
+-//      avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)    
++    if(netif_carrier_ok(p_dev))
++      avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
++#endif
+ 
+     if(p_dev->flags & IFF_PROMISC)
+     {
+@@ -1920,9 +1925,9 @@
+         goto cpmac_dev_tx_drop_pkt; 
+     }
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_TX_ACTIVITY);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_TX_ACTIVITY);
++#endif
+ 
+     return(ret_val);
+ 
+@@ -1969,22 +1974,24 @@
+     return(ret_ptr);
+ }
+ 
+-void cpmac_hal_isr(int irq, void *p_param, struct pt_regs *regs)
++static void cpmac_hal_isr(int irq, void *p_param, struct pt_regs *regs)
+ {
+     CPMAC_ISR_INFO_T      *p_cb_param    = (CPMAC_ISR_INFO_T*) p_param;
+     CPMAC_DRV_HAL_INFO_T  *p_drv_hal     = p_cb_param->owner;
+     CPMAC_PRIVATE_INFO_T *p_cpmac_priv   = p_drv_hal->owner;
+     int                   pkts_to_handle = 0;
+ 
+-    if(p_cpmac_priv->non_data_irq_expected)
+-    {
++    printk(KERN_DEBUG "%s: irq = %d\n", __func__, irq);
++
++    if (p_cpmac_priv->non_data_irq_expected) {
+         p_cb_param->hal_isr(p_drv_hal->hal_dev, &pkts_to_handle);
+         p_drv_hal->hal_funcs->PacketProcessEnd(p_drv_hal->hal_dev);
+-    }
+-    else if(!p_cpmac_priv->set_to_close)
+-        tasklet_schedule(&((CPMAC_ISR_INFO_T*) p_param)->tasklet);
+-    else
++    } else if (!p_cpmac_priv->set_to_close) {
++	printk(KERN_DEBUG "%s: irq = %d calls tasklet_schedule\n", __func__, irq);
++        tasklet_schedule(&p_cb_param->tasklet);
++    } else {
+         ; // back off from doing anything more. We are closing down.
++    }
+ }
+ 
+ void cpmac_handle_tasklet(unsigned long data)
+@@ -2134,9 +2141,8 @@
+         /* For Sangam Mdio-switching  action should be always "set"*/
+         if(cpmac_ci_strcmp(action, hcSet) == 0 && value != NULL )
+         {
+-           unsigned  int mdix =  *((unsigned int *) value) ;
+-
+ #ifdef CONFIG_AR7_MDIX
++           unsigned  int mdix =  *((unsigned int *) value) ;
+ 	   avalanche_set_mdix_on_chip(0xa8610000 , mdix ? 1: 0);
+ #endif
+   
+@@ -2219,9 +2225,9 @@
+ 
+     netif_rx(p_skb);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_RX_ACTIVITY);	
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_RX_ACTIVITY);	
++#endif
+ 
+     p_cpmac_priv->net_dev_stats.rx_packets++;
+     p_cpmac_priv->net_dev_stats.rx_bytes += packet_size;
+@@ -2325,7 +2331,9 @@
+     //cpmac_cpu_freq = avalanche_clkc_get_freq(CLKC_MIPS);
+     cpmac_cpu_freq = CONFIG_AR7_CPU * 1000 * 1000;
+ 
+-    build_psp_config();                       
++    dbgPrint("%s:%u freq = %lu\n", __FILE__, __LINE__, (unsigned long)cpmac_cpu_freq);
++
++    build_psp_config();
+ 
+     for(unit = 0; unit < instance_count; unit++)
+     {
+@@ -2360,7 +2368,7 @@
+         
+ #if defined CONFIG_MIPS_CPMAC_INIT_BUF_MALLOC
+         g_init_enable_flag = 1;
+-        printk("Cpmac driver is allocating buffer memory at init time.\n");
++        printk(KERN_DEBUG "Cpmac driver is allocating buffer memory at init time.\n");
+ #endif
+ 
+ 	/* This section gives a default value by the number of PHY in order to
+@@ -2368,12 +2376,12 @@
+ 	{
+ 	    char *mac_port = prom_getenv("MAC_PORT"); /* Internal: 0, External: 1 */
+ 	    if(!mac_port || (0 != strcmp(mac_port, "0"))) {
+-		printk("Using the MAC with external PHY\n");
++		printk(KERN_INFO "Using the MAC with external PHY\n");
+ 		cfg_start_link_speed = _CPMDIO_NOPHY;
+ 		cpmac_max_frame_size = CPMAC_MAX_FRAME_SIZE + 4;
+ 	    }
+ 	    else {
+-		printk("Using the MAC with internal PHY\n");
++		printk(KERN_INFO "Using the MAC with internal PHY\n");
+ 		cfg_start_link_speed = CFG_START_LINK_SPEED;
+ 		cpmac_max_frame_size = CPMAC_MAX_FRAME_SIZE;
+ 	    }
+@@ -2469,9 +2477,9 @@
+       
+         cpmac_drv_cleanup(p_cpmac_priv->drv_hal);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//        avalanche_led_unregister(p_cpmac_priv->led_handle);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++        avalanche_led_unregister(p_cpmac_priv->led_handle);
++#endif
+ 	strcpy(proc_name, "avalanche/");
+         strcat(proc_name, p_dev->name);
+         proc_category_name_len = strlen(proc_name);
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.h linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.h
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.h	2006-05-19 19:04:48.000000000 +0200
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.h	2006-05-03 19:23:54.000000000 +0200
+@@ -348,7 +348,7 @@
+ 
+ 
+ void *cpmac_hal_malloc_buffer(unsigned int size, void *MemBase, unsigned int MemRange,
+-                              HAL_DEVICE *HalDev, HAL_RECEIVEINFO *HalReceiveInfo, 
++                              OS_SETUP *p_os_setup, HAL_RECEIVEINFO *HalReceiveInfo, 
+                               OS_RECEIVEINFO **OsReceiveInfo, OS_DEVICE *OsDev);
+ 
+ void cpmac_hal_tear_down_complete(OS_DEVICE*, int, int);
+@@ -360,7 +360,6 @@
+                unsigned int mode);
+ int  cpmac_hal_send_complete(OS_SENDINFO*);
+ 
+-void  cpmac_hal_isr(int irq, void *p_param, struct pt_regs *p_cb_param);
+ void  cpmac_handle_tasklet(unsigned long data);
+ 
+ inline static int cpmac_ci_strcmp(const char *s1, const char *s2)
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmacHalLx.h linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmacHalLx.h
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmacHalLx.h	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmacHalLx.h	2005-12-27 21:45:14.000000000 +0100
+@@ -22,16 +22,7 @@
+ typedef struct net_device         OS_DEVICE;
+ typedef struct sk_buff            OS_RECEIVEINFO;
+ typedef struct sk_buff            OS_SENDINFO;
+-
+-#ifdef DEBUG
+-typedef void                      HAL_RECEIVEINFO;
+-typedef void                      HAL_DEVICE;
+-typedef void                      OS_SETUP;
+-#endif
+-
+-#define OS_SETUP   void
+-#define HAL_DEVICE void
+-#define HAL_RECEIVEINFO void
++typedef struct _os_setup_s OS_SETUP;
+ 
+ #define _CPHAL_CPMAC
+  
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmdio.c linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmdio.c
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmdio.c	2006-05-18 17:54:36.000000000 +0200
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmdio.c	2006-05-09 08:43:32.000000000 +0200
+@@ -18,11 +18,9 @@
+ 
+ #include "mdio_reg.h"
+ 
+-#ifdef _CPHAL_CPMAC
+-#define mdioPrintf PhyDev->HalDev->OsFunc->Printf
+-#else
+-#define mdioPrintf printf
+-#endif
++#include <linux/kernel.h> /* printk */
++
++#define mdioPrintf printk
+ 
+ typedef struct _phy_device
+ {
+@@ -139,7 +137,7 @@
+   #define PHY_MDIX     (1<<PHY_MDIX_OFFSET)
+ 
+ static char *lstate[]={"NULL","INIT","FINDING","FOUND","NWAY_START","NWAY_WAIT","LINK_WAIT","LINKED", "LOOPBACK"};
+-static int cpMacDebug;
++static int cpMacDebug = 1;
+ 
+ /*  Local MDIO Register Macros    */
+ 
+@@ -161,7 +159,7 @@
+ *** before returning
+ ***
+ **************************************/
+-void _mdioDelayEmulate(PHY_DEVICE *PhyDev, int ClockWait)
++static void _mdioDelayEmulate(PHY_DEVICE *PhyDev, int ClockWait)
+   {
+ #ifdef _CPHAL_CPMAC                                                  /*+RC3.02*/
+   HAL_DEVICE *HalDev = PhyDev->HalDev;                               /*+RC3.02*/
+@@ -175,14 +173,14 @@
+ #endif
+   }
+ 
+-void _mdioWaitForAccessComplete(PHY_DEVICE *PhyDev)
++static void _mdioWaitForAccessComplete(PHY_DEVICE *PhyDev)
+   {
+   while((myMDIO_USERACCESS & MDIO_USERACCESS_GO)!=0)
+     {
+     }
+   }
+ 
+-void _mdioUserAccess(PHY_DEVICE *PhyDev, bit32u method, bit32u regadr, bit32u phyadr, bit32u data)
++static void _mdioUserAccess(PHY_DEVICE *PhyDev, bit32u method, bit32u regadr, bit32u phyadr, bit32u data)
+   {
+   bit32u  control;
+ 
+@@ -206,7 +204,7 @@
+ ***        to be consistent with rest of the code.
+ ***
+ **************************************/
+-bit32u _mdioUserAccessRead(PHY_DEVICE *PhyDev, bit32u regadr, bit32u phyadr)
++static bit32u _mdioUserAccessRead(PHY_DEVICE *PhyDev, bit32u regadr, bit32u phyadr)
+   {
+ 
+   _mdioWaitForAccessComplete(PhyDev);  /* Wait until UserAccess ready */
+@@ -222,13 +220,13 @@
+ *** Waits for MDIO_USERACCESS to be ready and writes data
+ ***
+ **************************************/
+-void _mdioUserAccessWrite(PHY_DEVICE *PhyDev, bit32u regadr, bit32u phyadr, bit32u data)
++static void _mdioUserAccessWrite(PHY_DEVICE *PhyDev, bit32u regadr, bit32u phyadr, bit32u data)
+   {
+   _mdioWaitForAccessComplete(PhyDev);  /* Wait until UserAccess ready */
+   _mdioUserAccess(PhyDev, MDIO_USERACCESS_WRITE, regadr, phyadr, data);
+   }
+ 
+-void _mdioDumpPhyDetailed(PHY_DEVICE *PhyDev)
++static void _mdioDumpPhyDetailed(PHY_DEVICE *PhyDev)
+ {
+   bit32u *PhyState = &PhyDev->PhyState;
+   bit32u  PhyNum;
+@@ -237,7 +235,7 @@
+   PhyNum=(*PhyState&PHY_DEV_MASK)>>PHY_DEV_OFFSET;
+ 
+   RegData = _mdioUserAccessRead(PhyDev, 0, PhyNum);
+-  mdioPrintf("PhyControl: %04X, Lookback=%s, Speed=%s, Duplex=%s\n",
++  mdioPrintf("PhyControl: %04X, Loopback=%s, Speed=%s, Duplex=%s\n",
+     RegData,
+     RegData&PHY_LOOP?"On":"Off",
+     RegData&PHY_100?"100":"10",
+@@ -309,13 +307,13 @@
+   }
+ 
+ 
+-void _mdioResetPhy(PHY_DEVICE *PhyDev,bit32u PhyNum)
++static void _mdioResetPhy(PHY_DEVICE *PhyDev,bit32u PhyNum)
+   {
+   bit16u PhyControlReg;
+ 
+   _mdioUserAccessWrite(PhyDev, PHY_CONTROL_REG, PhyNum, PHY_RESET);
+   if (cpMacDebug)
+-    mdioPrintf("cpMacMdioPhYReset(%d)\n",PhyNum);
++    mdioPrintf("cpMacMdioPhyReset(%d)\n",PhyNum);
+ 
+   /* Read control register until Phy Reset is complete */
+   do
+@@ -325,7 +323,7 @@
+    while (PhyControlReg & PHY_RESET); /* Wait for Reset to clear */
+   }
+ 
+-void _mdioDisablePhy(PHY_DEVICE *PhyDev,bit32u PhyNum)
++static void _mdioDisablePhy(PHY_DEVICE *PhyDev,bit32u PhyNum)
+   {
+   _mdioUserAccessWrite(PhyDev, PHY_CONTROL_REG, PhyNum, PHY_ISOLATE|PHY_PDOWN);
+ 
+@@ -334,7 +332,7 @@
+ 
+   }
+ 
+-void _MdioInitState(PHY_DEVICE *PhyDev)
++static void _MdioInitState(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState = &PhyDev->PhyState;
+   bit32u CurrentState;
+@@ -350,7 +348,7 @@
+ 
+   }
+ 
+-void _MdioFindingState(PHY_DEVICE *PhyDev)
++static void _MdioFindingState(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState = &PhyDev->PhyState;
+   bit32u  PhyMask  = PhyDev->PhyMask;
+@@ -389,7 +387,7 @@
+     }
+   }
+ 
+-void _MdioFoundState(PHY_DEVICE *PhyDev)
++static void _MdioFoundState(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState  = &PhyDev->PhyState;
+   bit32u  PhyMask   = PhyDev->PhyMask;
+@@ -508,7 +506,7 @@
+      _mdioMdixDelay(PhyDev);  /* If AutoMdix add delay */
+   }
+ 
+-void _MdioNwayStartState(PHY_DEVICE *PhyDev)
++static void _MdioNwayStartState(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState = &PhyDev->PhyState;
+   bit32u PhyNum,PhyMode;
+@@ -535,7 +533,7 @@
+     }
+   }
+ 
+-void _MdioNwayWaitState(PHY_DEVICE *PhyDev)
++static void _MdioNwayWaitState(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState = &PhyDev->PhyState;
+   bit32u  PhyNum,PhyStatus,NWAYadvertise,NWAYREadvertise,NegMode,i,j;
+@@ -779,7 +777,7 @@
+   _mdioDumpState(PhyDev);
+   }
+ 
+-/* cpMacMdioTic is called every 10 mili seconds to process Phy states         */
++/* cpMacMdioTic is called every 10 milliseconds to process Phy states         */
+ 
+ int cpMacMdioTic(PHY_DEVICE *PhyDev)
+   {
+@@ -840,7 +838,7 @@
+   return((*PhyState&PHY_DUPLEX_MASK)?1:0);  /* return 0 or a 1  */
+   }
+ 
+-/* cpMacMdioGetSpeed is called to retreive the Speed info                     */
++/* cpMacMdioGetSpeed is called to retrieve the Speed info                     */
+ 
+ int cpMacMdioGetSpeed(PHY_DEVICE *PhyDev)
+   {
+@@ -848,7 +846,7 @@
+   return(*PhyState&PHY_SPEED_MASK);
+   }
+ 
+-/* cpMacMdioGetPhyNum is called to retreive the Phy Device Adr info           */
++/* cpMacMdioGetPhyNum is called to retrieve the Phy Device Adr info           */
+ 
+ int cpMacMdioGetPhyNum(PHY_DEVICE *PhyDev)
+   {
+@@ -871,6 +869,7 @@
+   return((*PhyState&PHY_STATE_MASK)==LINKED);
+   }
+ 
++#if 0 /* unused */
+ void cpMacMdioLinkChange(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState = &PhyDev->PhyState;
+@@ -897,6 +896,7 @@
+       }
+     }
+   }
++#endif
+ 
+ void cpMacMdioGetVer(bit32u miibase, bit32u *ModID,  bit32u *RevMaj,  bit32u *RevMin)
+   {
+@@ -915,7 +915,7 @@
+   }
+ 
+   /* returns 0 if current Phy has AutoMdix support, otherwise 0 */
+-int _mdioMdixSupported(PHY_DEVICE *PhyDev)
++static int _mdioMdixSupported(PHY_DEVICE *PhyDev)
+   {
+   bit32u *PhyState = &PhyDev->PhyState;
+   bit32u PhyNum;
+@@ -931,7 +931,7 @@
+   }
+ 
+ /* If current Phy has AutoMdix support add Mdix Delay to the Timer State Value */
+-void _mdioMdixDelay(PHY_DEVICE *PhyDev)
++static void _mdioMdixDelay(PHY_DEVICE *PhyDev)
+   {
+   int Delay;
+   bit32u *PhyState = &PhyDev->PhyState;  
+@@ -956,5 +956,3 @@
+   *PhyState |=  (Delay<<PHY_TIM_OFFSET);     /* Set new value */
+ #endif
+   }
+-
+-
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/hcpmac.c linux-2.4.32.new/drivers/net/avalanche_cpmac/hcpmac.c
+--- linux-2.4.32/drivers/net/avalanche_cpmac/hcpmac.c	2006-05-18 17:54:36.000000000 +0200
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/hcpmac.c	2006-05-10 23:01:45.000000000 +0200
+@@ -1,3 +1,5 @@
++#warning needed?
++
+ /******************************************************************************
+  *  TNETDxxxx Software Support
+  *  Copyright (c) 2002-2004 Texas Instruments Incorporated. All Rights Reserved.
+@@ -54,7 +56,6 @@
+ #include "hcpmac.h"
+ #include "cpmac_reg.h"
+ 
+-
+ #define EC_MODULE
+ 
+ /* MDIO Clock Frequency Default Value */
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/psp_config_build.c linux-2.4.32.new/drivers/net/avalanche_cpmac/psp_config_build.c
+--- linux-2.4.32/drivers/net/avalanche_cpmac/psp_config_build.c	2006-05-19 19:57:19.000000000 +0200
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/psp_config_build.c	2006-05-18 21:30:33.000000000 +0200
+@@ -1,3 +1,5 @@
++#if 1
++#warning check
+ /******************************************************************************
+  * FILE PURPOSE:    PSP Config Manager - Configuration Build Source
+  ******************************************************************************
+@@ -10,7 +12,6 @@
+  *
+  * (C) Copyright 2002, Texas Instruments, Inc
+  *******************************************************************************/
+-
+ #ifdef INCLUDE_FFS
+ #include "ffs.h"
+ #endif /* INCLUDE_FFS */
+@@ -127,16 +128,19 @@
+             phy_sel = SELECT_INT_PHY_MAC;
+         }
+ 
++	printk(KERN_DEBUG "%s:%d detected cpmac_phy = %d\n",
++		__FILE__, __LINE__, auto_detect_cpmac_phy());
++
+         //if(phy_sel == auto_detect_cpmac_phy())
+         if(!mac_port || (0 != strcmp(mac_port, "0")))
+         {
+-            printk("Using the MAC with external PHY\n");
++            printk(KERN_DEBUG "Using the MAC with external PHY\n");
+             psp_config_add("cpmdio", s3, psp_config_strlen(s3), en_compile);
+             psp_config_add("cpmac", s6, psp_config_strlen(s6), en_compile);
+         }
+         else
+         {
+-            printk("Using the MAC with internal PHY\n");
++            printk(KERN_DEBUG "Using the MAC with internal PHY\n");
+             psp_config_add("cpmdio", s3, psp_config_strlen(s3), en_compile);
+             psp_config_add("cpmac", s4, psp_config_strlen(s4), en_compile);
+         }
+@@ -332,4 +336,4 @@
+     dump_device_cfg_pool();
+ 
+ }
+-
++#endif
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/Makefile linux-2.4.32.new/drivers/net/avalanche_cpmac/Makefile
+--- linux-2.4.32/drivers/net/avalanche_cpmac/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -5,22 +5,8 @@
+ 
+ O_TARGET := avalanche_cpmac.o
+ 
+-
+-list-multi := avalanche_cpmac.o
+-obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) := avalanche_cpmac.o
+-
+-avalanche_cpmac-objs += cpmac.o            cpmacHalLx.o       hcpmac.o \
+-                        	      psp_config_build.o psp_config_mgr.o            \
+-				      psp_config_parse.o psp_config_util.o
+-
++obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) := cpmac.o cpmacHalLx.o hcpmac.o
++obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) += psp_config_build.o psp_config_mgr.o
++obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) += psp_config_parse.o psp_config_util.o
+ 
+ include $(TOPDIR)/Rules.make
+-
+-
+-avalanche_cpmac.o:        $(avalanche_cpmac-objs)
+-	$(LD) -r -o $@ $(avalanche_cpmac-objs)
+-
+-
+-
+-clean:
+-	rm -f core *.o *.a *.s
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/psp_config_mgr.h linux-2.4.32.new/drivers/net/avalanche_cpmac/psp_config_mgr.h
+--- linux-2.4.32/drivers/net/avalanche_cpmac/psp_config_mgr.h	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/psp_config_mgr.h	2005-12-27 21:44:16.000000000 +0100
+@@ -105,6 +105,8 @@
+   -------------------------------------------------------------------------*/
+ void  psp_config_print(char *key);
+ 
++void  psp_config_cleanup(void);
++
+ void  dump_device_cfg_pool(void);
+ 
+ #endif /* __PSP_CONFIG_MGR_H__ */
+diff -urN linux-2.4.32/drivers/net/wireless/Config.in linux-2.4.32.new/drivers/net/wireless/Config.in
+--- linux-2.4.32/drivers/net/wireless/Config.in	2004-11-17 12:54:21.000000000 +0100
++++ linux-2.4.32.new/drivers/net/wireless/Config.in	2005-12-27 21:44:16.000000000 +0100
+@@ -38,6 +38,7 @@
+ 
+ # yes, this works even when no drivers are selected
+ if [ "$CONFIG_ISA" = "y" -o "$CONFIG_PCI" = "y" -o \
++     "$CONFIG_AR7_VLYNQ" = "y" -o \
+      "$CONFIG_ALL_PPC" = "y" -o "$CONFIG_PCMCIA" != "n" ]; then
+    define_bool CONFIG_NET_WIRELESS y
+ else
+diff -urN linux-2.4.32/include/asm-mips/ar7/ar7.h linux-2.4.32.new/include/asm-mips/ar7/ar7.h
+--- linux-2.4.32/include/asm-mips/ar7/ar7.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/ar7.h	2005-12-27 21:45:12.000000000 +0100
+@@ -24,8 +24,6 @@
+ #include <asm/addrspace.h>
+ #include <linux/config.h>
+ 
+-#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(CONFIG_AR7_MEMORY))
+-
+ #define AR7_UART0_REGS_BASE (KSEG1ADDR(0x08610E00))
+ #define AR7_UART1_REGS_BASE (KSEG1ADDR(0x08610F00))
+ #define AR7_BASE_BAUD ( 3686400 / 16 )
+diff -urN linux-2.4.32/fs/partitions/msdos.c linux-2.4.32.new/fs/partitions/msdos.c
+--- linux-2.4.32/fs/partitions/msdos.c  2002-11-29 00:53:15.000000000 +0100
++++ linux-2.4.32.new/fs/partitions/msdos.c      2006-03-06 21:00:34.000000000 +0100
+@@ -27,6 +27,7 @@
+ #include <linux/string.h>
+ #include <linux/blk.h>
+
++#ifdef CONFIG_MSDOS_PARTITION
+ #ifdef CONFIG_BLK_DEV_IDE
+ #include <linux/ide.h> /* IDE xlate */
+ #elif defined(CONFIG_BLK_DEV_IDE_MODULE)
+@@ -639,3 +640,4 @@
+        put_dev_sector(sect);
+        return 1;
+ }
++#endif /* CONFIG_MSDOS_PARTITION */
+diff -urN linux-2.4.32/include/asm-mips/ar7/avalanche_intc.h linux-2.4.32.new/include/asm-mips/ar7/avalanche_intc.h
+--- linux-2.4.32/include/asm-mips/ar7/avalanche_intc.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/avalanche_intc.h	2005-12-27 21:45:06.000000000 +0100
+@@ -27,6 +27,7 @@
+ #define _AVALANCHE_INTC_H
+ 
+ #include <linux/config.h>
++#include "sangam.h"
+ 
+ /* ----- */
+ 
+@@ -34,7 +35,6 @@
+ #define KSEG_INV_MASK               0x1FFFFFFF /* Inverted mask for kseg address */
+ #define PHYS_ADDR(addr)             ((addr) & KSEG_INV_MASK)
+ #define PHYS_TO_K1(addr)            (PHYS_ADDR(addr)|KSEG1_BASE)
+-#define AVALANCHE_INTC_BASE PHYS_TO_K1(0x08612400)
+ 
+ /* ----- */
+ 
+@@ -285,8 +285,4 @@
+ 
+ #define EMIF_INT                    (7 + PRIMARY_INTS)
+ 
+-
+-extern void avalanche_int_set(int channel, int line);
+-
+-
+ #endif /* _AVALANCHE_INTC_H */
+diff -urN linux-2.4.32/include/asm-mips/ar7/avalanche_misc.h linux-2.4.32.new/include/asm-mips/ar7/avalanche_misc.h
+--- linux-2.4.32/include/asm-mips/ar7/avalanche_misc.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/avalanche_misc.h	2005-12-27 21:44:16.000000000 +0100
+@@ -79,6 +79,12 @@
+ 
+ typedef int (*REMOTE_VLYNQ_DEV_RESET_CTRL_FN)(unsigned int reset_module, AVALANCHE_RESET_CTRL_T reset_ctrl);
+ 
++int avalanche_reset_ctrl(unsigned int module_reset_bit, 
++			 AVALANCHE_RESET_CTRL_T reset_ctrl);
++ 
++/* ar7/misc.c */
++extern REMOTE_VLYNQ_DEV_RESET_CTRL_FN p_remote_vlynq_dev_reset_ctrl;
++
+ /*****************************************************************************
+  * Power Control Module
+  *****************************************************************************/
+diff -urN linux-2.4.32/include/asm-mips/ar7/tnetd73xx_misc.h linux-2.4.32.new/include/asm-mips/ar7/tnetd73xx_misc.h
+--- linux-2.4.32/include/asm-mips/ar7/tnetd73xx_misc.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/tnetd73xx_misc.h	2005-12-27 21:44:16.000000000 +0100
+@@ -17,6 +17,8 @@
+ #ifndef __TNETD73XX_MISC_H__
+ #define __TNETD73XX_MISC_H__
+ 
++#include <asm/ar7/tnetd73xx_err.h> /* TNETD73XX_ERR */
++
+ /*****************************************************************************
+  * Reset Control Module
+  *****************************************************************************/
+diff -urN linux-2.4.32/include/asm-mips/ar7/vlynq_hal.h linux-2.4.32.new/include/asm-mips/ar7/vlynq_hal.h
+--- linux-2.4.32/include/asm-mips/ar7/vlynq_hal.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/vlynq_hal.h	2005-12-27 21:44:16.000000000 +0100
+@@ -598,9 +598,8 @@
+ GLOBAL INT32 vlynq_interrupt_disable(VLYNQ_DEV * pdev,
+                                      VLYNQ_DEV_TYPE dev,
+                                      UINT32 map_vector);
+-                 
+ 
+-              
+-        
++/* vlynq_drv.h */
++extern VLYNQ_DEV vlynqDevice0, vlynqDevice1;
+ 
+ #endif /* _VLYNQ_HAL_H_ */
+diff -urN linux-2.4.32/include/asm-mips/bootinfo.h linux-2.4.32.new/include/asm-mips/bootinfo.h
+--- linux-2.4.32/include/asm-mips/bootinfo.h	2005-12-29 11:23:22.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/bootinfo.h	2005-12-27 21:46:52.000000000 +0100
+@@ -37,6 +37,8 @@
+ #define MACH_GROUP_HP_LJ       20 /* Hewlett Packard LaserJet               */
+ #define MACH_GROUP_LASAT       21
+ #define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
++#define MACH_GROUP_AR531X      23 /* Atheros AR531X                         */
++#define MACH_GROUP_AR7         24 /* TI AR7 (Sangam) based Boards           */
+ 
+ /*
+  * Valid machtype values for group unknown (low order halfword of mips_machtype)
+@@ -201,6 +203,23 @@
+  */
+ #define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
+ 
++/*
++ * Valid machtype for group AR7 (SANGAM)
++ */
++#define MACH_AR7_ADAM2          0       /* ADAM2 based Boards */
++#define MACH_AR7_SINUS154       1       /* Sinus 154 DSL Basic SE / Basic 3 */
++
++/*
++ * Valid machtype for group MACH_GROUP_AR5312
++ */
++#define MACH_ATHEROS_UNUSED     0
++#define MACH_ATHEROS_AP30       1       /* AP30 */
++#define MACH_ATHEROS_AP33	2       /* AP33 */
++#define MACH_ATHEROS_AP38       3       /* AP38 */
++#define MACH_ATHEROS_AP43       4       /* AP43 */
++#define MACH_ATHEROS_AP48       5       /* AP48 */
++#define MACH_ATHEROS_PB32       6       /* PB32 */
++
+ #define CL_SIZE			(256)
+ 
+ const char *get_system_type(void);
Index: target/linux/ar7-2.4/Makefile
===================================================================
--- target/linux/ar7-2.4/Makefile	(Revision 3803)
+++ target/linux/ar7-2.4/Makefile	(Arbeitskopie)
@@ -11,13 +11,13 @@
 ATM_FIRMWARE_DIR=sangam-atm-firmware-$(ATM_FIRMWARE_VERSION)
 
 $(eval $(call KMOD_template,SANGAM_ATM_A,sangam-atm-annex-a,\
-	$(MODULES_DIR)/kernel/drivers/atm/tiatm.o \
+	$(MODULES_DIR)/kernel/drivers/atm/sangam_atm/tiatm.o \
 ,CONFIG_MIPS_SANGAM_ATM,kmod-atm,60,tiatm, \
 	$(CP) $(BUILD_DIR)/$(ATM_FIRMWARE_DIR)/ar0700xx_a.bin $$(I_SANGAM_ATM_A)/lib/modules/ar0700xx.bin \
 ))
 
 $(eval $(call KMOD_template,SANGAM_ATM_B,sangam-atm-annex-b,\
-	$(MODULES_DIR)/kernel/drivers/atm/tiatm.o \
+	$(MODULES_DIR)/kernel/drivers/atm/sangam_atm/tiatm.o \
 ,CONFIG_MIPS_SANGAM_ATM,kmod-atm,60,tiatm, \
 	$(CP) $(BUILD_DIR)/$(ATM_FIRMWARE_DIR)/ar0700xx_b.bin $$(I_SANGAM_ATM_B)/lib/modules/ar0700xx.bin \
 ))
Index: target/linux/package/base-files/files/ar7-2.4/etc/config/network
===================================================================
--- target/linux/package/base-files/files/ar7-2.4/etc/config/network	(Revision 3803)
+++ target/linux/package/base-files/files/ar7-2.4/etc/config/network	(Arbeitskopie)
@@ -4,7 +4,7 @@
 ## LAN configuration
 lan_ifname="eth0"
 lan_proto="static"
-lan_ipaddr="192.168.1.1"
+lan_ipaddr="192.168.2.1"
 lan_netmask="255.255.255.0"
 # lan_gateway=""
 # lan_dns=""
Index: target/utils/src/mkfirm.c
===================================================================
--- target/utils/src/mkfirm.c	(Revision 0)
+++ target/utils/src/mkfirm.c	(Revision 0)
@@ -0,0 +1,305 @@
+/* $Id: mkfirm.c,v 1.1 2005/09/01 20:49:08 stefan Exp stefan $
+ *
+ * Original version by Petr Novak for SMC7004ABR rev.2
+ * Modified to support SMC7004VWBR PN720.x version by BLFC from Openline ISP.
+ *
+ * Heavily modified to support many different devices and enhanced firmware
+ * formats by Stefan Weil.
+ *
+ * This software is distributed under the GNU public license (GPL).
+ */
+
+#include <assert.h>	// assert
+#include <stdio.h>
+#include <stdlib.h>	// exit
+#include <string.h>
+#include <unistd.h>	// getopt
+#include <sys/types.h>
+#include <fcntl.h>
+
+/*
+
+Format of BRN firmware files
+
+emergency firmware
+00000000 data block 1	
+00015400 data block 2
+00016800 signature
+00016c00 end
+
+data block 1
+	data (zipped pfs.img)
+	(n) 0xff fill bytes
+	(4) length of data (little endian)
+	(4) magic number 0x12345678 (little endian)
+	(4) CRC-32 of data
+data block 2
+	data (zipped soho.img)
+	(n) 0xff fill bytes
+	(4) length of data (little endian)
+	(4) magic number 0x12345678 (little endian)
+	(4) CRC-32 of data
+(10) signature
+
+Format of zipped data
+
+ 0  (2) 'PK' magic (error 4)
+ 2  (1) 3 (error 4)
+    (1) 4 (error 4)
+ 4  (3)
+ 7  (1) bit0 == 0 (error 5)
+ 8  (2) 8 (little endian) (error 6)
+10  (8)
+18  (4) length of zipped data
+22  (4) length of unzipped data (?)
+26  (2) length of filename (little endian)
+28  (2) offset of filename (little endian)
+(n) filename
+(n) zipped data
+(2) 'PK'
+
+*/
+
+typedef unsigned long uint32_t;
+
+#if !defined(O_BINARY)
+# define O_BINARY 0
+#endif
+
+static uint32_t crc_32_tab[256];
+
+/*
+ * Code to compute the CRC-32 table. Borrowed from 
+ * gzip-1.0.3/makecrc.c.
+ */
+
+static void
+makecrc(void)
+{
+/* Not copyrighted 1990 Mark Adler	*/
+
+  uint32_t c;      /* crc shift register */
+  uint32_t e;      /* polynomial exclusive-or pattern */
+  int i;           /* counter for all possible eight bit values */
+  int k;           /* byte being shifted into crc apparatus */
+
+  /* terms of polynomial defining this crc (except x^32): */
+  static const int p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* Make exclusive-or pattern from polynomial */
+  e = 0;
+  for (i = 0; i < sizeof(p)/sizeof(int); i++)
+    e |= 1L << (31 - p[i]);
+
+  crc_32_tab[0] = 0;
+
+  for (i = 1; i < 256; i++)
+  {
+    c = 0;
+    for (k = i | 256; k != 1; k >>= 1)
+    {
+      c = c & 1 ? (c >> 1) ^ e : c >> 1;
+      if (k & 1)
+        c ^= e;
+    }
+    crc_32_tab[i] = c;
+  }
+}
+
+static uint32_t comp_crc(unsigned char *p, uint32_t len)
+{
+	uint32_t crc = 0xFFFFFFFFUL;
+
+	while (len--) {
+		crc = crc_32_tab[(crc ^ *p++) & 0xff] ^ (crc >> 8);
+	}
+	assert((crc ^ 0xFFFFFFFFUL) == ~crc);
+	return crc ^ 0xFFFFFFFFUL;
+}
+
+typedef struct {
+	const char magic[10];
+	const char *description;
+	size_t pfs_size;
+	size_t soho_size;
+} device_t;
+
+#define KiB 1024
+#define MiB (KiB * KiB)
+
+/* Please note:
+ * Not all entries in the following device table could be verified.
+ * Unknown values are marked with BRN??? or 0 * KiB.
+ */
+
+static const device_t device[] = {
+	// 3COM 11g?
+	// BUFFALO BBR-4HG
+	// A123456789 = AR4502GW = 154BAS???
+	// http://hri.sourceforge.net/hw/smc7004abr/
+	{"BRNABR", "SMC7004ABR V2", 576 * KiB, 192 * KiB},
+	// http://hri.sourceforge.net/hw/smc7004vbr/
+	{"BRN???", "SMC7004VBR", 0 * KiB, 0 * KiB},	
+	// http://hri.sourceforge.net/SMC7004/
+	{"BRNAW", "SMC7004VWBR", 0x30000, 0xbb800},
+	// http://hri.sourceforge.net/hw/index.html
+	{"BRN???", "SMC7004FW", 0 * KiB, 0 * KiB},	
+	{"BRN???", "SMC7004WFW", 0 * KiB, 0 * KiB},	
+	// http://hri.sourceforge.net/hw/smc2804wbr/
+	{"BRN2804W", "SMC2804WBR V1", 0 * KiB, 0 * KiB},	
+	// http://hri.sourceforge.net/hw/northq9100/
+	{"BRN6104V2", "NorthQ9100", 0x30000, 0x90000},
+	//{"BRN154BAS", "Sinus 154 DSL Basic SE", 0x30000, 0xbb800},
+	{"BRN154BAS", "Sinus 154 DSL Basic SE", 832 * KiB, 896 * KiB},
+	{"BRNDTBAS3", "Sinus 154 DSL Basic 3", 832 * KiB, 896 * KiB},
+	{"BRN154DSL", "Sinus 154 DSL", 0 * KiB, 0 * KiB},
+	{"BRN154KOM", "Sinus 154 DSL Komfort", 0 * KiB, 0 * KiB},
+	{"", 0}
+};
+
+/* buffer must be large enough to contain pfs + soho + signature */
+static unsigned char buffer[4 * MiB];
+
+static char signature[10];
+
+static const char *program_name;
+
+static void usage(void)
+{
+	const device_t *dev;
+	fprintf(stderr, "Usage: %s [-h|-?]\n", program_name);
+	fprintf(stderr, "  or:  %s [-o <outfile>] [-l <blocksize>] -m <magic> <zipfile>\n", program_name);
+	fprintf(stderr, "  or:  %s [-o <outfile>] [-l <blocksize>] -m <magic> <pfsfile> <sohofile>\n", program_name);
+	fprintf(stderr, "<magic>:     any of the following\n");
+	for (dev = device; ; dev++) {
+		const char *magic = dev->magic;
+		const char *description = dev->description;
+		if (*magic == 0) break;
+		fprintf(stderr, "\t%-10s%s\n", magic, description);
+	}
+	fprintf(stderr, "<zipfile>:   zipped file with code or user interface\n");
+	fprintf(stderr, "<pfsfile>:   zipped file with user interface (pfs.img)\n");
+	fprintf(stderr, "<sohofile>:  zipped file with code (soho.bin)\n");
+	fprintf(stderr, "<outfile>:   write result into this file\n");
+	fprintf(stderr, "<blocksize>: size of flash blocks (default: 65536)\n");
+}
+
+static unsigned char *write_data(const char *filename, unsigned char *buffer, uint32_t max_size)
+{
+	uint32_t *p;
+	uint32_t crc;
+	uint32_t len;
+	int fd = open(filename, O_RDONLY|O_BINARY);
+	if (fd < 0) {
+		perror(filename);
+		exit(1);
+	}
+	len = read(fd, buffer, max_size);
+	close(fd);
+	fprintf(stderr, "%s has %lu (0x%lx) bytes, %lu bytes left\n", filename, len, len, max_size - len);
+	crc = comp_crc(buffer, len);
+	max_size = ((len + 0x7fff) & 0xffff8000);
+	fprintf(stderr, "%s uses %lu (0x%lx) bytes = %lu KiB, %lu bytes left\n",
+			filename, max_size, max_size, max_size / 1024, max_size - len);
+	if (strncmp((char *)buffer, "PK", 2) != 0) {
+		fprintf(stderr, "%s is no zip file\n", filename);
+	}
+	p = (uint32_t *)(buffer + max_size - 3 * 4);
+	*p++ = len;
+	*p++ = 0x12345678;
+	*p++ = crc;
+	return (unsigned char *)p;
+}
+
+int main(int argc, char *argv[])
+{
+	unsigned char *p;
+	int fd;
+	
+	const char *magic = 0;
+	const char *pfs_file;
+	const char *soho_file;
+	const char *output_file = 0;
+
+	const device_t *dev;
+	size_t pfs_size;
+	size_t soho_size;
+	size_t total_size;
+	size_t block_size = 65536;
+
+	program_name = argv[0];
+
+	for (;;) {
+		int option = getopt(argc, argv, "?hmo");
+		if (option == -1) {
+			break;
+		} else if (option == '?' || option == 'h') {
+			usage();
+			exit(0);
+		} else if (option == 'l') {
+			block_size = strtoul(argv[optind++], 0, 0);
+		} else if (option == 'm') {
+			magic = argv[optind++];
+		} else if (option == 'o') {
+			output_file = argv[optind++];
+		} else {
+			usage();
+			exit(1);
+		}
+	}
+
+	if (((optind + 1 != argc) && (optind + 2 != argc)) || magic == 0) {
+		usage();
+		exit(1);
+	}
+
+	pfs_file = argv[optind++];
+	soho_file = argv[optind++];
+
+	for (dev = device; ; dev++) {
+		if (*dev->magic == 0) {
+			usage();
+			exit(2);
+		}
+		if (strcmp(magic, dev->magic) == 0) break;
+	}
+
+	pfs_size = dev->pfs_size;
+	soho_size = dev->soho_size;
+	total_size = pfs_size + soho_size + sizeof(signature);
+	strncpy(signature, magic, 10);
+
+	if (total_size > sizeof(buffer)) {
+		fprintf(stderr, "buffer too small, needs %lu bytes, has %lu bytes\n",
+			(unsigned long)total_size, (unsigned long)sizeof(buffer));
+		exit(3);
+	}
+
+	makecrc();
+	memset(buffer, 0xff, total_size);
+
+	p = buffer;
+	p = write_data(pfs_file, p, pfs_size);
+
+	if (soho_file != 0) {
+		p = write_data(soho_file, p, soho_size);
+	}
+
+	memcpy(p, signature, 10);
+
+	total_size = (p - buffer) + sizeof(signature);
+	
+	if (output_file != 0) {
+		fd = open(output_file, O_CREAT|O_WRONLY|O_TRUNC|O_BINARY, 0666);
+		if (fd < 0) {
+			perror(pfs_file);
+			exit(1);
+		}
+		write(fd, buffer, total_size);
+		close(fd);
+	} else if (!isatty(1)) {
+		write(1, buffer, total_size);
+	}
+
+	return 0;
+}
Index: target/utils/Makefile
===================================================================
--- target/utils/Makefile	(Revision 3803)
+++ target/utils/Makefile	(Arbeitskopie)
@@ -1,6 +1,9 @@
 include $(TOPDIR)/rules.mk
 
 TARGETS := addpattern trx motorola-bin dgfirmware
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+TARGETS	+= mkfirm
+endif
 
 UTILS_BUILD_DIR:=$(BUILD_DIR)/target-utils
 
Index: target/Config.in
===================================================================
--- target/Config.in	(Revision 3803)
+++ target/Config.in	(Arbeitskopie)
@@ -58,7 +58,7 @@
 	bool "TI AR7 [2.4]"
 	select BR2_mipsel
 	help
-	  Build firmware images for TI AR7 based routers (w.g. Linksys WAG54G v2)
+	  Build firmware images for TI AR7 based routers (e.g. Linksys WAG54G v2)
 
 config BR2_LINUX_2_4_X86
 	bool "x86 [2.4]"
@@ -128,6 +128,57 @@
 
 endchoice
 
+choice
+	prompt "Device selection"
+
+	config BR2_LINUX_2_4_WAX
+		bool "Support for Linksys boards"
+		depends BR2_LINUX_2_4_AR7
+		help
+		  Build firmware images for Linksys AG1B, WA22, WAG2, WA21, WA32
+
+	config BR2_LINUX_2_4_GIGASET
+		bool "Support for Siemens Gigaset boards"
+		depends BR2_LINUX_2_4_AR7
+		help
+		  Build firmware images for Siemens AR7 based boards
+
+	config BR2_LINUX_2_4_SINUS154
+		bool "Support for T-Com Sinus 154 boards"
+		depends BR2_LINUX_2_4_AR7
+		#select BUSYBOX_CONFIG_CMP
+		#select BUSYBOX_CONFIG_OD
+		#select BUSYBOX_CONFIG_RX
+		help
+		  Build firmware images for T-Com AR7 based boards
+	
+endchoice
+
+menu "Device variants"
+
+	config BR2_LINUX_2_4_SINUS154_DSL_BASIC_SE
+		bool "Support for Sinus 154 DSL Basic SE"
+		default y
+		depends BR2_LINUX_2_4_SINUS154
+		help
+		  Build firmware image for T-Com Sinus 154 DSL Basic SE
+	
+	config BR2_LINUX_2_4_SINUS154_DSL_BASIC_3
+		bool "Support for Sinus 154 DSL Basic 3"
+		default n
+		depends BR2_LINUX_2_4_SINUS154
+		help
+		  Build firmware image for T-Com Sinus 154 DSL Basic 3
+
+	config BR2_LINUX_2_4_SX541
+		bool "Support for Siemens Gigaset SX541"
+		default n
+		depends BR2_LINUX_2_4_GIGASET
+		help
+		  Build firmware image for Siemens Gigaset SX541
+
+endmenu
+
 config BR2_LINUX_2_6
 	bool
 	default n
Index: package/ruby/patches/01-ruby-cross.patch
===================================================================
--- package/ruby/patches/01-ruby-cross.patch	(Revision 0)
+++ package/ruby/patches/01-ruby-cross.patch	(Revision 0)
@@ -0,0 +1,23 @@
+diff -urN ruby-1.8.4/configure ruby-1.8.4patched/configure
+--- ruby-1.8.4/configure	2005-12-24 13:36:33.000000000 +0100
++++ ruby-1.8.4patched/configure	2006-02-28 13:50:57.000000000 +0100
+@@ -9308,6 +9308,8 @@
+   enable_pthread=no
+ fi;
+ 
++ac_cv_func_setpgrp_void=yes
++
+ case "$target_os" in
+ nextstep*)	;;
+ openstep*)	;;
+diff -urN ruby-1.8.4/gc.c ruby-1.8.4patched/gc.c
+--- ruby-1.8.4/gc.c	2005-12-16 05:58:51.000000000 +0100
++++ ruby-1.8.4patched/gc.c	2006-03-01 22:48:23.000000000 +0100
+@@ -363,6 +363,7 @@
+     if (himem < pend) himem = pend;
+     heaps_used++;
+     heap_slots *= 1.8;
++    if (heap_slots <= 0) heap_slots = HEAP_MIN_SLOTS;
+ 
+     while (p < pend) {
+ 	p->as.free.flags = 0;
Index: package/ruby/ipkg/ruby.control
===================================================================
--- package/ruby/ipkg/ruby.control	(Revision 0)
+++ package/ruby/ipkg/ruby.control	(Revision 0)
@@ -0,0 +1,14 @@
+Package: ruby
+Version: 1
+Architecture: mipsel
+Maintainer: Stefan Weil <weil@mail.berlios.de>
+Priority: optional
+Section: misc
+Description: Ruby scripting language
+ Ruby is the interpreted scripting language for quick and easy
+ object-oriented programming.
+ .
+ It has many features to process text files
+ and to do system management tasks (as in Perl).
+ .
+ It is simple, straight-forward, extensible, and portable.
Index: package/ruby/Config.in
===================================================================
--- package/ruby/Config.in	(Revision 0)
+++ package/ruby/Config.in	(Revision 0)
@@ -0,0 +1,12 @@
+config BR2_PACKAGE_RUBY
+	prompt "ruby.............................. Interpreted scripting language"
+	tristate
+	default m if CONFIG_DEVEL
+	help
+	  Ruby is the interpreted scripting language for quick and easy
+	  object-oriented programming. It has many features to process text files
+	  and to do system management tasks (as in Perl).
+	  It is simple, straight-forward, extensible, and portable.
+
+	  
+	  http://www.ruby-lang.org/
Index: package/ruby/Makefile
===================================================================
--- package/ruby/Makefile	(Revision 0)
+++ package/ruby/Makefile	(Revision 0)
@@ -0,0 +1,52 @@
+# $Id$
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=ruby
+PKG_VERSION:=1.8.4
+PKG_RELEASE:=1
+PKG_MD5SUM:=bd8c2e593e1fa4b01fd98eaf016329bb
+
+# space separated list or special @SF for sourceforge projects
+PKG_SOURCE_URL:=ftp://ftp.ruby-lang.org/pub/ruby
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_CAT:=zcat
+
+PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)-$(PKG_VERSION)
+PKG_INSTALL_DIR:=$(PKG_BUILD_DIR)/ipkg-install
+
+include $(TOPDIR)/package/rules.mk
+
+$(eval $(call PKG_template,RUBY,$(PKG_NAME),$(PKG_VERSION)-$(PKG_RELEASE),$(ARCH)))
+
+$(PKG_BUILD_DIR)/.configured: $(PKG_BUILD_DIR)/.prepared
+	(cd $(PKG_BUILD_DIR); rm -rf config.{cache,status} ; \
+		$(TARGET_CONFIGURE_OPTS) \
+		CFLAGS="$(TARGET_CFLAGS)" \
+		./configure \
+		  --target=$(GNU_TARGET_NAME) \
+		  --host=$(GNU_TARGET_NAME) \
+		  --build=$(GNU_HOST_NAME) \
+		  --prefix=/usr \
+		  --localstatedir=/var \
+		  --mandir=/usr/share/man \
+		  --enable-shared \
+	);
+	touch $@
+
+$(PKG_BUILD_DIR)/.built:
+	rm -rf $(PKG_INSTALL_DIR)
+	mkdir -p $(PKG_INSTALL_DIR)/usr/bin
+	$(MAKE) -C $(PKG_BUILD_DIR) all
+	touch $@
+
+$(IPKG_RUBY):
+	$(MAKE) -C $(PKG_BUILD_DIR) DESTDIR=$(IDIR_RUBY) install
+	rm $(IDIR_RUBY)/usr/lib/libruby-static.a
+	rm -r $(IDIR_RUBY)/usr/share
+	$(RSTRIP) $(IDIR_RUBY)
+	$(IPKG_BUILD) $(IDIR_RUBY) $(PACKAGE_DIR)
+
+mostlyclean:
+	make -C $(PKG_BUILD_DIR) clean
+	rm $(PKG_BUILD_DIR)/.built
Index: package/Makefile
===================================================================
--- package/Makefile	(Revision 3803)
+++ package/Makefile	(Arbeitskopie)
@@ -220,6 +220,7 @@
 package-$(BR2_COMPILE_RRDTOOL1) += rrdtool1
 package-$(BR2_COMPILE_RRS) += rrs
 package-$(BR2_PACKAGE_RSYNC) += rsync
+package-$(BR2_PACKAGE_RUBY) += ruby
 package-$(BR2_PACKAGE_SABLEVM) += sablevm
 package-$(BR2_COMPILE_SABLEVM_CLASSPATH) += sablevm-classpath
 package-$(BR2_COMPILE_SAMBA) += samba
Index: package/Config.in
===================================================================
--- package/Config.in	(Revision 3803)
+++ package/Config.in	(Arbeitskopie)
@@ -42,6 +42,7 @@
 source "package/php5/Config.in"
 source "package/procmail/Config.in"
 source "package/psybnc/Config.in"
+source "package/ruby/Config.in"
 menu "sablevm........................... A Java Virtual Machine (JVM) implementation"
 source "package/sablevm/Config.in"
 source "package/sablevm-classpath/Config.in"
Index: package/base-files/default/www/index.html
===================================================================
--- package/base-files/default/www/index.html	(Revision 0)
+++ package/base-files/default/www/index.html	(Revision 0)
@@ -0,0 +1,8 @@
+<html>
+<head>
+<title>Sinus 154 DSL Basic SE</title>
+</head>
+<body>
+Web server is running...
+</body>
+</html>
Index: package/base-files/default/www/README
===================================================================
--- package/base-files/default/www/README	(Revision 0)
+++ package/base-files/default/www/README	(Revision 0)
@@ -0,0 +1 @@
+This is the document root of the web server.
Index: package/base-files/default/usr/sbin/nvram
===================================================================
--- package/base-files/default/usr/sbin/nvram	(Revision 0)
+++ package/base-files/default/usr/sbin/nvram	(Revision 0)
@@ -0,0 +1,31 @@
+#/bin/sh
+
+#failsafe=1
+#dhcp_start=192.168.2.2
+#dhcp_num=
+lan_proto=static
+lan_hwaddr=00:30:f1:df:5f:55
+lan_ifname=eth0
+lan_ipaddr=192.168.2.1
+#lan_netmask=
+#lan_gateway=
+lan_dns=192.168.2.1
+wan_hostname=sinus154
+wan_proto=none
+wan_ifname=
+wifi_proto=none
+no_root_swap=1
+#static_route=
+
+if [ -f /dev/mtdblock/3 ]; then
+  eval $(strings /dev/mtdblock/3 | fgrep =)
+fi
+
+[ -w /dev/tty ] && echo $0 $@ >/dev/tty
+
+case $1 in
+	get) eval "echo \${$2:-\${DEFAULT_$2}}";;
+	*);;
+esac
+
+# eof

Eigenschaftsnderungen: package/base-files/default/usr/sbin/nvram
___________________________________________________________________
Name: svn:executable
   + *

Index: package/base-files/default/etc/init.d/S40network
===================================================================
--- package/base-files/default/etc/init.d/S40network	(Revision 0)
+++ package/base-files/default/etc/init.d/S40network	(Revision 0)
@@ -0,0 +1,16 @@
+#!/bin/sh
+. /etc/functions.sh
+[ "$FAILSAFE" != "true" -a -e /etc/config/network ] && . /etc/config/network
+case "$1" in
+  start|restart)
+    ifup lan
+    ifup wan
+    ifup wifi
+    [ -x /sbin/wifi ] && wifi up
+
+    for route in $(nvram get static_route); do {
+      eval "set $(echo $route | sed 's/:/ /g')"
+      $DEBUG route add -net $1 netmask $2 gw $3 metric $4 dev $5
+    } done
+    ;;
+esac

Eigenschaftsnderungen: package/base-files/default/etc/init.d/S40network
___________________________________________________________________
Name: svn:executable
   + *

Index: package/base-files/default/etc/init.d/S20syslog
===================================================================
--- package/base-files/default/etc/init.d/S20syslog	(Revision 0)
+++ package/base-files/default/etc/init.d/S20syslog	(Revision 0)
@@ -0,0 +1,14 @@
+#!/bin/sh
+. /etc/functions.sh
+case "$1" in
+  start|restart)
+    /sbin/syslogd
+    /sbin/klogd
+    ;;
+  stop)
+    killall klogd
+    killall syslogd
+    ;;
+  *)
+    echo Usage: $0 [start|stop]
+esac

Eigenschaftsnderungen: package/base-files/default/etc/init.d/S20syslog
___________________________________________________________________
Name: svn:executable
   + *

Index: package/base-files/default/etc/init.d/rcS
===================================================================
--- package/base-files/default/etc/init.d/rcS	(Revision 3803)
+++ package/base-files/default/etc/init.d/rcS	(Arbeitskopie)
@@ -1,4 +1,11 @@
 #!/bin/sh
+. /etc/nvram.sh
+
+mount /dev/pts
+mount /dev/shm
+fgrep -q /tmp /proc/mounts || mount /tmp
+
+if false; then
 ${FAILSAFE:+exit}
 
 [ -f /etc/config/network ] && . /etc/config/network
@@ -6,6 +13,7 @@
 [ "$log_ipaddr" = "$IP" ] || log_ipaddr=""
 syslogd -C 16 ${log_ipaddr:+-L -R $log_ipaddr}
 klogd
+fi
 #${FAILSAFE:+telnetd -l /bin/login; ifup lan; exit}
 for i in /etc/init.d/S*; do
   $i start 2>&1
Index: package/base-files/default/etc/TZ
===================================================================
--- package/base-files/default/etc/TZ	(Revision 0)
+++ package/base-files/default/etc/TZ	(Revision 0)
@@ -0,0 +1 @@
+CET-1CEST,M3.5.0,M10.5.0
Index: package/base-files/default/etc/fstab
===================================================================
--- package/base-files/default/etc/fstab	(Revision 0)
+++ package/base-files/default/etc/fstab	(Revision 0)
@@ -0,0 +1,7 @@
+# $Id: fstab $
+/dev/root	/		auto	defaults,errors=continue	0 0
+devfs		/dev		devfs	defaults,noauto			0 0
+devpts		/dev/pts	devpts	defaults			0 0
+tmpfs		/dev/shm	tmpfs	defaults			0 0
+proc		/proc		proc	defaults			0 0
+tmpfs		/tmp		tmpfs	defaults,nosuid,nodev,mode=1777,size=50%	0 0
Index: package/base-files/default/etc/preinit.sinus154
===================================================================
--- package/base-files/default/etc/preinit.sinus154	(Revision 0)
+++ package/base-files/default/etc/preinit.sinus154	(Revision 0)
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+#~ set -x
+
+. /etc/nvram.sh
+export PATH=/bin:/sbin:/usr/bin:/usr/sbin
+
+# Filesystem devfs on /dev is mounted by kernel.
+mount /proc
+mount /tmp
+
+if [ -f /dev/mtdblock/3 ]; then
+  lan_hwaddr=$(hexdump -e "\"\" 6/1 \"%02X:\" \"\\n\"" -n 6 -s 22 /dev/mtdblock/3|sed s/.$//)
+fi
+
+ifup lan
+if arping -c 1 192.168.2.2 -q; then
+	mount -t nfs -o nolock 192.168.2.2:/nfsroot /net
+	pivot_root /net /net/rom
+	[ -x /etc/preinit.net ] && . /etc/preinit.net
+	mount -a
+fi
+
+#mount none /proc -t proc
+#insmod diag
+[ -f /proc/sys/diag ] && echo 0x01 > /proc/sys/diag
+#sleep 1
+if [ -f /proc/sys/reset ] && [ $(cat /proc/sys/reset) = 1 -o "$(nvram get failsafe)" = 1 ]; then
+	export FAILSAFE=true
+	[ "$(nvram get boot_wait)" != "on" ] && {
+		nvram set boot_wait=on
+		nvram commit
+	}
+	while :; do { echo $(((X=(X+1)%8)%2)) > /proc/sys/diag; sleep $((X==0)); } done &
+fi
+
+exec /sbin/init

Eigenschaftsnderungen: package/base-files/default/etc/preinit.sinus154
___________________________________________________________________
Name: svn:executable
   + *

