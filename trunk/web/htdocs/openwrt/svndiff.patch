Index: .config
===================================================================
--- .config	(Revision 0)
+++ .config	(Revision 0)
@@ -0,0 +1,1122 @@
+#
+# Automatically generated make config: don't edit
+#
+MODULES=y
+BR2_HAVE_DOT_CONFIG=y
+BR2_mipsel=y
+BR2_ARCH="mipsel"
+BR2_WGET="wget --passive-ftp -nd"
+# BR2_TAR_VERBOSITY is not set
+BR2_JLEVEL=1
+# BR2_UCLIBC_VERSION_SNAPSHOT is not set
+BR2_BINUTILS_VERSION="2.16.1"
+BR2_GCC_VERSION="3.4.4"
+BR2_GCC_USE_SJLJ_EXCEPTIONS=""
+BR2_EXTRA_GCC_CONFIG_OPTIONS=""
+BR2_INSTALL_LIBSTDCPP=y
+# BR2_ENABLE_MULTILIB is not set
+BR2_LARGEFILE=y
+BR2_TARGET_OPTIMIZATION="-Os -pipe -mips32 -mtune=mips32 -funit-at-a-time"
+
+#
+# OpenWrt Package Selection
+#
+
+#
+# The default set
+#
+
+#
+# busybox........................... The Swiss Army Knife of embedded Linux
+#
+BR2_PACKAGE_BUSYBOX=y
+
+#
+# Busybox Configuration
+#
+BUSYBOX_HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# BUSYBOX_CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+BUSYBOX_CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# BUSYBOX_CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+BUSYBOX_CONFIG_FEATURE_VERBOSE_USAGE=y
+# BUSYBOX_CONFIG_FEATURE_INSTALLER is not set
+# BUSYBOX_CONFIG_LOCALE_SUPPORT is not set
+BUSYBOX_CONFIG_FEATURE_DEVFS=y
+BUSYBOX_CONFIG_FEATURE_DEVPTS=y
+# BUSYBOX_CONFIG_FEATURE_CLEAN_UP is not set
+BUSYBOX_CONFIG_FEATURE_SUID=y
+# BUSYBOX_CONFIG_FEATURE_SUID_CONFIG is not set
+# BUSYBOX_CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+# BUSYBOX_CONFIG_STATIC is not set
+BUSYBOX_CONFIG_LFS=y
+BUSYBOX_USING_CROSS_COMPILER=y
+BUSYBOX_CROSS_COMPILER_PREFIX="mipsel-uclibc-"
+BUSYBOX_EXTRA_CFLAGS_OPTIONS="-Os "
+
+#
+# Installation Options
+#
+# BUSYBOX_CONFIG_INSTALL_NO_USR is not set
+BUSYBOX_PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# BUSYBOX_CONFIG_AR is not set
+BUSYBOX_CONFIG_BUNZIP2=y
+# BUSYBOX_CONFIG_CPIO is not set
+# BUSYBOX_CONFIG_DPKG is not set
+# BUSYBOX_CONFIG_DPKG_DEB is not set
+BUSYBOX_CONFIG_GUNZIP=y
+BUSYBOX_CONFIG_FEATURE_GUNZIP_UNCOMPRESS=y
+BUSYBOX_CONFIG_GZIP=y
+# BUSYBOX_CONFIG_IPKG is not set
+# BUSYBOX_CONFIG_RPM2CPIO is not set
+# BUSYBOX_CONFIG_RPM is not set
+BUSYBOX_CONFIG_TAR=y
+BUSYBOX_CONFIG_FEATURE_TAR_CREATE=y
+BUSYBOX_CONFIG_FEATURE_TAR_BZIP2=y
+BUSYBOX_CONFIG_FEATURE_TAR_FROM=y
+BUSYBOX_CONFIG_FEATURE_TAR_GZIP=y
+# BUSYBOX_CONFIG_FEATURE_TAR_COMPRESS is not set
+# BUSYBOX_CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+BUSYBOX_CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# BUSYBOX_CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# BUSYBOX_CONFIG_UNCOMPRESS is not set
+# BUSYBOX_CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# BUSYBOX_CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+BUSYBOX_CONFIG_BASENAME=y
+# BUSYBOX_CONFIG_CAL is not set
+BUSYBOX_CONFIG_CAT=y
+BUSYBOX_CONFIG_CHGRP=y
+BUSYBOX_CONFIG_CHMOD=y
+BUSYBOX_CONFIG_CHOWN=y
+BUSYBOX_CONFIG_CHROOT=y
+BUSYBOX_CONFIG_CMP=y
+BUSYBOX_CONFIG_CP=y
+BUSYBOX_CONFIG_CUT=y
+BUSYBOX_CONFIG_DATE=y
+BUSYBOX_CONFIG_FEATURE_DATE_ISOFMT=y
+BUSYBOX_CONFIG_DD=y
+BUSYBOX_CONFIG_DF=y
+BUSYBOX_CONFIG_DIRNAME=y
+# BUSYBOX_CONFIG_DOS2UNIX is not set
+BUSYBOX_CONFIG_DU=y
+BUSYBOX_CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+BUSYBOX_CONFIG_ECHO=y
+BUSYBOX_CONFIG_FEATURE_FANCY_ECHO=y
+BUSYBOX_CONFIG_ENV=y
+BUSYBOX_CONFIG_EXPR=y
+BUSYBOX_CONFIG_FALSE=y
+# BUSYBOX_CONFIG_FOLD is not set
+BUSYBOX_CONFIG_HEAD=y
+BUSYBOX_CONFIG_FEATURE_FANCY_HEAD=y
+BUSYBOX_CONFIG_HOSTID=y
+BUSYBOX_CONFIG_ID=y
+# BUSYBOX_CONFIG_INSTALL is not set
+BUSYBOX_CONFIG_LENGTH=y
+BUSYBOX_CONFIG_LN=y
+# BUSYBOX_CONFIG_LOGNAME is not set
+BUSYBOX_CONFIG_LS=y
+BUSYBOX_CONFIG_FEATURE_LS_FILETYPES=y
+BUSYBOX_CONFIG_FEATURE_LS_FOLLOWLINKS=y
+BUSYBOX_CONFIG_FEATURE_LS_RECURSIVE=y
+BUSYBOX_CONFIG_FEATURE_LS_SORTFILES=y
+BUSYBOX_CONFIG_FEATURE_LS_TIMESTAMPS=y
+BUSYBOX_CONFIG_FEATURE_LS_USERNAME=y
+BUSYBOX_CONFIG_FEATURE_LS_COLOR=y
+BUSYBOX_CONFIG_MD5SUM=y
+BUSYBOX_CONFIG_MKDIR=y
+BUSYBOX_CONFIG_MKFIFO=y
+# BUSYBOX_CONFIG_MKNOD is not set
+BUSYBOX_CONFIG_MV=y
+BUSYBOX_CONFIG_OD=y
+BUSYBOX_CONFIG_PRINTF=y
+BUSYBOX_CONFIG_PWD=y
+# BUSYBOX_CONFIG_REALPATH is not set
+BUSYBOX_CONFIG_RM=y
+BUSYBOX_CONFIG_RMDIR=y
+BUSYBOX_CONFIG_SEQ=y
+# BUSYBOX_CONFIG_SHA1SUM is not set
+BUSYBOX_CONFIG_SLEEP=y
+BUSYBOX_CONFIG_FEATURE_FANCY_SLEEP=y
+BUSYBOX_CONFIG_SORT=y
+# BUSYBOX_CONFIG_STTY is not set
+BUSYBOX_CONFIG_SYNC=y
+BUSYBOX_CONFIG_TAIL=y
+BUSYBOX_CONFIG_FEATURE_FANCY_TAIL=y
+BUSYBOX_CONFIG_TEE=y
+BUSYBOX_CONFIG_FEATURE_TEE_USE_BLOCK_IO=y
+BUSYBOX_CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# BUSYBOX_CONFIG_FEATURE_TEST_64 is not set
+BUSYBOX_CONFIG_TOUCH=y
+BUSYBOX_CONFIG_TR=y
+BUSYBOX_CONFIG_TRUE=y
+# BUSYBOX_CONFIG_TTY is not set
+BUSYBOX_CONFIG_UNAME=y
+BUSYBOX_CONFIG_UNIQ=y
+# BUSYBOX_CONFIG_USLEEP is not set
+# BUSYBOX_CONFIG_UUDECODE is not set
+# BUSYBOX_CONFIG_UUENCODE is not set
+# BUSYBOX_CONFIG_WATCH is not set
+BUSYBOX_CONFIG_WC=y
+# BUSYBOX_CONFIG_WHO is not set
+# BUSYBOX_CONFIG_WHOAMI is not set
+BUSYBOX_CONFIG_YES=y
+
+#
+# Common options for cp and mv
+#
+BUSYBOX_CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+BUSYBOX_CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+BUSYBOX_CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+BUSYBOX_CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# BUSYBOX_CONFIG_CHVT is not set
+BUSYBOX_CONFIG_CLEAR=y
+# BUSYBOX_CONFIG_DEALLOCVT is not set
+# BUSYBOX_CONFIG_DUMPKMAP is not set
+# BUSYBOX_CONFIG_LOADFONT is not set
+# BUSYBOX_CONFIG_LOADKMAP is not set
+# BUSYBOX_CONFIG_OPENVT is not set
+BUSYBOX_CONFIG_RESET=y
+# BUSYBOX_CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+BUSYBOX_CONFIG_MKTEMP=y
+# BUSYBOX_CONFIG_PIPE_PROGRESS is not set
+# BUSYBOX_CONFIG_READLINK is not set
+# BUSYBOX_CONFIG_RUN_PARTS is not set
+# BUSYBOX_CONFIG_START_STOP_DAEMON is not set
+BUSYBOX_CONFIG_WHICH=y
+
+#
+# Editors
+#
+BUSYBOX_CONFIG_AWK=y
+BUSYBOX_CONFIG_FEATURE_AWK_MATH=y
+# BUSYBOX_CONFIG_PATCH is not set
+BUSYBOX_CONFIG_SED=y
+BUSYBOX_CONFIG_VI=y
+BUSYBOX_CONFIG_FEATURE_VI_COLON=y
+BUSYBOX_CONFIG_FEATURE_VI_YANKMARK=y
+BUSYBOX_CONFIG_FEATURE_VI_SEARCH=y
+BUSYBOX_CONFIG_FEATURE_VI_USE_SIGNALS=y
+BUSYBOX_CONFIG_FEATURE_VI_DOT_CMD=y
+BUSYBOX_CONFIG_FEATURE_VI_READONLY=y
+BUSYBOX_CONFIG_FEATURE_VI_SETOPTS=y
+BUSYBOX_CONFIG_FEATURE_VI_SET=y
+BUSYBOX_CONFIG_FEATURE_VI_WIN_RESIZE=y
+BUSYBOX_CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+BUSYBOX_CONFIG_FIND=y
+# BUSYBOX_CONFIG_FEATURE_FIND_MTIME is not set
+BUSYBOX_CONFIG_FEATURE_FIND_PERM=y
+BUSYBOX_CONFIG_FEATURE_FIND_TYPE=y
+BUSYBOX_CONFIG_FEATURE_FIND_XDEV=y
+# BUSYBOX_CONFIG_FEATURE_FIND_NEWER is not set
+# BUSYBOX_CONFIG_FEATURE_FIND_INUM is not set
+BUSYBOX_CONFIG_GREP=y
+BUSYBOX_CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+BUSYBOX_CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+BUSYBOX_CONFIG_FEATURE_GREP_CONTEXT=y
+BUSYBOX_CONFIG_XARGS=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+BUSYBOX_CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+BUSYBOX_CONFIG_INIT=y
+BUSYBOX_CONFIG_FEATURE_USE_INITTAB=y
+# BUSYBOX_CONFIG_FEATURE_INITRD is not set
+# BUSYBOX_CONFIG_FEATURE_INIT_COREDUMPS is not set
+# BUSYBOX_CONFIG_FEATURE_EXTRA_QUIET is not set
+# BUSYBOX_CONFIG_HALT is not set
+# BUSYBOX_CONFIG_POWEROFF is not set
+BUSYBOX_CONFIG_REBOOT=y
+BUSYBOX_CONFIG_MESG=y
+
+#
+# Login/Password Management Utilities
+#
+# BUSYBOX_CONFIG_USE_BB_PWD_GRP is not set
+BUSYBOX_CONFIG_ADDGROUP=y
+BUSYBOX_CONFIG_DELGROUP=y
+BUSYBOX_CONFIG_ADDUSER=y
+BUSYBOX_CONFIG_DELUSER=y
+# BUSYBOX_CONFIG_GETTY is not set
+# BUSYBOX_CONFIG_LOGIN is not set
+BUSYBOX_CONFIG_PASSWD=y
+# BUSYBOX_CONFIG_SU is not set
+# BUSYBOX_CONFIG_SULOGIN is not set
+# BUSYBOX_CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+BUSYBOX_CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# BUSYBOX_CONFIG_ADJTIMEX is not set
+BUSYBOX_CONFIG_CROND=y
+# BUSYBOX_CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+BUSYBOX_CONFIG_CRONTAB=y
+# BUSYBOX_CONFIG_DC is not set
+# BUSYBOX_CONFIG_DEVFSD is not set
+# BUSYBOX_CONFIG_LAST is not set
+# BUSYBOX_CONFIG_HDPARM is not set
+# BUSYBOX_CONFIG_MAKEDEVS is not set
+# BUSYBOX_CONFIG_MT is not set
+BUSYBOX_CONFIG_RX=y
+BUSYBOX_CONFIG_STRINGS=y
+BUSYBOX_CONFIG_TIME=y
+# BUSYBOX_CONFIG_WATCHDOG is not set
+
+#
+# Linux Module Utilities
+#
+BUSYBOX_CONFIG_INSMOD=y
+BUSYBOX_CONFIG_FEATURE_2_4_MODULES=y
+# BUSYBOX_CONFIG_FEATURE_2_6_MODULES is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# BUSYBOX_CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+BUSYBOX_CONFIG_LSMOD=y
+BUSYBOX_CONFIG_FEATURE_QUERY_MODULE_INTERFACE=y
+# BUSYBOX_CONFIG_MODPROBE is not set
+BUSYBOX_CONFIG_RMMOD=y
+BUSYBOX_CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+BUSYBOX_CONFIG_FEATURE_IPV6=y
+BUSYBOX_CONFIG_ARPING=y
+# BUSYBOX_CONFIG_FTPGET is not set
+# BUSYBOX_CONFIG_FTPPUT is not set
+# BUSYBOX_CONFIG_HOSTNAME is not set
+BUSYBOX_CONFIG_HTTPD=y
+# BUSYBOX_CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+BUSYBOX_CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_AUTH_MD5=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP=y
+# BUSYBOX_CONFIG_FEATURE_HTTPD_SETUID is not set
+BUSYBOX_CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_CGI=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV=y
+BUSYBOX_CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+BUSYBOX_CONFIG_IFCONFIG=y
+BUSYBOX_CONFIG_FEATURE_IFCONFIG_STATUS=y
+# BUSYBOX_CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# BUSYBOX_CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ is not set
+BUSYBOX_CONFIG_FEATURE_IFCONFIG_HW=y
+BUSYBOX_CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS=y
+# BUSYBOX_CONFIG_IFUPDOWN is not set
+# BUSYBOX_CONFIG_INETD is not set
+# BUSYBOX_CONFIG_IP is not set
+BUSYBOX_CONFIG_IPCALC=y
+BUSYBOX_CONFIG_FEATURE_IPCALC_FANCY=y
+# BUSYBOX_CONFIG_IPADDR is not set
+# BUSYBOX_CONFIG_IPLINK is not set
+# BUSYBOX_CONFIG_IPROUTE is not set
+# BUSYBOX_CONFIG_IPTUNNEL is not set
+# BUSYBOX_CONFIG_NAMEIF is not set
+BUSYBOX_CONFIG_NC=y
+BUSYBOX_CONFIG_NETSTAT=y
+BUSYBOX_CONFIG_NSLOOKUP=y
+BUSYBOX_CONFIG_PING=y
+BUSYBOX_CONFIG_FEATURE_FANCY_PING=y
+BUSYBOX_CONFIG_PING6=y
+BUSYBOX_CONFIG_FEATURE_FANCY_PING6=y
+BUSYBOX_CONFIG_ROUTE=y
+BUSYBOX_CONFIG_TELNET=y
+BUSYBOX_CONFIG_FEATURE_TELNET_TTYPE=y
+# BUSYBOX_CONFIG_FEATURE_TELNET_AUTOLOGIN is not set
+BUSYBOX_CONFIG_TELNETD=y
+# BUSYBOX_CONFIG_FEATURE_TELNETD_INETD is not set
+# BUSYBOX_CONFIG_TFTP is not set
+BUSYBOX_CONFIG_TRACEROUTE=y
+BUSYBOX_CONFIG_FEATURE_TRACEROUTE_VERBOSE=y
+BUSYBOX_CONFIG_VCONFIG=y
+BUSYBOX_CONFIG_WGET=y
+BUSYBOX_CONFIG_FEATURE_WGET_STATUSBAR=y
+BUSYBOX_CONFIG_FEATURE_WGET_AUTHENTICATION=y
+BUSYBOX_CONFIG_FEATURE_WGET_IP6_LITERAL=y
+
+#
+# udhcp Server/Client
+#
+# BUSYBOX_CONFIG_UDHCPD is not set
+BUSYBOX_CONFIG_UDHCPC=y
+# BUSYBOX_CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# BUSYBOX_CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+BUSYBOX_CONFIG_FREE=y
+BUSYBOX_CONFIG_KILL=y
+BUSYBOX_CONFIG_KILLALL=y
+BUSYBOX_CONFIG_KILLALL5=y
+BUSYBOX_CONFIG_PIDOF=y
+BUSYBOX_CONFIG_PS=y
+# BUSYBOX_CONFIG_RENICE is not set
+BUSYBOX_CONFIG_TOP=y
+BUSYBOX_FEATURE_CPU_USAGE_PERCENTAGE=y
+BUSYBOX_CONFIG_UPTIME=y
+BUSYBOX_CONFIG_BB_SYSCTL=y
+
+#
+# Another Bourne-like Shell
+#
+BUSYBOX_CONFIG_FEATURE_SH_IS_ASH=y
+# BUSYBOX_CONFIG_FEATURE_SH_IS_HUSH is not set
+# BUSYBOX_CONFIG_FEATURE_SH_IS_LASH is not set
+# BUSYBOX_CONFIG_FEATURE_SH_IS_MSH is not set
+# BUSYBOX_CONFIG_FEATURE_SH_IS_NONE is not set
+BUSYBOX_CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+BUSYBOX_CONFIG_ASH_JOB_CONTROL=y
+BUSYBOX_CONFIG_ASH_ALIAS=y
+BUSYBOX_CONFIG_ASH_MATH_SUPPORT=y
+# BUSYBOX_CONFIG_ASH_MATH_SUPPORT_64 is not set
+BUSYBOX_CONFIG_ASH_GETOPTS=y
+BUSYBOX_CONFIG_ASH_CMDCMD=y
+# BUSYBOX_CONFIG_ASH_MAIL is not set
+BUSYBOX_CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# BUSYBOX_CONFIG_ASH_RANDOM_SUPPORT is not set
+# BUSYBOX_CONFIG_HUSH is not set
+# BUSYBOX_CONFIG_LASH is not set
+# BUSYBOX_CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# BUSYBOX_CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# BUSYBOX_CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+BUSYBOX_CONFIG_FEATURE_COMMAND_EDITING=y
+BUSYBOX_CONFIG_FEATURE_COMMAND_HISTORY=15
+# BUSYBOX_CONFIG_FEATURE_COMMAND_SAVEHISTORY is not set
+BUSYBOX_CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# BUSYBOX_CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+BUSYBOX_CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+BUSYBOX_CONFIG_SYSLOGD=y
+BUSYBOX_CONFIG_FEATURE_ROTATE_LOGFILE=y
+BUSYBOX_CONFIG_FEATURE_REMOTE_LOG=y
+BUSYBOX_CONFIG_FEATURE_IPC_SYSLOG=y
+BUSYBOX_CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=16
+BUSYBOX_CONFIG_LOGREAD=y
+# BUSYBOX_CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+BUSYBOX_CONFIG_KLOGD=y
+BUSYBOX_CONFIG_LOGGER=y
+
+#
+# Linux System Utilities
+#
+BUSYBOX_CONFIG_DMESG=y
+# BUSYBOX_CONFIG_FBSET is not set
+# BUSYBOX_CONFIG_FDFLUSH is not set
+# BUSYBOX_CONFIG_FDFORMAT is not set
+# BUSYBOX_CONFIG_FDISK is not set
+BUSYBOX_FDISK_SUPPORT_LARGE_DISKS=y
+# BUSYBOX_CONFIG_FREERAMDISK is not set
+# BUSYBOX_CONFIG_FSCK_MINIX is not set
+# BUSYBOX_CONFIG_MKFS_MINIX is not set
+# BUSYBOX_CONFIG_GETOPT is not set
+BUSYBOX_CONFIG_HEXDUMP=y
+# BUSYBOX_CONFIG_HWCLOCK is not set
+BUSYBOX_CONFIG_LOSETUP=y
+BUSYBOX_CONFIG_MKSWAP=y
+BUSYBOX_CONFIG_MORE=y
+BUSYBOX_CONFIG_FEATURE_USE_TERMIOS=y
+BUSYBOX_CONFIG_PIVOT_ROOT=y
+BUSYBOX_CONFIG_RDATE=y
+BUSYBOX_CONFIG_SWAPONOFF=y
+BUSYBOX_CONFIG_MOUNT=y
+BUSYBOX_CONFIG_NFSMOUNT=y
+BUSYBOX_CONFIG_UMOUNT=y
+BUSYBOX_CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+BUSYBOX_CONFIG_FEATURE_MOUNT_LOOP=y
+# BUSYBOX_CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Debugging Options
+#
+# BUSYBOX_CONFIG_DEBUG is not set
+BR2_PACKAGE_BRIDGE=y
+BR2_PACKAGE_DNSMASQ=y
+BR2_PACKAGE_IPKG=y
+
+#
+# iptables.......................... IPv4 / IPv6 firewall administration
+#
+# BR2_PACKAGE_IPTABLES is not set
+# BR2_PACKAGE_IP6TABLES is not set
+BR2_PACKAGE_MTD=m
+# BR2_PACKAGE_MTD_STATIC is not set
+
+#
+# Applications
+#
+# BR2_PACKAGE_DECO is not set
+# BR2_PACKAGE_GPSD is not set
+# BR2_PACKAGE_HASERL is not set
+# BR2_PACKAGE_IRSSI is not set
+# BR2_PACKAGE_LCD4LINUX is not set
+BR2_PACKAGE_LESS=m
+
+#
+# lua............................... LUA programming language
+#
+# BR2_PACKAGE_LIBLUA is not set
+# BR2_PACKAGE_LUA is not set
+# BR2_PACKAGE_LUAC is not set
+# BR2_PACKAGE_LUA_EXAMPLES is not set
+# BR2_PACKAGE_MICROPERL is not set
+# BR2_PACKAGE_MONIT is not set
+# BR2_PACKAGE_MONIT_NOSSL is not set
+# BR2_PACKAGE_NANO is not set
+# BR2_PACKAGE_OSIRISD is not set
+
+#
+# php4.............................. PHP4 Hypertext preprocessor
+#
+
+#
+# Server API ---
+#
+# BR2_PACKAGE_PHP4_CLI is not set
+# BR2_PACKAGE_PHP4_CGI is not set
+# BR2_PACKAGE_PHP4_FASTCGI is not set
+
+#
+# Extensions ---
+#
+
+#
+# php5.............................. PHP5 Hypertext preprocessor
+#
+
+#
+# Server API ---
+#
+# BR2_PACKAGE_PHP5_CLI is not set
+# BR2_PACKAGE_PHP5_CGI is not set
+# BR2_PACKAGE_PHP5_FASTCGI is not set
+
+#
+# Extensions ---
+#
+# BR2_PACKAGE_PSYBNC is not set
+
+#
+# sablevm........................... A Java Virtual Machine (JVM) implementation
+#
+# BR2_PACKAGE_SABLEVM is not set
+# BR2_PACKAGE_LIBSABLEVM_CLASSPATH is not set
+# BR2_PACKAGE_LIBFFI_SABLE is not set
+# BR2_PACKAGE_SANE_BACKENDS is not set
+
+#
+# rrdtool........................... Round-Robin Database (RRD) libraries and tools
+#
+# BR2_COMPILE_RRDTOOL is not set
+BR2_COMPILE_RRDTOOL1=y
+# BR2_PACKAGE_LIBRRD1 is not set
+# BR2_PACKAGE_RRDCGI1 is not set
+# BR2_PACKAGE_RRDTOOL1 is not set
+# BR2_PACKAGE_SCREEN is not set
+
+#
+# Networking
+#
+# BR2_PACKAGE_AIRCRACK is not set
+# BR2_PACKAGE_AMWALL is not set
+# BR2_PACKAGE_ARPD is not set
+# BR2_PACKAGE_ARPTABLES is not set
+# BR2_PACKAGE_ARPWATCH is not set
+
+#
+# asterisk.......................... Complete open source PBX
+#
+# BR2_PACKAGE_ASTERISK is not set
+# BR2_PACKAGE_ASTERISK_MINI is not set
+# BR2_PACKAGE_ATFTP is not set
+# BR2_PACKAGE_ATFTPD is not set
+
+#
+# avahi............................. An mDNS/DNS-SD (aka RendezVous/Bonjour/ZeroConf) implementation
+#
+# BR2_PACKAGE_AVAHI_DAEMON is not set
+# BR2_PACKAGE_LIBAVAHI is not set
+# BR2_PACKAGE_BIND_CLIENT is not set
+# BR2_PACKAGE_BIND_SERVER is not set
+# BR2_PACKAGE_BWM is not set
+# BR2_PACKAGE_CHILLISPOT is not set
+# BR2_PACKAGE_CIFSMOUNT is not set
+# BR2_PACKAGE_CUPS is not set
+# BR2_PACKAGE_CUTTER is not set
+# BR2_PACKAGE_DHCP_RELAY is not set
+# BR2_PACKAGE_DHCP_SERVER is not set
+# BR2_PACKAGE_DHCP_FORWARDER is not set
+BR2_PACKAGE_DROPBEAR=m
+# BR2_PACKAGE_DSNIFF is not set
+# BR2_PACKAGE_EBTABLES is not set
+# BR2_PACKAGE_ELHTTP is not set
+# BR2_PACKAGE_ETHER_WAKE is not set
+# BR2_PACKAGE_EZIPUPDATE is not set
+# BR2_PACKAGE_FPING is not set
+# BR2_PACKAGE_FPROBE is not set
+# BR2_PACKAGE_FPROBE_ULOG is not set
+
+#
+# freeradius........................ A Flexible RADIUS server implementation
+#
+# BR2_PACKAGE_FREERADIUS is not set
+# BR2_PACKAGE_FRICKIN is not set
+
+#
+# howl.............................. A Zeroconf networking implementation
+#
+# BR2_PACKAGE_LIBHOWL is not set
+
+#
+# Daemons ---
+#
+# BR2_PACKAGE_AUTOIPD is not set
+# BR2_PACKAGE_MDNSRESPONDER is not set
+# BR2_PACKAGE_NIFD is not set
+BR2_PACKAGE_HOSTAP_UTILS=m
+BR2_PACKAGE_HOSTAPD=m
+# BR2_PACKAGE_HTPDATE is not set
+# BR2_PACKAGE_IPCAD is not set
+
+#
+# iproute2.......................... A collection of utilites for controlling TCP/IP networking and Traffic Control
+#
+# BR2_PACKAGE_IP is not set
+# BR2_PACKAGE_TC is not set
+# BR2_PACKAGE_IPERF is not set
+# BR2_PACKAGE_IPSEC_TOOLS is not set
+# BR2_PACKAGE_IPSET is not set
+# BR2_PACKAGE_IPTABLES_SNMP is not set
+# BR2_PACKAGE_IPTRAF is not set
+# BR2_PACKAGE_KISMET_CLIENT is not set
+# BR2_PACKAGE_KISMET_DRONE is not set
+# BR2_PACKAGE_KISMET_SERVER is not set
+# BR2_PACKAGE_KNOCK is not set
+# BR2_PACKAGE_KNOCKD is not set
+# BR2_PACKAGE_L2TPD is not set
+# BR2_PACKAGE_L2TPNS is not set
+
+#
+# lighttpd.......................... Flexible and lightweight web server
+#
+# BR2_PACKAGE_LIGHTTPD is not set
+# BR2_PACKAGE_LINUX_ATM is not set
+# BR2_PACKAGE_MACCHANGER is not set
+# BR2_PACKAGE_MARADNS is not set
+
+#
+# mini-httpd........................ A small web server
+#
+# BR2_PACKAGE_MINI_HTTPD is not set
+# BR2_PACKAGE_MINI_HTTPD_MATRIXSSL is not set
+# BR2_PACKAGE_MINI_HTTPD_OPENSSL is not set
+# BR2_PACKAGE_MINI_SENDMAIL is not set
+# BR2_PACKAGE_MTR is not set
+
+#
+# net-snmp.......................... Open source SNMP (Simple Network Management Protocol) implementation
+#
+# BR2_PACKAGE_LIBNETSNMP is not set
+# BR2_PACKAGE_SNMPD is not set
+# BR2_PACKAGE_SNMPD_STATIC is not set
+# BR2_PACKAGE_NETSTAT_NAT is not set
+# BR2_PACKAGE_NFS_SERVER is not set
+# BR2_PACKAGE_NMAP is not set
+# BR2_PACKAGE_NOCATSPLASH is not set
+# BR2_PACKAGE_NTPCLIENT is not set
+
+#
+# olsrd............................. OLSR (Optimized Link State Routing) daemon
+#
+# BR2_PACKAGE_OLSRD is not set
+# BR2_PACKAGE_OPENNTPD is not set
+
+#
+# openssh........................... A free implementation of the Secure Shell protocol
+#
+# BR2_PACKAGE_OPENSSH_CLIENT is not set
+# BR2_PACKAGE_OPENSSH_SERVER is not set
+# BR2_PACKAGE_OPENSSH_SFTP_CLIENT is not set
+# BR2_PACKAGE_OPENSSH_SFTP_SERVER is not set
+# BR2_PACKAGE_OPENSWAN is not set
+
+#
+# openvpn........................... Open source VPN solution using SSL
+#
+# BR2_PACKAGE_OPENVPN is not set
+# BR2_PACKAGE_P910ND is not set
+# BR2_PACKAGE_PARPROUTED is not set
+
+#
+# pmacct............................ IPv4/IPv6 accounting and aggregation tools
+#
+# BR2_PACKAGE_NFACCTD_BASIC is not set
+# BR2_PACKAGE_NFACCTD_MYSQL is not set
+# BR2_PACKAGE_NFACCTD_PGSQL is not set
+# BR2_PACKAGE_NFACCTD_CUSTOM is not set
+# BR2_PACKAGE_PMACCTD_BASIC is not set
+# BR2_PACKAGE_PMACCTD_MYSQL is not set
+# BR2_PACKAGE_PMACCTD_PGSQL is not set
+# BR2_PACKAGE_PMACCTD_CUSTOM is not set
+# BR2_PACKAGE_PMACCT_CLIENT is not set
+# BR2_PACKAGE_PORTMAP is not set
+# BR2_PACKAGE_PORTSENTRY is not set
+
+#
+# ppp............................... PPP (Point-to-Point Protocol) daemon
+#
+BR2_PACKAGE_PPP=y
+# BR2_PACKAGE_PPP_MOD_PPPOA is not set
+BR2_PACKAGE_PPP_MOD_PPPOE=y
+# BR2_PACKAGE_PPP_MOD_RADIUS is not set
+# BR2_PACKAGE_CHAT is not set
+# BR2_PACKAGE_PPPDUMP is not set
+# BR2_PACKAGE_PPPSTATS is not set
+# BR2_PACKAGE_PPPOE_CLIENT is not set
+# BR2_PACKAGE_PPPOE_RELAY is not set
+# BR2_PACKAGE_PPPOE_SERVER is not set
+# BR2_PACKAGE_PPPOE_SNIFF is not set
+# BR2_PACKAGE_PPTP is not set
+# BR2_PACKAGE_PPTPD is not set
+# BR2_PACKAGE_PTUNNEL is not set
+
+#
+# quagga............................ The Quagga Software Routing Suite
+#
+# BR2_PACKAGE_QUAGGA is not set
+# BR2_PACKAGE_RADDUMP is not set
+# BR2_PACKAGE_RARPD is not set
+# BR2_PACKAGE_REAIM is not set
+# BR2_PACKAGE_ROBOCFG is not set
+# BR2_PACKAGE_RRS is not set
+# BR2_PACKAGE_RRS_NOSSL is not set
+# BR2_PACKAGE_RSYNC is not set
+# BR2_PACKAGE_SAMBA is not set
+# BR2_PACKAGE_SAMBA_CLIENT is not set
+# BR2_PACKAGE_SCDP is not set
+# BR2_PACKAGE_SER is not set
+# BR2_PACKAGE_SHAT is not set
+# BR2_PACKAGE_SIPROXD is not set
+# BR2_PACKAGE_SIPSAK is not set
+# BR2_PACKAGE_SLURM is not set
+
+#
+# snort............................. Ligthweight Network Intrusion Detection System (NIDS)
+#
+# BR2_PACKAGE_SNORT_BASIC is not set
+# BR2_PACKAGE_SNORT_MYSQL is not set
+# BR2_PACKAGE_SNORT_PGSQL is not set
+# BR2_PACKAGE_SNORT_CUSTOM is not set
+
+#
+# snort-wireless.................... Ligthweight Wireless Network Intrusion Detection System (NIDS)
+#
+# BR2_PACKAGE_SNORT_WIRELESS_BASIC is not set
+# BR2_PACKAGE_SNORT_WIRELESS_MYSQL is not set
+# BR2_PACKAGE_SNORT_WIRELESS_PGSQL is not set
+# BR2_PACKAGE_SNORT_WIRELESS_CUSTOM is not set
+# BR2_PACKAGE_SOCAT is not set
+# BR2_PACKAGE_SSMTP is not set
+# BR2_PACKAGE_SRELAY is not set
+# BR2_PACKAGE_TMSNC is not set
+BR2_PACKAGE_TCPDUMP=m
+# BR2_PACKAGE_KMOD_TIAP is not set
+# BR2_PACKAGE_TINC is not set
+# BR2_PACKAGE_TOR is not set
+# BR2_PACKAGE_TTCP is not set
+
+#
+# ulogd............................. Netfilter userspace logging daemon
+#
+# BR2_PACKAGE_ULOGD is not set
+
+#
+# updatedd.......................... A tool to update dynamic dns services
+#
+# BR2_PACKAGE_UPDATEDD is not set
+# BR2_PACKAGE_VGP is not set
+# BR2_PACKAGE_VNC_REFLECTOR is not set
+# BR2_PACKAGE_VNSTAT is not set
+# BR2_PACKAGE_VPNC is not set
+# BR2_PACKAGE_VRRPD is not set
+# BR2_PACKAGE_VSFTPD is not set
+# BR2_PACKAGE_VTUN is not set
+# BR2_PACKAGE_WCCPD is not set
+# BR2_PACKAGE_WIFIDOG is not set
+BR2_PACKAGE_WIRELESS_TOOLS=y
+# BR2_PACKAGE_WIVIZ is not set
+# BR2_PACKAGE_WKNOCK is not set
+# BR2_PACKAGE_WOL is not set
+# BR2_PACKAGE_WONDERSHAPER is not set
+BR2_PACKAGE_WPA_SUPPLICANT=m
+# BR2_PACKAGE_WPUT is not set
+# BR2_PACKAGE_XINETD is not set
+# BR2_PACKAGE_XSUPPLICANT is not set
+
+#
+# IPv6
+#
+# BR2_PACKAGE_6TUNNEL is not set
+# BR2_PACKAGE_AICCU is not set
+# BR2_PACKAGE_DHCP6 is not set
+# BR2_PACKAGE_MIREDO is not set
+# BR2_PACKAGE_MIREDO_SERVER is not set
+
+#
+# ndisc6............................ IPv6 discovery tools
+#
+# BR2_PACKAGE_NDISC6 is not set
+# BR2_PACKAGE_RDISC6 is not set
+# BR2_PACKAGE_TCPTRACEROUTE6 is not set
+# BR2_PACKAGE_RADVD is not set
+
+#
+# Libraries
+#
+# BR2_PACKAGE_CGILIB is not set
+# BR2_PACKAGE_GLIB1 is not set
+# BR2_PACKAGE_ID3LIB is not set
+# BR2_PACKAGE_LIBAMSEL is not set
+# BR2_PACKAGE_LIBAO is not set
+# BR2_PACKAGE_LIBART is not set
+# BR2_PACKAGE_LIBCLI is not set
+# BR2_PACKAGE_LIBCURL is not set
+# BR2_PACKAGE_LIBDAEMON is not set
+# BR2_PACKAGE_LIBDB is not set
+# BR2_PACKAGE_LIBDNET is not set
+# BR2_PACKAGE_LIBELF is not set
+# BR2_PACKAGE_LIBEVENT is not set
+# BR2_PACKAGE_LIBEXPAT is not set
+# BR2_PACKAGE_LIBFLAC is not set
+# BR2_PACKAGE_LIBFREETYPE is not set
+# BR2_PACKAGE_LIBGCRYPT is not set
+# BR2_PACKAGE_LIBGD is not set
+# BR2_PACKAGE_LIBGDBM is not set
+# BR2_PACKAGE_LIBGMP is not set
+# BR2_PACKAGE_LIBGNUTLS is not set
+# BR2_PACKAGE_LIBGPG_ERROR is not set
+# BR2_PACKAGE_LIBGSM is not set
+# BR2_PACKAGE_LIBID3TAG is not set
+# BR2_PACKAGE_LIBJPEG is not set
+# BR2_PACKAGE_LIBLTDL is not set
+# BR2_PACKAGE_LIBLZO is not set
+# BR2_PACKAGE_LIBMAD is not set
+# BR2_PACKAGE_LIBMATRIXSSL is not set
+# BR2_PACKAGE_LIBMYSQLCLIENT is not set
+BR2_COMPILE_NCURSES=m
+BR2_PACKAGE_LIBNCURSES=m
+# BR2_PACKAGE_LIBNET is not set
+# BR2_PACKAGE_LIBNIDS is not set
+# BR2_PACKAGE_LIBOGG is not set
+# BR2_PACKAGE_LIBOPENCDK is not set
+# BR2_PACKAGE_LIBOPENLDAP is not set
+BR2_COMPILE_OPENSSL=m
+BR2_PACKAGE_LIBOPENSSL=m
+# BR2_PACKAGE_OPENSSL_UTIL is not set
+# BR2_PACKAGE_LIBOSIP2 is not set
+BR2_PACKAGE_LIBPCAP=m
+# BR2_PACKAGE_LIBPCRE is not set
+# BR2_PACKAGE_LIBPNG is not set
+# BR2_PACKAGE_LIBPOPT is not set
+# BR2_PACKAGE_LIBPQ is not set
+# BR2_PACKAGE_LIBPTHREAD is not set
+# BR2_PACKAGE_LIBREADLINE is not set
+# BR2_PACKAGE_LIBSASL2 is not set
+# BR2_PACKAGE_LIBSPEEX is not set
+# BR2_PACKAGE_LIBSQLITE is not set
+# BR2_PACKAGE_LIBSQLITE2 is not set
+# BR2_PACKAGE_LIBTASN1 is not set
+# BR2_PACKAGE_LIBUPNP is not set
+# BR2_PACKAGE_LIBUSB is not set
+# BR2_PACKAGE_LIBVORBIS is not set
+# BR2_PACKAGE_LIBVORBISIDEC is not set
+# BR2_PACKAGE_LIBXML2 is not set
+# BR2_PACKAGE_LIBXSLT is not set
+# BR2_PACKAGE_UCLIBCXX is not set
+# BR2_PACKAGE_USTL is not set
+BR2_PACKAGE_ZLIB=y
+
+#
+# Multimedia
+#
+# BR2_PACKAGE_GMEDIASERVER is not set
+# BR2_PACKAGE_ICECAST is not set
+# BR2_PACKAGE_MADPLAY is not set
+
+#
+# mpd............................... Music Player Daemon
+#
+# BR2_PACKAGE_MPD is not set
+# BR2_PACKAGE_MT_DAAPD is not set
+# BR2_PACKAGE_PALANTIR is not set
+# BR2_PACKAGE_PEERCAST is not set
+# BR2_PACKAGE_SETPWC is not set
+
+#
+# Serial communications & terminal emulation
+#
+# BR2_PACKAGE_MICROCOM is not set
+# BR2_PACKAGE_PICOCOM is not set
+# BR2_PACKAGE_SERDISPLIB is not set
+# BR2_PACKAGE_SETSERIAL is not set
+
+#
+# Utilities
+#
+# BR2_PACKAGE_BC is not set
+# BR2_PACKAGE_DC is not set
+# BR2_PACKAGE_GDBSERVER is not set
+# BR2_PACKAGE_MADWIFI_TOOLS is not set
+# BR2_PACKAGE_LSUSB is not set
+# BR2_PACKAGE_STRACE is not set
+# BR2_PACKAGE_UDEV is not set
+
+#
+# FileSystems related
+#
+# BR2_PACKAGE_DOSFSTOOLS is not set
+# BR2_PACKAGE_E2FSPROGS is not set
+# BR2_PACKAGE_LIBFUSE is not set
+# BR2_PACKAGE_SHFS_UTILS is not set
+
+#
+# util-linux
+#
+# BR2_PACKAGE_FDISK is not set
+# BR2_PACKAGE_LOSETUP is not set
+# BR2_PACKAGE_SWAP_UTILS is not set
+
+#
+# Bluetooth
+#
+# BR2_PACKAGE_BLUEZ_LIBS is not set
+# BR2_PACKAGE_BLUEZ_UTILS is not set
+# BR2_PACKAGE_MIAX is not set
+
+#
+# Extra stuff
+#
+# BR2_PACKAGE_SDK is not set
+# BR2_PACKAGE_IMAGEBUILDER is not set
+
+#
+# Runtime Configuration
+#
+BR2_SYSCONF_TELNET_FAILSAFE_ONLY=y
+# BR2_SYSCONF_TELNET_OPEN is not set
+
+#
+# Failsafe configuration
+#
+BR2_SYSCONF_FAILSAFE_IP="192.168.2.1"
+BR2_SYSCONF_FAILSAFE_NETMASK="255.255.255.0"
+BR2_SYSCONF_FAILSAFE_MAC="00:00:BA:DC:0D:ED"
+
+#
+# Target Root Filesystem
+#
+# BR2_TARGET_ROOTFS_JFFS2 is not set
+BR2_TARGET_ROOTFS_SQUASHFS_LZMA=y
+# BR2_TARGET_ROOTFS_TGZ is not set
+
+#
+# Kernel Configuration / Device Support
+#
+# BR2_LINUX_2_4_BRCM is not set
+BR2_LINUX_2_4_AR7=y
+# BR2_LINUX_2_4_X86 is not set
+# BR2_LINUX_2_6_BRCM is not set
+# BR2_LINUX_2_6_X86 is not set
+# BR2_LINUX_2_4_AR531X is not set
+# BR2_LINUX_2_4_WAX is not set
+BR2_LINUX_2_4_SINUS154=y
+
+#
+# Device variants
+#
+BR2_LINUX_2_4_SINUS154_DSL_BASIC_SE=y
+# BR2_LINUX_2_4_SINUS154_DSL_BASIC_3 is not set
+
+#
+# Device specific modules
+#
+BR2_PACKAGE_KMOD_CPMAC=y
+BR2_PACKAGE_KMOD_SANGAM_ATM_A=m
+BR2_PACKAGE_KMOD_SANGAM_ATM_B=m
+
+#
+# Networking modules
+#
+BR2_PACKAGE_KMOD_ATM=m
+# BR2_PACKAGE_KMOD_GRE is not set
+# BR2_PACKAGE_KMOD_IPV6 is not set
+BR2_PACKAGE_KMOD_PPP=y
+BR2_PACKAGE_KMOD_MPPE=m
+BR2_PACKAGE_KMOD_PPPOATM=m
+BR2_PACKAGE_KMOD_PPPOE=y
+BR2_PACKAGE_KMOD_SCHED=m
+BR2_PACKAGE_KMOD_TUN=m
+
+#
+# Filtering/Firewalling
+#
+BR2_PACKAGE_KMOD_ARPTABLES=m
+BR2_PACKAGE_KMOD_EBTABLES=m
+BR2_PACKAGE_KMOD_IPTABLES=y
+BR2_PACKAGE_KMOD_IPTABLES_EXTRA=m
+BR2_PACKAGE_KMOD_IPT_CONNTRACK=m
+BR2_PACKAGE_KMOD_IPT_FILTER=m
+BR2_PACKAGE_KMOD_IPT_IPOPT=m
+BR2_PACKAGE_KMOD_IPT_IPSEC=m
+BR2_PACKAGE_KMOD_IPT_NAT=m
+BR2_PACKAGE_KMOD_IPT_NAT_EXTRA=m
+BR2_PACKAGE_KMOD_IPT_QUEUE=m
+BR2_PACKAGE_KMOD_IPT_ULOG=m
+BR2_PACKAGE_KMOD_IPT_EXTRA=m
+
+#
+# Block devices support
+#
+# BR2_PACKAGE_KMOD_IDE is not set
+BR2_PACKAGE_KMOD_LOOP=m
+BR2_PACKAGE_KMOD_NBD=m
+
+#
+# Cryptographic support
+#
+BR2_PACKAGE_KMOD_CRYPTO=m
+
+#
+# Filesystems support
+#
+# BR2_PACKAGE_KMOD_CIFS is not set
+# BR2_PACKAGE_KMOD_FS_EXT2 is not set
+# BR2_PACKAGE_KMOD_FS_EXT3 is not set
+# BR2_PACKAGE_KMOD_FS_HFSPLUS is not set
+BR2_PACKAGE_KMOD_FS_NFS=y
+# BR2_PACKAGE_KMOD_FS_VFAT is not set
+# BR2_PACKAGE_KMOD_FS_XFS is not set
+
+#
+# Multimedia devices support
+#
+# BR2_PACKAGE_KMOD_PWC is not set
+# BR2_PACKAGE_KMOD_SOUNDCORE is not set
+# BR2_PACKAGE_KMOD_VIDEODEV is not set
+
+#
+# Native Language support
+#
+# BR2_PACKAGE_KMOD_NLS_BASE is not set
+
+#
+# Network devices support
+#
+# BR2_PACKAGE_KMOD_NET_3C59X is not set
+# BR2_PACKAGE_KMOD_NET_8139TOO is not set
+# BR2_PACKAGE_KMOD_NET_AIRO is not set
+# BR2_PACKAGE_KMOD_NET_E100 is not set
+# BR2_PACKAGE_KMOD_NET_B44 is not set
+# BR2_PACKAGE_KMOD_NET_HERMES is not set
+# BR2_PACKAGE_KMOD_NET_NATSEMI is not set
+# BR2_PACKAGE_KMOD_NET_PRISM54 is not set
+
+#
+# PCMCIA/CardBus support
+#
+
+#
+# USB support
+#
+# BR2_PACKAGE_KMOD_USB is not set
+
+#
+# Misc. devices support
+#
+# BR2_PACKAGE_KMOD_AX25 is not set
+# BR2_PACKAGE_KMOD_BLUETOOTH is not set
+# BR2_PACKAGE_KMOD_LP is not set
+
+#
+# Additional kernel modules
+#
+BR2_PACKAGE_KMOD_DIAG=y
+# BR2_PACKAGE_KMOD_FUSE is not set
+# BR2_PACKAGE_KMOD_HOSTAP is not set
+# BR2_PACKAGE_KMOD_IEEE80211_DSCAPE is not set
+BR2_PACKAGE_KMOD_MADWIFI=m
+# BR2_PACKAGE_KMOD_MINI_FO is not set
+# BR2_PACKAGE_KMOD_OPENSWAN is not set
+# BR2_PACKAGE_KMOD_SHFS is not set
+# BR2_PACKAGE_KMOD_SPCA5XX is not set
+# BR2_PACKAGE_KMOD_SWITCH is not set
Index: target/linux/linux-2.4/ar7.mk
===================================================================
--- target/linux/linux-2.4/ar7.mk	(Revision 2793)
+++ target/linux/linux-2.4/ar7.mk	(Arbeitskopie)
@@ -28,15 +28,18 @@
 drivers-clean:
 	rm -rf $(BUILD_DIR)/$(ATM_FIRMWARE_DIR)
 
+#$(eval $(call KMOD_template,DIAG,diag,\
+#	$(MODULES_DIR)/kernel/drivers/net/diag/diag.o \
+#))
 
 $(eval $(call KMOD_template,SANGAM_ATM_A,sangam-atm-annex-a,\
-	$(MODULES_DIR)/kernel/drivers/atm/tiatm.o \
+	$(MODULES_DIR)/kernel/drivers/atm/sangam_atm/tiatm.o \
 ,CONFIG_MIPS_SANGAM_ATM,kmod-atm,60,tiatm, \
 	cp $(BUILD_DIR)/$(ATM_FIRMWARE_DIR)/ar0700xx_a.bin $$(I_SANGAM_ATM_A)/lib/modules/ar0700xx.bin \
 ))
 
 $(eval $(call KMOD_template,SANGAM_ATM_B,sangam-atm-annex-b,\
-	$(MODULES_DIR)/kernel/drivers/atm/tiatm.o \
+	$(MODULES_DIR)/kernel/drivers/atm/sangam_atm/tiatm.o \
 ,CONFIG_MIPS_SANGAM_ATM,kmod-atm,60,tiatm, \
 	cp $(BUILD_DIR)/$(ATM_FIRMWARE_DIR)/ar0700xx_b.bin $$(I_SANGAM_ATM_B)/lib/modules/ar0700xx.bin \
 ))
Index: target/linux/linux-2.4/config/ar7
===================================================================
--- target/linux/linux-2.4/config/ar7	(Revision 2793)
+++ target/linux/linux-2.4/config/ar7	(Arbeitskopie)
@@ -77,6 +77,7 @@
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SIBYTE_SB1xxx_SOC is not set
+CONFIG_MIPS_SINUS154=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TANBAC_TB0226 is not set
 # CONFIG_TANBAC_TB0229 is not set
@@ -172,27 +173,29 @@
 #
 # Memory Technology Devices (MTD)
 #
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD=m
+CONFIG_MTD_DEBUG=y
+CONFIG_MTD_DEBUG_VERBOSE=3
+CONFIG_MTD_PARTITIONS=m
+CONFIG_MTD_CONCAT=m
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
 #
 # User Modules And Translation Layers
 #
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_BLOCK_RO=m
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 
 #
 # RAM/ROM/Flash chip drivers
 #
-CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI=m
 # CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_GEN_PROBE=m
 CONFIG_MTD_CFI_ADV_OPTIONS=y
 CONFIG_MTD_CFI_NOSWAP=y
 # CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
@@ -206,10 +209,10 @@
 # CONFIG_MTD_CFI_I2 is not set
 # CONFIG_MTD_CFI_I4 is not set
 # CONFIG_MTD_CFI_I8 is not set
-CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_STAA is not set
-# CONFIG_MTD_CFI_SSTSTD is not set
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_MTD_CFI_STAA=m
+CONFIG_MTD_CFI_SSTSTD=m
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
@@ -222,10 +225,10 @@
 # Mapping drivers for chip access
 #
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_AR7=y
-CONFIG_MTD_AR7_DEFAULTS=y
+CONFIG_MTD_AR7=m
+# CONFIG_MTD_AR7_DEFAULTS is not set
 CONFIG_MTD_AR7_START=0x10000000
-CONFIG_MTD_AR7_LEN=0x400000
+CONFIG_MTD_AR7_LEN=0x200000
 CONFIG_MTD_AR7_BUSWIDTH=2
 # CONFIG_MTD_PB1000 is not set
 # CONFIG_MTD_PB1500 is not set
@@ -325,7 +328,10 @@
 CONFIG_IP_ROUTE_MULTIPATH=y
 CONFIG_IP_ROUTE_TOS=y
 # CONFIG_IP_ROUTE_VERBOSE is not set
-# CONFIG_IP_PNP is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
 CONFIG_NET_IPIP=m
 CONFIG_NET_IPGRE=m
 # CONFIG_NET_IPGRE_BROADCAST is not set
@@ -533,83 +539,9 @@
 #
 # SCSI support
 #
-CONFIG_SCSI=m
+# CONFIG_SCSI is not set
 
 #
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=m
-CONFIG_SD_EXTRA_DEVS=5
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-CONFIG_CHR_DEV_SG=m
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_DEBUG_QUEUES is not set
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_SCSI_7000FASST is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AHA1542 is not set
-# CONFIG_SCSI_AHA1740 is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_MEGARAID is not set
-# CONFIG_SCSI_MEGARAID2 is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_SATA_AHCI is not set
-# CONFIG_SCSI_SATA_SVW is not set
-# CONFIG_SCSI_ATA_PIIX is not set
-# CONFIG_SCSI_SATA_NV is not set
-# CONFIG_SCSI_SATA_QSTOR is not set
-# CONFIG_SCSI_SATA_PROMISE is not set
-# CONFIG_SCSI_SATA_SX4 is not set
-# CONFIG_SCSI_SATA_SIL is not set
-# CONFIG_SCSI_SATA_SIS is not set
-# CONFIG_SCSI_SATA_ULI is not set
-# CONFIG_SCSI_SATA_VIA is not set
-# CONFIG_SCSI_SATA_VITESSE is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_DMA is not set
-# CONFIG_SCSI_EATA_PIO is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_NCR53C406A is not set
-# CONFIG_SCSI_NCR53C7xx is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PCI2000 is not set
-# CONFIG_SCSI_PCI2220I is not set
-# CONFIG_SCSI_PSI240I is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_SIM710 is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_U14_34F is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
@@ -639,7 +571,7 @@
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-CONFIG_MIPS_AVALANCHE_CPMAC=m
+CONFIG_MIPS_AVALANCHE_CPMAC=y
 CONFIG_MIPS_CPMAC_INIT_BUF_MALLOC=y
 CONFIG_MIPS_CPMAC_PORTS=1
 CONFIG_AVALANCHE_CPMAC_AUTO=y
@@ -701,7 +633,7 @@
 # Prism54 PCI/PCMCIA GT/Duette Driver - 802.11(a/b/g)
 #
 # CONFIG_PRISM54 is not set
-# CONFIG_NET_WIRELESS is not set
+CONFIG_NET_WIRELESS=y
 
 #
 # Token Ring devices
@@ -834,33 +766,34 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
-CONFIG_HFSPLUS_FS=m
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
-CONFIG_EXT3_FS=m
-CONFIG_JBD=m
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
 # CONFIG_JBD_DEBUG is not set
-CONFIG_FAT_FS=m
+# CONFIG_FAT_FS is not set
 # CONFIG_MSDOS_FS is not set
 # CONFIG_UMSDOS_FS is not set
-CONFIG_VFAT_FS=m
+# CONFIG_VFAT_FS is not set
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS is not set
 # CONFIG_JFFS2_BBC_ARMLIB is not set
 # CONFIG_JFFS2_BBC_LZO is not set
-CONFIG_JFFS2_BBC_LZARI=y
+# CONFIG_JFFS2_BBC_LZARI is not set
 # CONFIG_JFFS2_BBC_LZHD is not set
 # CONFIG_JFFS2_BBC_LZSS is not set
 # CONFIG_CRAMFS is not set
 CONFIG_SQUASHFS=y
-# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
 CONFIG_TMPFS=y
 CONFIG_RAMFS=y
-CONFIG_ISO9660_FS=m
-CONFIG_JOLIET=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
 # CONFIG_ZISOFS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_JFS_DEBUG is not set
@@ -878,13 +811,13 @@
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_QNX4FS_RW is not set
 # CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UDF_FS is not set
 # CONFIG_UDF_RW is not set
 # CONFIG_UFS_FS is not set
 # CONFIG_UFS_FS_WRITE is not set
-CONFIG_XFS_FS=m
+# CONFIG_XFS_FS is not set
 # CONFIG_XFS_QUOTA is not set
 # CONFIG_XFS_RT is not set
 # CONFIG_XFS_TRACE is not set
@@ -895,15 +828,15 @@
 #
 # CONFIG_CODA_FS is not set
 # CONFIG_INTERMEZZO_FS is not set
-CONFIG_NFS_FS=m
+CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_DIRECTIO is not set
-# CONFIG_ROOT_NFS is not set
+CONFIG_ROOT_NFS=y
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
 # CONFIG_NFSD_TCP is not set
-CONFIG_SUNRPC=m
-CONFIG_LOCKD=m
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_CIFS=m
 # CONFIG_CIFS_STATS is not set
@@ -923,22 +856,8 @@
 #
 # Partition Types
 #
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_ACORN_PARTITION is not set
-# CONFIG_OSF_PARTITION is not set
-# CONFIG_AMIGA_PARTITION is not set
-# CONFIG_ATARI_PARTITION is not set
-CONFIG_MAC_PARTITION=y
+# CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_UNIXWARE_DISKLABEL is not set
-# CONFIG_LDM_PARTITION is not set
-# CONFIG_SGI_PARTITION is not set
-# CONFIG_ULTRIX_PARTITION is not set
-# CONFIG_SUN_PARTITION is not set
-# CONFIG_EFI_PARTITION is not set
 # CONFIG_SMB_NLS is not set
 CONFIG_NLS=y
 
@@ -1007,38 +926,16 @@
 #
 # Bluetooth support
 #
-CONFIG_BLUEZ=m
-CONFIG_BLUEZ_L2CAP=m
-CONFIG_BLUEZ_SCO=m
-CONFIG_BLUEZ_RFCOMM=m
-CONFIG_BLUEZ_RFCOMM_TTY=y
-CONFIG_BLUEZ_BNEP=m
-CONFIG_BLUEZ_BNEP_MC_FILTER=y
-CONFIG_BLUEZ_BNEP_PROTO_FILTER=y
+# CONFIG_BLUEZ is not set
 
 #
-# Bluetooth device drivers
-#
-# CONFIG_BLUEZ_HCIUSB is not set
-CONFIG_BLUEZ_HCIUART=m
-CONFIG_BLUEZ_HCIUART_H4=y
-CONFIG_BLUEZ_HCIUART_BCSP=y
-CONFIG_BLUEZ_HCIUART_BCSP_TXCRC=y
-# CONFIG_BLUEZ_HCIBFUSB is not set
-# CONFIG_BLUEZ_HCIDTL1 is not set
-# CONFIG_BLUEZ_HCIBT3C is not set
-# CONFIG_BLUEZ_HCIBLUECARD is not set
-# CONFIG_BLUEZ_HCIBTUART is not set
-# CONFIG_BLUEZ_HCIVHCI is not set
-
-#
 # Kernel hacking
 #
 CONFIG_CROSSCOMPILE=y
-# CONFIG_RUNTIME_DEBUG is not set
-# CONFIG_KGDB is not set
-# CONFIG_GDB_CONSOLE is not set
-# CONFIG_DEBUG_INFO is not set
+CONFIG_RUNTIME_DEBUG=y
+CONFIG_KGDB=y
+CONFIG_GDB_CONSOLE=y
+CONFIG_DEBUG_INFO=y
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_MIPS_UNCACHED is not set
 CONFIG_LOG_BUF_SHIFT=0
@@ -1075,5 +972,5 @@
 #
 # CONFIG_CRC32 is not set
 CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
+CONFIG_ZLIB_DEFLATE=m
 # CONFIG_FW_LOADER is not set
Index: target/linux/linux-2.4/patches/ar7/000-ar7_support.patch
===================================================================
--- target/linux/linux-2.4/patches/ar7/000-ar7_support.patch	(Revision 2793)
+++ target/linux/linux-2.4/patches/ar7/000-ar7_support.patch	(Arbeitskopie)
@@ -1959,7 +1959,7 @@
 +		int line;
 +		argptr += strlen("kgdb=ttyS");
 +		if (*argptr != '0' && *argptr != '1')
-+			printk("KGDB: Uknown serial line /dev/ttyS%c, "
++			printk("KGDB: Unknown serial line /dev/ttyS%c, "
 +					"falling back to /dev/ttyS1\n", *argptr);
 +		line = *argptr == '0' ? 0 : 1;
 +		printk("KGDB: Using serial line /dev/ttyS%d for session\n",
Index: target/linux/linux-2.4/patches/ar7/020-pretty.patch
===================================================================
--- target/linux/linux-2.4/patches/ar7/020-pretty.patch	(Revision 0)
+++ target/linux/linux-2.4/patches/ar7/020-pretty.patch	(Revision 0)
@@ -0,0 +1,41 @@
+diff -urN linux-2.4.30/drivers/net/avalanche_cpmac/cpmac_reg.h linux-2.4.30.new/drivers/net/avalanche_cpmac/cpmac_reg.h
+--- linux-2.4.30/drivers/net/avalanche_cpmac/cpmac_reg.h	2005-11-12 23:17:10.000000000 +0100
++++ linux-2.4.30.new/drivers/net/avalanche_cpmac/cpmac_reg.h	2005-11-07 21:10:16.000000000 +0100
+@@ -403,4 +403,4 @@
+ #define RX_QOS_ACT               (1 << 2)
+ #define RX_FLOW_ACT              (1 << 1)
+ #define TX_FLOW_ACT              (1 << 0)
+-#endif _INC_CPMAC_REG
++#endif // _INC_CPMAC_REG
+diff -urN linux-2.4.30/include/asm-mips/ar7/avalanche_regs.h linux-2.4.30.new/include/asm-mips/ar7/avalanche_regs.h
+--- linux-2.4.30/include/asm-mips/ar7/avalanche_regs.h	2005-11-12 23:17:52.000000000 +0100
++++ linux-2.4.30.new/include/asm-mips/ar7/avalanche_regs.h	2005-11-07 21:10:16.000000000 +0100
+@@ -558,10 +558,4 @@
+ 
+ #define VMAC_STATS_BASE(X)     (X + 0x00000400)
+ 
+-#endif __AVALANCHE_REGS_H
+-
+-
+-
+-
+-
+-
++#endif /* __AVALANCHE_REGS_H */
+diff -urN linux-2.4.30/net/ipv4/netfilter/ip_conntrack_core.c linux-2.4.30.new/net/ipv4/netfilter/ip_conntrack_core.c
+--- linux-2.4.30/net/ipv4/netfilter/ip_conntrack_core.c	2005-11-12 23:17:05.000000000 +0100
++++ linux-2.4.30.new/net/ipv4/netfilter/ip_conntrack_core.c	2005-11-07 21:10:16.000000000 +0100
+@@ -1469,10 +1469,13 @@
+ 	WRITE_UNLOCK(&ip_conntrack_lock);
+ 
+ 	for (i = 0; i < ip_conntrack_htable_size; i++)
++	{
+ 		INIT_LIST_HEAD(&ip_conntrack_hash[i]);
++	}
+ 
+ 	/* For use by ipt_REJECT */
+ 	ip_ct_attach = ip_conntrack_attach;
++	
+ 	return ret;
+ 
+ err_free_hash:
Index: target/linux/linux-2.4/patches/ar7/021-debug.patch
===================================================================
--- target/linux/linux-2.4/patches/ar7/021-debug.patch	(Revision 0)
+++ target/linux/linux-2.4/patches/ar7/021-debug.patch	(Revision 0)
@@ -0,0 +1,127 @@
+diff -urN linux-2.4.30/drivers/char/avalanche_vlynq/vlynq_hal.c linux-2.4.30.new/drivers/char/avalanche_vlynq/vlynq_hal.c
+--- linux-2.4.30/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-11-12 23:17:09.000000000 +0100
++++ linux-2.4.30.new/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-11-07 21:10:16.000000000 +0100
+@@ -519,7 +519,9 @@
+     VLYNQ_INT_STAT_REG = interrupts; /* clear the int CR register */
+     clrInterrupts = interrupts;      /* save them for further analysis */
+ 
++#if 0
+     debugPrint("vlynq_root_isr: dev %u. INTCR = 0x%08lx\n", pdev->dev_idx, clrInterrupts,0,0,0,0);
++#endif
+ 
+     /* Scan interrupt bits */
+     source =0;
+diff -urN linux-2.4.30/drivers/mtd/chips/cfi_cmdset_0001.c linux-2.4.30.new/drivers/mtd/chips/cfi_cmdset_0001.c
+--- linux-2.4.30/drivers/mtd/chips/cfi_cmdset_0001.c	2004-11-17 12:54:21.000000000 +0100
++++ linux-2.4.30.new/drivers/mtd/chips/cfi_cmdset_0001.c	2005-11-07 21:10:16.000000000 +0100
+@@ -65,7 +65,7 @@
+ };
+ 
+ /* #define DEBUG_LOCK_BITS */
+-/* #define DEBUG_CFI_FEATURES */
++#define DEBUG_CFI_FEATURES
+ 
+ #ifdef DEBUG_CFI_FEATURES
+ static void cfi_tell_features(struct cfi_pri_intelext *extp)
+diff -urN linux-2.4.30/drivers/mtd/chips/cfi_probe.c linux-2.4.30.new/drivers/mtd/chips/cfi_probe.c
+--- linux-2.4.30/drivers/mtd/chips/cfi_probe.c	2005-11-12 23:17:02.000000000 +0100
++++ linux-2.4.30.new/drivers/mtd/chips/cfi_probe.c	2005-11-07 21:10:16.000000000 +0100
+@@ -18,7 +18,7 @@
+ #include <linux/mtd/cfi.h>
+ #include <linux/mtd/gen_probe.h>
+ 
+-//#define DEBUG_CFI 
++#define DEBUG_CFI 
+ 
+ #ifdef DEBUG_CFI
+ static void print_cfi_ident(struct cfi_ident *);
+diff -urN linux-2.4.30/drivers/net/avalanche_cpmac/cpmacHalLx.c linux-2.4.30.new/drivers/net/avalanche_cpmac/cpmacHalLx.c
+--- linux-2.4.30/drivers/net/avalanche_cpmac/cpmacHalLx.c	2005-11-12 23:17:10.000000000 +0100
++++ linux-2.4.30.new/drivers/net/avalanche_cpmac/cpmacHalLx.c	2005-11-07 21:10:16.000000000 +0100
+@@ -370,10 +370,13 @@
+     int ret_val = 0;
+     int count   = 0;
+ 
++    dbgPrint("%s:%u\n", __FILE__, __LINE__);
++
+     /* Let's setup the TX Channels. */
+     for(;  p_tx_chan_info->opened_chan > 0; 
+         p_tx_chan_info->opened_chan--, count++)
+     {
++	dbgPrint("%s:%u\n", __FILE__, __LINE__);
+         if(p_hal_funcs->ChannelTeardown(p_hal_dev, count, flags) != 0)
+         {
+             errPrint("Error in tearing down channel %d for TX.\n", count);
+diff -urN linux-2.4.30/drivers/net/avalanche_cpmac/psp_config_build.c linux-2.4.30.new/drivers/net/avalanche_cpmac/psp_config_build.c
+--- linux-2.4.30/drivers/net/avalanche_cpmac/psp_config_build.c	2005-11-12 23:17:10.000000000 +0100
++++ linux-2.4.30.new/drivers/net/avalanche_cpmac/psp_config_build.c	2005-11-07 21:10:16.000000000 +0100
+@@ -127,6 +127,8 @@
+             phy_sel = SELECT_INT_PHY_MAC;
+         }
+ 
++	printk("%s:%d detected cpmac_phy = %d\n", __FILE__, __LINE__, auto_detect_cpmac_phy());
++
+         //if(phy_sel == auto_detect_cpmac_phy())
+         if(!mac_port || (0 != strcmp(mac_port, "0")))
+         {
+diff -urN linux-2.4.30/fs/jffs2/nodemgmt.c linux-2.4.30.new/fs/jffs2/nodemgmt.c
+--- linux-2.4.30/fs/jffs2/nodemgmt.c	2002-08-03 02:39:45.000000000 +0200
++++ linux-2.4.30.new/fs/jffs2/nodemgmt.c	2005-11-07 21:10:16.000000000 +0100
+@@ -87,6 +87,7 @@
+ 			int ret;
+ 
+ 			up(&c->alloc_sem);
++			D1(printk(KERN_DEBUG "free = %u, erasing = %u, needed = %u\n", c->nr_free_blocks, c->nr_erasing_blocks, blocksneeded));
+ 			if (c->dirty_size < c->sector_size) {
+ 				D1(printk(KERN_DEBUG "Short on space, but total dirty size 0x%08x < sector size 0x%08x, so -ENOSPC\n", c->dirty_size, c->sector_size));
+ 				spin_unlock_bh(&c->erase_completion_lock);
+diff -urN linux-2.4.30/fs/jffs2/pushpull.c linux-2.4.30.new/fs/jffs2/pushpull.c
+--- linux-2.4.30/fs/jffs2/pushpull.c	2001-10-05 00:13:18.000000000 +0200
++++ linux-2.4.30.new/fs/jffs2/pushpull.c	2005-11-07 21:10:16.000000000 +0100
+@@ -35,9 +35,10 @@
+  *
+  */
+ 
++#include <linux/errno.h>
++#include <linux/kernel.h>
+ #include <linux/string.h>
+ #include "pushpull.h"
+-#include <linux/errno.h>
+ 
+ void init_pushpull(struct pushpull *pp, char *buf, unsigned buflen, unsigned ofs, unsigned reserve)
+ {
+@@ -51,6 +52,7 @@
+ int pushbit(struct pushpull *pp, int bit, int use_reserved)
+ {
+ 	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve)) {
++		printk("%s:%d no space", __FILE__, __LINE__);
+ 		return -ENOSPC;
+ 	}
+ 
+diff -urN linux-2.4.30/fs/nfs/nfsroot.c linux-2.4.30.new/fs/nfs/nfsroot.c
+--- linux-2.4.30/fs/nfs/nfsroot.c	2003-08-25 13:44:43.000000000 +0200
++++ linux-2.4.30.new/fs/nfs/nfsroot.c	2005-11-07 21:10:16.000000000 +0100
+@@ -86,6 +86,7 @@
+ 
+ /* Define this to allow debugging output */
+ #undef NFSROOT_DEBUG
++#define NFSROOT_DEBUG
+ #define NFSDBG_FACILITY NFSDBG_ROOT
+ 
+ /* Default path we try to mount. "%s" gets replaced by our IP address */
+diff -urN linux-2.4.30/fs/proc/generic.c linux-2.4.30.new/fs/proc/generic.c
+--- linux-2.4.30/fs/proc/generic.c	2005-01-19 15:10:11.000000000 +0100
++++ linux-2.4.30.new/fs/proc/generic.c	2005-11-07 21:10:16.000000000 +0100
+@@ -446,6 +446,12 @@
+ 	ent->mode = mode;
+ 	ent->nlink = nlink;
+  out:
++#if defined(DEBUG) || 1
++	if (ent == 0) {
++		printk("%s:%u failed to create proc entry %s\n",
++				__FILE__, __LINE__, name);
++	}
++#endif
+ 	return ent;
+ }
+ 
Index: target/linux/linux-2.4/patches/ar7/011-sinus.patch
===================================================================
--- target/linux/linux-2.4/patches/ar7/011-sinus.patch	(Revision 0)
+++ target/linux/linux-2.4/patches/ar7/011-sinus.patch	(Revision 0)
@@ -0,0 +1,5651 @@
+diff -urN linux-2.4.32/arch/mips/ar7/cmdline.c linux-2.4.32.new/arch/mips/ar7/cmdline.c
+--- linux-2.4.32/arch/mips/ar7/cmdline.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/cmdline.c	2005-12-27 21:44:16.000000000 +0100
+@@ -17,13 +17,12 @@
+  *
+  * Kernel command line creation using the prom monitor (YAMON) argc/argv.
+  */
++#include <linux/config.h>
+ #include <linux/init.h>
+ #include <linux/string.h>
+ 
+ #include <asm/bootinfo.h>
+-
+-extern int prom_argc;
+-extern int *_prom_argv;
++#include <asm/ar7/adam2_env.h>	/* prom_getenv, prom_argc, ... */
+ 
+ /*
+  * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+diff -urN linux-2.4.32/arch/mips/ar7/gdb_hook.c linux-2.4.32.new/arch/mips/ar7/gdb_hook.c
+--- linux-2.4.32/arch/mips/ar7/gdb_hook.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/gdb_hook.c	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,136 @@
++/*
++ * Carsten Langgaard, carstenl@mips.com
++ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
++ *
++ * ########################################################################
++ *
++ *  This program is free software; you can distribute it and/or modify it
++ *  under the terms of the GNU General Public License (Version 2) as
++ *  published by the Free Software Foundation.
++ *
++ *  This program is distributed in the hope it will be useful, but WITHOUT
++ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ *  for more details.
++ *
++ *  You should have received a copy of the GNU General Public License along
++ *  with this program; if not, write to the Free Software Foundation, Inc.,
++ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
++ *
++ * ########################################################################
++ *
++ * This is the interface to the remote debugger stub.
++ *
++ */
++#include <linux/config.h>
++#include <linux/serialP.h>
++#include <linux/serial_reg.h>
++
++#include <asm/serial.h>
++#include <asm/io.h>
++
++static struct serial_state rs_table[RS_TABLE_SIZE] = {
++	SERIAL_PORT_DFNS	/* Defined in serial.h */
++};
++
++static struct async_struct kdb_port_info = {0};
++
++int (*generic_putDebugChar)(char);
++char (*generic_getDebugChar)(void);
++
++static __inline__ unsigned int serial_in(struct async_struct *info, int offset)
++{
++	return inb(info->port + offset);
++}
++
++static __inline__ void serial_out(struct async_struct *info, int offset,
++				int value)
++{
++	outb(value, info->port+offset);
++}
++
++void rs_kgdb_hook(int tty_no) {
++	int t;
++	struct serial_state *ser = &rs_table[tty_no];
++
++	kdb_port_info.state = ser;
++	kdb_port_info.magic = SERIAL_MAGIC;
++	kdb_port_info.port = ser->port;
++	kdb_port_info.flags = ser->flags;
++
++	/*
++	 * Clear all interrupts
++	 */
++	serial_in(&kdb_port_info, UART_LSR);
++	serial_in(&kdb_port_info, UART_RX);
++	serial_in(&kdb_port_info, UART_IIR);
++	serial_in(&kdb_port_info, UART_MSR);
++
++	/*
++	 * Now, initialize the UART
++	 */
++	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
++	if (kdb_port_info.flags & ASYNC_FOURPORT) {
++		kdb_port_info.MCR = UART_MCR_DTR | UART_MCR_RTS;
++		t = UART_MCR_DTR | UART_MCR_OUT1;
++	} else {
++		kdb_port_info.MCR
++			= UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2;
++		t = UART_MCR_DTR | UART_MCR_RTS;
++	}
++
++	kdb_port_info.MCR = t;		/* no interrupts, please */
++	serial_out(&kdb_port_info, UART_MCR, kdb_port_info.MCR);
++
++	/*
++	 * and set the speed of the serial port
++	 * (currently hardwired to 115200 8N1
++	 */
++
++	/* baud rate is fixed to 115200 (is this sufficient?)*/
++	t = kdb_port_info.state->baud_base / 115200;
++	/* set DLAB */
++	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
++	serial_out(&kdb_port_info, UART_DLL, t & 0xff);/* LS of divisor */
++	serial_out(&kdb_port_info, UART_DLM, t >> 8);  /* MS of divisor */
++	/* reset DLAB */
++	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);
++}
++
++int putDebugChar(char c)
++{
++	return generic_putDebugChar(c);
++}
++
++char getDebugChar(void)
++{
++	return generic_getDebugChar();
++}
++
++int rs_putDebugChar(char c)
++{
++
++	if (!kdb_port_info.state) { 	/* need to init device first */
++		return 0;
++	}
++
++	while ((serial_in(&kdb_port_info, UART_LSR) & UART_LSR_THRE) == 0)
++		;
++
++	serial_out(&kdb_port_info, UART_TX, c);
++
++	return 1;
++}
++
++char rs_getDebugChar(void)
++{
++	if (!kdb_port_info.state) { 	/* need to init device first */
++		return 0;
++	}
++
++	while (!(serial_in(&kdb_port_info, UART_LSR) & 1))
++		;
++
++	return(serial_in(&kdb_port_info, UART_RX));
++}
++
+diff -urN linux-2.4.32/arch/mips/ar7/init.c linux-2.4.32.new/arch/mips/ar7/init.c
+--- linux-2.4.32/arch/mips/ar7/init.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/init.c	2005-12-27 21:44:16.000000000 +0100
+@@ -24,6 +24,7 @@
+ #include <linux/module.h>
+ 
+ #include <asm/io.h>
++#include <asm/bootinfo.h>
+ #include <asm/mips-boards/prom.h>
+ #include <asm/mips-boards/generic.h>
+ 
+@@ -35,7 +36,91 @@
+ /* max # of Adam2 environment variables */
+ #define MAX_ENV_ENTRY 80
+ 
++#ifndef CONFIG_MIPS_SINUS154
+ static t_env_var local_envp[MAX_ENV_ENTRY];
++#else /* CONFIG_MIPS_SINUS154 */
++static t_env_var local_envp[/*MAX_ENV_ENTRY*/] = {
++	// Ethernet
++        {"ethaddr", "192.168.2.1"},
++        {"maca", "00:30:f1:df:5f:55"},		// !!!
++	{"mac_phy_sel", "int"},			// unused?
++	{"MAC_PORT", "0"},			// internal = 0, external = 1
++	{"threshold", "20"},
++	// ATM
++	{"oam_lb_timeout", "5000"},
++        {"modulation", "MMODE"},
++        {"enable_margin_retrain", 0},
++        {"enable_rate_adapt", 0},
++        {"enable_trellis", 0},
++        {"maximum_bits_per_carrier", 0},
++        {"maximum_interleave_depth", 0},
++        {"pair_selection", 0},
++        {"dgas_polarity", 0},
++        {"los_alarm", 0},
++        {"eoc_vendor_id", 0},
++        {"macc", "00:01:02:03:04:05"},
++        {"sar_ipacemax", "2"},
++        {"TurboDSL", "1"},
++	//
++	{"memsize", "0x01000000"},
++        {"modetty0", "115200,n,8,1,hw"},
++        {"modetty1", "57600,n,8,1,hw"},
++	// MTD partitions
++        {"mtd0", "0x90000000,0x90020000,adam2"},      // Boot
++        {"mtd4", "0x90020000,0x90040000,OpenWrt"},    // Configuration
++#if 1
++        {"mtd5", "0x90040000,0x90050000,pfs"},        // Web Image (reserved)
++        {"mtd2", "0x90050000,0x90110000,rootfs"},     // Web Image (squashfs)
++#else
++        {"mtd2", "0x90040000,0x90110000,rootfs"},     // Web Image
++#endif
++        {"mtd1", "0x90110000,0x901F0000,linux"},      // Code Image (zipped kernel)
++        {"mtd3", "0x901F0000,0x90200000,config"},     // Boot Params
++         //~ {"kernel_args", "root=/dev/nfs rw nfsroot=192.168.0.2:/nfsroot console=ttyS0,115200 init=/etc/preinit noinitrd"},
++ 	// Device br0 does not work (device is not available at boot time).
++        {
++		"kernel_args",
++#if defined(CONFIG_ROOT_NFS)
++# warning Using_NFS_boot
++		"root=/dev/nfs rw nfsroot=/nfsroot,nolock "
++		"ip=192.168.2.1:192.168.2.2::255.255.255.0:sinus:eth0:off "
++#else
++# warning Using_SQUASHFS_boot
++		"root=/dev/mtdblock2 rootfstype=squashfs "
++#endif
++#if defined(CONFIG_MTD_CMDLINE_PARTS) && defined(CONFIG_MIPS_SINUS154)
++# warning Cmdline defines MTD partitions
++		"mtdparts=sinus154:128k(Boot)ro,128k(Config),832k(Web),896k(Code),64k(Params) "
++#endif
++#if 0 && defined(CONFIG_KGDB)
++		"kgdb=ttyS0 "
++#endif
++#if defined(CONFIG_RUNTIME_DEBUG)
++		"debug "
++#endif
++		"console=ttyS0,115200 init=/etc/preinit.sinus154 noinitrd"
++	},
++        {0}
++#if 0
++flashsize       0x00400000
++modetty1        38400,n,8,1,hw
++bootserport     tty0
++cpufrequency    150000000
++sysfrequency    125000000
++bootloaderVersion       0.22.02
++ProductID       AR7WRD
++HWRevision      Unknown
++SerialNumber    none
++my_ipaddress    10.48.88.66
++prompt  Adam2_AR7RD
++firstfreeaddress        0x9401d328
++req_fullrate_freq       125000000
++autoload        1
++mac_ap  00:0F:3D:98:09:F4
++#endif
++};
++#endif
++
+ static int env_type = 0;
+ int init_debug = 0;
+ 
+@@ -155,6 +240,10 @@
+ 
+ int __init prom_init(int argc, char **argv, char **envp)
+ {
++#ifdef CONFIG_MIPS_SINUS154
++	mips_machgroup = MACH_GROUP_AR7;
++	mips_machtype = MACH_AR7_SINUS154;
++#else
+ 	int i;
+ 
+ 	t_env_var *env = (t_env_var *) envp;
+@@ -165,7 +254,7 @@
+ 	_prom_argv = (int *)argv;
+ 	_prom_envp = (int *)envp;
+ 
+-	if(strcmp(psp_env, psp_env_version) == 0) {
++	if((psp_env != 0) && (strcmp(psp_env, psp_env_version) == 0)) {
+  		/* PSPBOOT */
+ 
+ 		env_type = 1;
+@@ -188,10 +277,15 @@
+ 			}
+ 		}
+ 	}
++#endif
+ 
+ 	set_io_port_base(0);
+ 
++#if !defined(CONFIG_MIPS_SINUS154)
+ 	prom_printf("\nLINUX started...\n");
++#else
++	printk("\nLINUX started...\n");
++#endif
+ 	prom_init_cmdline();
+ 	prom_meminit();
+ 
+diff -urN linux-2.4.32/arch/mips/ar7/irq.c linux-2.4.32.new/arch/mips/ar7/irq.c
+--- linux-2.4.32/arch/mips/ar7/irq.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/irq.c	2005-12-27 21:44:16.000000000 +0100
+@@ -26,20 +26,30 @@
+ 
+ #include <linux/init.h>
+ #include <linux/interrupt.h>
++#include <linux/module.h>
+ 
+ #include <asm/irq.h>
+ #include <asm/mipsregs.h>
+ #include <asm/ar7/ar7.h>
+ #include <asm/ar7/avalanche_intc.h>
+ 
++#if 1
++# define dprintk(format, args...) printk(KERN_DEBUG format, ## args)
++# define dprintk(format, args...) printk(format, ## args)
++#else
++# define dprintk(format, args...) ((void)0)
++#endif
++
++static void avalanche_int_set(int channel, int line);
++
+ #define shutdown_avalanche_irq	disable_avalanche_irq
+ #define mask_and_ack_avalanche_irq   disable_avalanche_irq
+ 
+-static unsigned int startup_avalanche_irq(unsigned int irq);
+-static void end_avalanche_irq(unsigned int irq);
+-void enable_avalanche_irq(unsigned int irq_nr);
+-void disable_avalanche_irq(unsigned int irq_nr);
+-void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs);
++static unsigned int startup_avalanche_irq(unsigned int irq_nr);
++static void end_avalanche_irq(unsigned int irq_nr);
++static void enable_avalanche_irq(unsigned int irq_nr);
++static void disable_avalanche_irq(unsigned int irq_nr);
++static void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs);
+ 
+ static struct hw_interrupt_type avalanche_irq_type = {
+ 	"AR7",
+@@ -75,16 +85,26 @@
+ static void end_avalanche_irq(unsigned int irq)
+ {
+ 	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
++	{
++		unsigned long flags;
++		save_and_cli(flags);
+ 		enable_avalanche_irq(irq);
++		restore_flags(flags);
++	}
+ }
+ 
+-void disable_avalanche_irq(unsigned int irq_nr)
++static void disable_avalanche_irq(unsigned int irq_nr)
+ {
+-	unsigned long flags;
+-	unsigned long chan_nr=0;
++	unsigned long chan_nr;
+ 
+-	save_and_cli(flags);
++	//~ dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
+ 
++	if (irq_nr <  MIPS_EXCEPTION_OFFSET || irq_nr >= AVALANCHE_INTC_END)
++	{
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++ 
+ 	/* irq_nr represents the line number for the interrupt.  We must
+ 	 *  disable the channel number associated with that line number.
+ 	 */
+@@ -109,17 +129,20 @@
+ 
+ 	else  /* secondary interrupt #'s 0-31 */
+ 		avalanche_hw0_ecregs->exiecr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+-
+-	restore_flags(flags);
+ }
+ 
+-void enable_avalanche_irq(unsigned int irq_nr)
++static void enable_avalanche_irq(unsigned int irq_nr)
+ {
+-	unsigned long flags;
+-	unsigned long chan_nr=0;
++	unsigned long chan_nr;
+ 
+-	save_and_cli(flags);
++	//~ dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
+ 
++	if (irq_nr <  MIPS_EXCEPTION_OFFSET || irq_nr >= AVALANCHE_INTC_END)
++	{
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++ 
+ 	/* irq_nr represents the line number for the interrupt.  We must
+ 	 *  disable the channel number associated with that line number.
+ 	 */
+@@ -142,19 +165,18 @@
+ 
+ 	else    /* secondary interrupt #'s 0-31 */
+ 		avalanche_hw0_ecregs->exiesr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+-
+-	restore_flags(flags);
+ }
+ 
+ static unsigned int startup_avalanche_irq(unsigned int irq)
+ {
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq);
+ 	enable_avalanche_irq(irq);
+ 	return 0; /* never anything pending */
+ }
+ 
+ void __init ar7_irq_init(int base)
+ {
+-	int i;
++	unsigned int i;
+ 
+ 	avalanche_hw0_icregs = (struct avalanche_ictrl_regs *)AVALANCHE_ICTRL_REGS_BASE;
+ 	avalanche_hw0_ecregs = (struct avalanche_exctrl_regs *)AVALANCHE_ECTRL_REGS_BASE;
+@@ -182,7 +204,8 @@
+ 		avalanche_int_set(i,i);
+ 
+ 	ar7_irq_base = base;
+-	for (i = base; i <= base+40; i++)
++	/* Set irq data for primary interrupts */
++	for (i = base; i <= base + 40; i++)
+ 	{
+ 		irq_desc[i].status	= IRQ_DISABLED;
+ 		irq_desc[i].action	= 0;
+@@ -196,7 +219,7 @@
+ 	return;
+ }
+ 
+-void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs)
++static void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs)
+ {
+ 	int irq;
+ 	unsigned long int_line_number, status;
+@@ -250,7 +273,7 @@
+ 	return;
+ }
+ 
+-void avalanche_int_set(int channel, int line)
++static void avalanche_int_set(int channel, int line)
+ {
+ 	switch(channel)
+ 	{
+@@ -390,38 +413,348 @@
+ #define AVALANCHE_PACING_LOW_VAL   2
+ #define AVALANCHE_PACING_HIGH_VAL 63
+ 
+-int avalanche_request_pacing(int irq_nr, unsigned int blk_num,
++int avalanche_request_pacing(unsigned int irq_nr, unsigned int blk_num,
+                             unsigned int pace_value)
+ {
+-    unsigned int  blk_offset;
+-    unsigned long flags;
++	irq_desc_t *desc;
++	unsigned int  blk_offset;
++	unsigned long flags;
+ 
+-    if(irq_nr < MIPS_EXCEPTION_OFFSET &&
+-       irq_nr >= AVALANCHE_INT_END_PRIMARY)
+-        return (0);
++	if(irq_nr < MIPS_EXCEPTION_OFFSET &&
++	   irq_nr >= AVALANCHE_INT_END_PRIMARY)
++		return (0);
++
++	if (irq_nr >= NR_IRQS)
++		return -1;
++
++	if(blk_num > AVALANCHE_MAX_PACING_BLK)
++		return(-1);
++
++	if(pace_value > AVALANCHE_PACING_HIGH_VAL &&
++	   pace_value < AVALANCHE_PACING_LOW_VAL)
++		return(-1);
++
++	blk_offset = blk_num*8;
++	
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
++	
++	/* disable the interrupt pacing, if enabled previously */
++	avalanche_hw0_ipaceregs->ipacemax &= ~(0xff << blk_offset);
++	
++	/* clear the pacing map */
++	avalanche_hw0_ipaceregs->ipacemap &= ~(0xff << blk_offset);
++	
++	/* setup the new values */
++	avalanche_hw0_ipaceregs->ipacemap |= ((AVINTNUM(irq_nr))   << blk_offset);
++	avalanche_hw0_ipaceregs->ipacemax |= ((0x80 | pace_value)  << blk_offset);
++	
++	spin_unlock_irqrestore(&desc->lock, flags);
+ 
+-    if(blk_num > AVALANCHE_MAX_PACING_BLK)
+-        return(-1);
++	return(0);
++}
+ 
+-    if(pace_value > AVALANCHE_PACING_HIGH_VAL &&
+-       pace_value < AVALANCHE_PACING_LOW_VAL)
+-       return(-1);
++int avalanche_intr_polarity_set(unsigned int irq_nr, unsigned long polarity_val)
++{
++	irq_desc_t *desc;
++	unsigned long flags;
++	unsigned long chan_nr = 0;
+ 
+-    blk_offset = blk_num*8;
++	dprintk("%s:%u %s(%u,%lu)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr,
++		polarity_val);
+ 
+-    save_and_cli(flags);
++	if (irq_nr < MIPS_EXCEPTION_OFFSET ||
++	    irq_nr >= AVALANCHE_INT_END ||
++	    (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
++	     irq_nr < AVALANCHE_INT_END_SECONDARY)) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++		printk
++		    ("Not one of the primary or vlynq avalanche interrupts.\n");
++#else
++		printk("Not one of the primary avalanche interrupts\n");
++#endif
++		panic("IRQ, you lose...");
++		return (-1);
++	}
+ 
+-    /* disable the interrupt pacing, if enabled previously */
+-    avalanche_hw0_ipaceregs->ipacemax &= ~(0xff << blk_offset);
++	if (polarity_val > 1) {
++		printk("Not a valid polarity value.\n");
++		return (-1);
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts
++	 * managed by the interrupt controller.
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			vlynq_interrupt_set_polarity(&vlynqDevice1,
++						     VLYNQ_REMOTE_DVC,
++						     irq_nr -
++						     AVALANCHE_INT_END_LOW_VLYNQ,
++						     polarity_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			vlynq_interrupt_set_polarity(&vlynqDevice0,
++						     VLYNQ_REMOTE_DVC,
++						     irq_nr -
++						     AVALANCHE_INTC_END,
++						     polarity_val);
++		}
++		goto ret_from_set_polarity;
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_interrupt_set_polarity == NULL) {
++			return 1;
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			(*p_vlynq_interrupt_set_polarity) (p_vlynqDevice1, 1,
++							   irq_nr -
++							   AVALANCHE_INT_END_LOW_VLYNQ,
++							   polarity_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			(*p_vlynq_interrupt_set_polarity) (p_vlynqDevice0, 1,
++							   irq_nr -
++							   AVALANCHE_INTC_END,
++							   polarity_val);
++		}
++		goto ret_from_set_polarity;
++	}
++#endif
+ 
+-    /* clear the pacing map */
+-    avalanche_hw0_ipaceregs->ipacemap &= ~(0xff << blk_offset);
++	chan_nr = line_to_channel[AVINTNUM(irq_nr)];
+ 
+-    /* setup the new values */
+-    avalanche_hw0_ipaceregs->ipacemap |= ((AVINTNUM(irq_nr))   << blk_offset);
+-    avalanche_hw0_ipaceregs->ipacemax |= ((0x80 | pace_value)  << blk_offset);
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
+ 
+-    restore_flags(flags);
++	if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
++		/* primary interrupt #'s 0-31 */
++		if (polarity_val)
++			avalanche_hw0_icregs->intpolr1 |= (1 << chan_nr);
++		else
++			avalanche_hw0_icregs->intpolr1 &= ~(1 << chan_nr);
++	} else {
++		/* primary interrupt #'s 32-39 */
++		if (polarity_val)
++			avalanche_hw0_icregs->intpolr2 |=
++			    (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++		else
++			avalanche_hw0_icregs->intpolr2 &=
++			    ~(1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++	}
++
++	spin_unlock_irqrestore(&desc->lock, flags);
+ 
+-    return(0);
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++      ret_from_set_polarity:
++#endif
++
++	return (0);
+ }
++
++int avalanche_intr_polarity_get(unsigned int irq_nr)
++{
++	irq_desc_t *desc;
++	unsigned long flags;
++	unsigned long chan_nr = 0;
++	int value;
++
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < MIPS_EXCEPTION_OFFSET ||
++	    irq_nr >= AVALANCHE_INT_END ||
++	    (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
++	     irq_nr < AVALANCHE_INT_END_SECONDARY)) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++		printk
++		    ("Not one of the primary or vlynq avalanche interrupts.\n");
++#else
++		printk("Not one of the primary avalanche interrupts\n");
++#endif
++		panic("IRQ, you lose...");
++		return (-1);
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			value =
++			    vlynq_interrupt_get_polarity(&vlynqDevice1,
++							 VLYNQ_REMOTE_DVC,
++							 irq_nr -
++							 AVALANCHE_INT_END_LOW_VLYNQ);
++		} else {
++			/* Vlynq interupts 0-31 */
++			value =
++			    vlynq_interrupt_get_polarity(&vlynqDevice0,
++							 VLYNQ_REMOTE_DVC,
++							 irq_nr -
++							 AVALANCHE_INTC_END);
++
++			goto ret_from_get_polarity;
++		}
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_interrupt_get_polarity == NULL) {
++			return 0;
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			value =
++			    (*p_vlynq_interrupt_get_polarity) (p_vlynqDevice1,
++							       1,
++							       irq_nr -
++							       AVALANCHE_INT_END_LOW_VLYNQ);
++		} else {
++			/* Vlynq interupts 0-31 */
++			value =
++			    (*p_vlynq_interrupt_get_polarity) (p_vlynqDevice0,
++							       1,
++							       irq_nr -
++							       AVALANCHE_INTC_END);
++		}
++		goto ret_from_get_polarity;
++	}
++#endif
++
++	chan_nr = line_to_channel[AVINTNUM(irq_nr)];
++
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
++
++	if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
++		/* primary interrupt #'s 0-31 */
++		value = avalanche_hw0_icregs->intpolr1;
++		value = (value >> chan_nr) & 0x1;
++	} else {
++		/* primary interrupt #'s 32-39 */
++		value = avalanche_hw0_icregs->intpolr2;
++		value =
++		    (value >> (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1)) & 0x1;
++	}
++
++	spin_unlock_irqrestore(&desc->lock, flags);
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++      ret_from_get_polarity:
++#endif
++
++	return (value);
++}
++
++/* Sets the trigger type: edge or level */
++int avalanche_intr_type_set(unsigned int irq_nr, unsigned long type_val)
++{
++	irq_desc_t *desc;
++	unsigned long flags;
++	unsigned long chan_nr = 0;
++
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < MIPS_EXCEPTION_OFFSET ||
++	    irq_nr >= AVALANCHE_INT_END ||
++	    (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
++	     irq_nr < AVALANCHE_INT_END_SECONDARY)) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++		return (-1);
++	}
++
++	if (type_val > 1) {
++		printk("Not a valid polarity value.\n");
++		return (-1);
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after
++	 *  the interrupts managed by the interrupt controller.
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		/* Type values for VLYNQ are INTC are different. */
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			vlynq_interrupt_set_type(&vlynqDevice1,
++						 VLYNQ_REMOTE_DVC,
++						 irq_nr -
++						 AVALANCHE_INT_END_LOW_VLYNQ,
++						 !type_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			vlynq_interrupt_set_type(&vlynqDevice0,
++						 VLYNQ_REMOTE_DVC,
++						 irq_nr - AVALANCHE_INTC_END,
++						 !type_val);
++		}
++		goto ret_from_set_type;
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after
++	 *  the interrupts managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_interrupt_set_type == NULL) {
++			return 1;
++			/* Type values for VLYNQ are INTC are different. */
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			(*p_vlynq_interrupt_set_type) (p_vlynqDevice1, 1,
++						       irq_nr -
++						       AVALANCHE_INT_END_LOW_VLYNQ,
++						       !type_val);
++		} else {
++			/* Vlynq interupts 0-31 */
++			(*p_vlynq_interrupt_set_type) (p_vlynqDevice0, 1,
++						       irq_nr -
++						       AVALANCHE_INTC_END,
++						       !type_val);
++		}
++		goto ret_from_set_type;
++	}
++#endif
++
++	chan_nr = line_to_channel[AVINTNUM(irq_nr)];
++
++	desc = irq_desc + irq_nr;
++	spin_lock_irqsave(&desc->lock, flags);
++
++	if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
++		/* primary interrupt #'s 0-31 */
++		if (type_val) {
++			avalanche_hw0_icregs->inttypr1 |= (1 << chan_nr);
++		} else {
++			avalanche_hw0_icregs->inttypr1 &= ~(1 << chan_nr);
++		}
++	} else {
++		/* primary interrupt #'s 32-39 */
++		if (type_val) {
++			avalanche_hw0_icregs->inttypr2 |=
++			    (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++		} else {
++			avalanche_hw0_icregs->inttypr2 &=
++			    ~(1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
++		}
++	}
++
++	spin_unlock_irqrestore(&desc->lock, flags);
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++      ret_from_set_type:
++#endif
++
++	return (0);
++}
++
++EXPORT_SYMBOL(avalanche_intr_type_set);
++EXPORT_SYMBOL(avalanche_intr_polarity_set);
+diff -urN linux-2.4.32/arch/mips/ar7/irq-vlynq.c linux-2.4.32.new/arch/mips/ar7/irq-vlynq.c
+--- linux-2.4.32/arch/mips/ar7/irq-vlynq.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/irq-vlynq.c	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,269 @@
++/*
++ * Interrupt handling for VLYNQ interrupts.
++ */
++
++#include <linux/config.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/module.h>
++
++#include <asm/irq.h>
++#include <asm/mipsregs.h>
++#include <asm/ar7/ar7.h>
++#include <asm/ar7/avalanche_intc.h>
++#include <asm/ar7/avalanche_types.h>	/* vlynqDevice0 */
++
++#if defined(CONFIG_AR7_VLYNQ)
++# define CONFIG_MIPS_AVALANCHE_VLYNQ
++# include <asm/ar7/vlynq_hal.h>
++#else
++# error This file needs CONFIG_AR7_VLYNQ
++#endif
++
++#if (AVALANCHE_INT_END) != NR_IRQS
++# error unexpected number of interrupts, check size of irq_desc
++#endif
++
++#if 1
++# define dprintk(format, args...) printk(KERN_DEBUG format, ## args)
++# define dprintk(format, args...) printk(format, ## args)
++#else
++# define dprintk(format, args...) ((void)0)
++#endif
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ) || defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++
++static unsigned int startup_vlynq_irq(unsigned int irq_nr);
++static void shutdown_vlynq_irq(unsigned int irq_nr);
++static void enable_vlynq_irq(unsigned int irq_nr);
++static void disable_vlynq_irq(unsigned int irq_nr);
++#define mask_and_ack_vlynq_irq   disable_vlynq_irq
++static void end_vlynq_irq(unsigned int irq_nr);
++
++static struct hw_interrupt_type vlynq_irq_type = {
++	"VLYNQ",
++	startup_vlynq_irq,
++	shutdown_vlynq_irq,
++	enable_vlynq_irq,
++	disable_vlynq_irq,
++	mask_and_ack_vlynq_irq,
++	end_vlynq_irq,
++	NULL
++};
++
++static void end_vlynq_irq(unsigned int irq)
++{
++	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
++		unsigned long flags;
++		save_and_cli(flags);
++		enable_vlynq_irq(irq);
++		restore_flags(flags);
++	}
++}
++
++static void disable_vlynq_irq(unsigned int irq_nr)
++{
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < AVALANCHE_INTC_END || irq_nr >= AVALANCHE_INT_END) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		vlynq_interrupt_disable(&vlynqDevice1, VLYNQ_REMOTE_DVC,
++					irq_nr - AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		vlynq_interrupt_disable(&vlynqDevice0, VLYNQ_REMOTE_DVC,
++					irq_nr - AVALANCHE_INTC_END);
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (p_vlynq_interrupt_disable == NULL) {
++	} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		(*p_vlynq_interrupt_disable) (p_vlynqDevice1, 1,
++					      irq_nr -
++					      AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		(*p_vlynq_interrupt_disable) (p_vlynqDevice0, 1,
++					      irq_nr - AVALANCHE_INTC_END);
++	}
++#endif
++}
++
++static void enable_vlynq_irq(unsigned int irq_nr)
++{
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	if (irq_nr < AVALANCHE_INTC_END || irq_nr >= AVALANCHE_INT_END) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		vlynq_interrupt_enable(&vlynqDevice1, VLYNQ_REMOTE_DVC,
++				       irq_nr - AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		vlynq_interrupt_enable(&vlynqDevice0, VLYNQ_REMOTE_DVC,
++				       irq_nr - AVALANCHE_INTC_END);
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (p_vlynq_interrupt_enable == NULL) {
++	} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		(*p_vlynq_interrupt_enable) (p_vlynqDevice1, 1,
++					     irq_nr -
++					     AVALANCHE_INT_END_LOW_VLYNQ);
++	} else {
++		/* Vlynq interupts 0-31 */
++		(*p_vlynq_interrupt_enable) (p_vlynqDevice0, 1,
++					     irq_nr - AVALANCHE_INTC_END);
++	}
++#endif
++}
++
++static unsigned int startup_vlynq_irq(unsigned int irq_nr)
++{
++	irq_desc_t *desc;
++	struct irqaction *action;
++	void (*handler) (int, void *, struct pt_regs *) = 0;
++	void *dev_id = 0;
++
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr < AVALANCHE_INTC_END || irq_nr >= AVALANCHE_INT_END) {
++		printk("whee, invalid irq_nr %u\n", irq_nr);
++		panic("IRQ, you lose...");
++	}
++
++	desc = irq_desc + irq_nr;
++	action = desc->action;
++	if (action != 0) {
++		handler = action->handler;
++		dev_id = action->dev_id;
++	}
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		vlynq_install_isr(&vlynqDevice1,
++				  irq_nr - AVALANCHE_INT_END_LOW_VLYNQ,
++				  (VLYNQ_INTR_CNTRL_ISR) handler,
++				  (void *)irq_nr, dev_id, NULL);
++	} else {
++		/* Vlynq interupts 0-31 */
++		vlynq_install_isr(&vlynqDevice0, irq_nr - AVALANCHE_INTC_END,
++				  (VLYNQ_INTR_CNTRL_ISR) handler,
++				  (void *)irq_nr, dev_id, NULL);
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	if (p_vlynq_install_isr == NULL) {
++		enable_irq(irq_nr);
++		return 1;
++	} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++		/* Vlynq interrupts 32-63 */
++		(*p_vlynq_install_isr) (p_vlynqDevice1,
++					irq_nr - AVALANCHE_INT_END_LOW_VLYNQ,
++					(p_vlynq_intr_cntrl_isr_t) handler,
++					(void *)irq_nr, dev_id, NULL);
++	} else {
++		/* Vlynq interupts 0-31 */
++		(*p_vlynq_install_isr) (p_vlynqDevice0,
++					irq_nr - AVALANCHE_INTC_END,
++					(p_vlynq_intr_cntrl_isr_t) handler,
++					(void *)irq_nr, dev_id, NULL);
++	}
++#endif
++	enable_vlynq_irq(irq_nr);
++	return 0;		/* never anything pending */
++}
++
++static void shutdown_vlynq_irq(unsigned int irq_nr)
++{
++	dprintk("%s:%u %s(%u)\n", __FILE__, __LINE__, __FUNCTION__, irq_nr);
++
++#if defined (CONFIG_MIPS_AVALANCHE_VLYNQ)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		irq_desc_t *desc = irq_desc + irq_nr;
++		struct irqaction *action = desc->action;
++		void *dev_id = ((action != 0) ? action->dev_id : 0);
++
++		if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			vlynq_uninstall_isr(&vlynqDevice1,
++					    irq_nr -
++					    AVALANCHE_INT_END_LOW_VLYNQ,
++					    (void *)irq_nr, dev_id, NULL);
++		} else {
++			/* Vlynq interupts 0-31 */
++			vlynq_uninstall_isr(&vlynqDevice0,
++					    irq_nr - AVALANCHE_INTC_END,
++					    (void *)irq_nr, dev_id, NULL);
++		}
++
++		// action = irq_desc[irq_nr].action;
++	}
++#elif defined (CONFIG_MIPS_AVALANCHE_VLYNQ_MODULE)
++	/* Vlynq irq_nr are 80-143 in the system and are placed after the interrupts  
++	 * managed by the interrupt controller. 
++	 */
++	if (irq_nr >= AVALANCHE_INTC_END) {
++		if (p_vlynq_uninstall_isr == NULL) {
++		} else if (irq_nr >= AVALANCHE_INT_END_LOW_VLYNQ) {
++			/* Vlynq interrupts 32-63 */
++			(*p_vlynq_uninstall_isr) (p_vlynqDevice1,
++						  irq_nr -
++						  AVALANCHE_INT_END_LOW_VLYNQ,
++						  (void *)irq_nr, dev_id, NULL);
++		} else {
++			/* Vlynq interupts 0-31 */
++			(*p_vlynq_uninstall_isr) (p_vlynqDevice0,
++						  irq_nr - AVALANCHE_INTC_END,
++						  (void *)irq_nr, dev_id, NULL);
++		}
++
++		// action = irq_desc[irq_nr].action;
++	}
++#endif
++}
++
++void __init vlynq_irq_init(int base)
++{
++	unsigned int i;
++
++	//~ ar7_irq_base = base;
++
++	/* Set irq data for VLYNQ interrupts */
++	for (i = AVALANCHE_INTC_END; i < AVALANCHE_INT_END; i++) {
++		irq_desc[i].status = IRQ_DISABLED;
++		irq_desc[i].action = 0;
++		irq_desc[i].depth = 1;
++		irq_desc[i].handler = &vlynq_irq_type;
++	}
++
++	return;
++}
++
++#endif
+diff -urN linux-2.4.32/arch/mips/ar7/Makefile linux-2.4.32.new/arch/mips/ar7/Makefile
+--- linux-2.4.32/arch/mips/ar7/Makefile	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -1,14 +1,19 @@
+-.S.s:
+-	$(CPP) $(AFLAGS) $< -o $*.s
++#
++# Makefile for the Linux/MIPS kernel - AR7 specific part.
++#
++# Note! Dependencies are done automagically by 'make dep', which also
++# removes any old dependencies. DON'T put your own dependencies here
++# unless it's something special (ie not a .c file).
++#
+ 
+-.S.o:
+-	$(CC) $(AFLAGS) -c $< -o $*.o
++USE_STANDARD_AS_RULE := true
+ 
+ EXTRA_CFLAGS := -I$(TOPDIR)/include/asm/ar7 -DLITTLE_ENDIAN -D_LINK_KSEG0_
+ O_TARGET := ar7.o
+ 
+ obj-y := tnetd73xx_misc.o misc.o
+ export-objs := misc.o irq.o init.o
+-obj-y += setup.o irq.o int-handler.o reset.o init.o psp_env.o memory.o promlib.o cmdline.o
++obj-y += setup.o irq.o irq-vlynq.o int-handler.o reset.o init.o psp_env.o memory.o promlib.o cmdline.o
++obj-$(CONFIG_KGDB) += gdb_hook.o
+ 
+ include $(TOPDIR)/Rules.make
+diff -urN linux-2.4.32/arch/mips/ar7/misc.c linux-2.4.32.new/arch/mips/ar7/misc.c
+--- linux-2.4.32/arch/mips/ar7/misc.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/misc.c	2005-12-27 21:44:16.000000000 +0100
+@@ -12,29 +12,28 @@
+ /*****************************************************************************
+  * Reset Control Module.
+  *****************************************************************************/
+-void avalanche_reset_ctrl(unsigned int module_reset_bit, 
++int avalanche_reset_ctrl(unsigned int module_reset_bit, 
+                           AVALANCHE_RESET_CTRL_T reset_ctrl)
+ {
+     volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+    
+     if(module_reset_bit >= 32 && module_reset_bit < 64)
+-        return;
++        return 0;
+ 
+     if(module_reset_bit >= 64)
+     {
+         if(p_remote_vlynq_dev_reset_ctrl) {
+-            p_remote_vlynq_dev_reset_ctrl(module_reset_bit - 64, reset_ctrl);
+-	    return;
++            return p_remote_vlynq_dev_reset_ctrl(module_reset_bit - 64, reset_ctrl);
+ 	}
+         else
+-            return;
++            return 1;
+     }
+     
+     if(reset_ctrl == OUT_OF_RESET)
+         *reset_reg |= 1 << module_reset_bit;
+     else
+         *reset_reg &= ~(1 << module_reset_bit);
+-    return;
++    return 0;
+ }
+ 
+ AVALANCHE_RESET_CTRL_T avalanche_get_reset_status(unsigned int module_reset_bit)
+diff -urN linux-2.4.32/arch/mips/ar7/setup.c linux-2.4.32.new/arch/mips/ar7/setup.c
+--- linux-2.4.32/arch/mips/ar7/setup.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/ar7/setup.c	2005-12-27 21:44:16.000000000 +0100
+@@ -36,6 +36,7 @@
+ 
+ extern void ar7_reboot_setup(void);
+ extern void ar7_irq_init(int);
++extern void vlynq_irq_init(int);
+ extern asmlinkage void ar7IRQ(void);
+ 
+ void ar7_time_init(void)
+@@ -55,6 +56,7 @@
+   init_generic_irq();
+   mips_cpu_irq_init(0);
+   ar7_irq_init(8);
++  vlynq_irq_init(80);
+ 
+   /* Now safe to set the exception vector. */
+   set_except_vector(0, ar7IRQ);
+@@ -124,7 +126,7 @@
+ 		generic_putDebugChar = rs_putDebugChar;
+ 		generic_getDebugChar = rs_getDebugChar;
+ 
+-		prom_printf("KGDB: Using serial line /dev/ttyS%d for session, "
++		printk("KGDB: Using serial line /dev/ttyS%d for session, "
+ 				"please connect your debugger\n", line ? 1 : 0);
+ 
+ 		remote_debug = 1;
+diff -urN linux-2.4.32/arch/mips/config-shared.in linux-2.4.32.new/arch/mips/config-shared.in
+--- linux-2.4.32/arch/mips/config-shared.in	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/config-shared.in	2005-12-27 21:44:16.000000000 +0100
+@@ -218,6 +218,7 @@
+    fi
+    define_bool CONFIG_MIPS_RTC y
+ fi
++dep_bool 'Support for Sinus 154 boards  (EXPERIMENTAL)' CONFIG_MIPS_SINUS154 $CONFIG_AR7 $CONFIG_EXPERIMENTAL
+ bool 'Support for SNI RM200 PCI' CONFIG_SNI_RM200_PCI
+ bool 'Support for TANBAC TB0226 (Mbase)' CONFIG_TANBAC_TB0226
+ bool 'Support for TANBAC TB0229 (VR4131DIMM)' CONFIG_TANBAC_TB0229
+diff -urN linux-2.4.32/arch/mips/kernel/head.S linux-2.4.32.new/arch/mips/kernel/head.S
+--- linux-2.4.32/arch/mips/kernel/head.S	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/kernel/head.S	2005-12-27 21:44:16.000000000 +0100
+@@ -33,7 +33,16 @@
+ 		 * Reserved space for exception handlers.
+ 		 * Necessary for machines which link their kernels at KSEG0.
+ 		 */
++#if defined(CONFIG_MIPS_SINUS154)
++		/*
++		 * The firmware loads the unzipped kernel at KSEG0
++		 * and starts it from the beginning of KSEG0, namely here.
++		 */
++		jal	kernel_entry
++		.align	10
++#else
+ 		.fill	0x400
++#endif
+ 
+ 		/* The following two symbols are used for kernel profiling. */
+ 		EXPORT(stext)
+diff -urN linux-2.4.32/arch/mips/kernel/setup.c linux-2.4.32.new/arch/mips/kernel/setup.c
+--- linux-2.4.32/arch/mips/kernel/setup.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/arch/mips/kernel/setup.c	2005-12-27 21:44:16.000000000 +0100
+@@ -125,6 +125,20 @@
+ 	/* Determine which MIPS variant we are running on. */
+ 	cpu_probe();
+ 
++#if defined(CONFIG_MIPS_SINUS154)
++	printk("%s:%d\n", __FILE__, __LINE__);
++	printk("argc = %d\n", argc);
++	printk("argv = 0x%p\n", argv);
++	printk("envp = 0x%p\n", envp);
++	printk("prom_vec = 0x%p\n", prom_vec);
++#endif
++
++	if (argc < 0 || argc > 10) {
++		argv = 0;
++		envp = 0;
++		prom_vec = 0;
++	}
++
+ 	prom_init(argc, argv, envp, prom_vec);
+ 
+ 	cpu_report();
+@@ -307,6 +321,7 @@
+ 		printk(KERN_WARNING "Use a HIGHMEM enabled kernel.\n");
+ #endif
+ 	}
++	printk("max_low_pfn = 0x%08lx\n", max_low_pfn);
+ 
+ #ifdef CONFIG_HIGHMEM
+ 	/*
+@@ -425,6 +440,7 @@
+ 
+ 		start = boot_mem_map.map[i].addr;
+ 		end = boot_mem_map.map[i].addr + boot_mem_map.map[i].size - 1;
++		printk("start = 0x%08lx, end = 0x%08lx, maxmem = 0x%08lx\n", start, end, MAXMEM);
+ 		if (start >= MAXMEM)
+ 			continue;
+ 		if (end >= MAXMEM)
+@@ -700,6 +716,7 @@
+                 break;
+ #endif
+ #ifdef CONFIG_AR7
++	case MACH_GROUP_AR7:
+ 	case MACH_GROUP_UNKNOWN:
+ 		ar7_setup();
+ 		break;
+diff -urN linux-2.4.32/arch/mips/Makefile linux-2.4.32.new/arch/mips/Makefile
+--- linux-2.4.32/arch/mips/Makefile	2005-12-29 11:23:34.000000000 +0100
++++ linux-2.4.32.new/arch/mips/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -374,8 +374,12 @@
+ ifdef CONFIG_AR7
+ LIBS		+= arch/mips/ar7/ar7.o
+ SUBDIRS		+= arch/mips/ar7
++ifdef CONFIG_MIPS_SINUS154
++LOADADDR	+= 0x94000000
++else
+ LOADADDR	+= 0x94020000
+ endif
++endif
+ 
+ #
+ # DECstation family
+diff -urN linux-2.4.32/drivers/atm/Makefile linux-2.4.32.new/drivers/atm/Makefile
+--- linux-2.4.32/drivers/atm/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/atm/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -8,38 +8,15 @@
+ export-objs := uPD98402.o suni.o idt77105.o
+ 
+ obj-y := atmdev_init.o
++obj-m :=
+ 
+ obj-$(CONFIG_ATM_ENI) += eni.o suni.o
+ obj-$(CONFIG_ATM_ZATM) += zatm.o uPD98402.o
+ obj-$(CONFIG_ATM_NICSTAR) += nicstar.o
+ obj-$(CONFIG_ATM_IDT77252) += idt77252.o
+ 
+-ifeq ($(CONFIG_AR7),y)
+-
+ subdir-$(CONFIG_MIPS_SANGAM_ATM) += sangam_atm
+ 
+-EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
+-#EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP
+-
+-ifeq ($(ANNEX),B)
+-EXTRA_CFLAGS += -DANNEX_B -DB
+-else
+-ifeq ($(ANNEX),C)
+-EXTRA_CFLAGS += -DANNEX_C -DC
+-else
+-EXTRA_CFLAGS += -DANNEX_A -DP
+-endif
+-endif
+-
+-list-multi	:= tiatm.o
+-tiatm-objs	:= sangam_atm/tn7atm.o sangam_atm/tn7dsl.o sangam_atm/tn7sar.o \
+-	sangam_atm/dsl_hal_api.o sangam_atm/dsl_hal_support.o sangam_atm/cpsar.o \
+-	sangam_atm/aal5sar.o
+-
+-obj-$(CONFIG_MIPS_SANGAM_ATM) += sangam_atm/tiatm.o
+-
+-endif
+-
+ ifeq ($(CONFIG_ATM_NICSTAR_USE_SUNI),y)
+   obj-$(CONFIG_ATM_NICSTAR) += suni.o
+ endif
+diff -urN linux-2.4.32/drivers/atm/sangam_atm/Makefile linux-2.4.32.new/drivers/atm/sangam_atm/Makefile
+--- linux-2.4.32/drivers/atm/sangam_atm/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/atm/sangam_atm/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -3,14 +3,21 @@
+ # Makefile for the Linux network (CPMAC) device drivers.
+ #
+ 
+-
+ O_TARGET := tiatm.o
+-obj-$(CONFIG_MIPS_SANGAM_ATM) += tiatm.o
+-list-multi      := tiatm.o
+ 
+-tiatm-objs	:= tn7atm.o tn7dsl.o tn7sar.o dsl_hal_api.o dsl_hal_support.o cpsar.o aal5sar.o
++obj-y :=
++obj-m :=
++
++#~ list-multi := tiatm.o
+ 
+-EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
++tiatm-objs := tn7atm.o tn7dsl.o tn7sar.o
++tiatm-objs += dsl_hal_api.o dsl_hal_support.o
++tiatm-objs += cpsar.o aal5sar.o
++
++obj-$(CONFIG_MIPS_SANGAM_ATM) += tiatm.o
++
++EXTRA_CFLAGS += -DEL -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
++#EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP
+ 
+ ifeq ($(ANNEX),B)
+ EXTRA_CFLAGS += -DANNEX_B -DB
+@@ -22,14 +29,7 @@
+ endif
+ endif
+ 
+-
+ include $(TOPDIR)/Rules.make
+ 
+-tiatm.o:      $(tiatm-objs)
++tiatm.o: $(tiatm-objs)
+ 	$(LD) -r -o $@ $(tiatm-objs)
+-
+-#avalanche_cpmac.o:      $(avalanche_cpmac-objs)
+-#	$(LD) -r -o $@ $(avalanche_cpmac-objs)
+-
+-clean:
+-	rm -f core *.o *.a *.s
+diff -urN linux-2.4.32/drivers/atm/sangam_atm/tn7dsl.c linux-2.4.32.new/drivers/atm/sangam_atm/tn7dsl.c
+--- linux-2.4.32/drivers/atm/sangam_atm/tn7dsl.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/atm/sangam_atm/tn7dsl.c	2005-12-27 21:44:16.000000000 +0100
+@@ -496,7 +496,7 @@
+       ptr = kmalloc(size, GFP_KERNEL|GFP_DMA);
+     }
+   }
+-  printk("size=%d\n", size);
++  printk("%s:%u size = %u\n", __FILE__, __LINE__, size);
+   return ptr;
+ 
+ }
+diff -urN linux-2.4.32/drivers/char/avalanche_led/gpio.c linux-2.4.32.new/drivers/char/avalanche_led/gpio.c
+--- linux-2.4.32/drivers/char/avalanche_led/gpio.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/gpio.c	2005-12-27 21:44:16.000000000 +0100
+@@ -1,3 +1,10 @@
++/*
++ * Todo:
++ * - missing calls (only needed for clean shutdown of driver):
++ *   remove_proc_entry(AR7_RESET_FILE, NULL)
++ *   remove_proc_entry(AR7_VERSION_FILE, NULL)
++ */
++
+ #include <linux/kernel.h>
+ #include <asm/uaccess.h>
+ #include <linux/spinlock.h>
+@@ -10,62 +17,65 @@
+ #include <asm/ar7/tnetd73xx_misc.h>
+ #include <asm/ar7/ledapp.h>
+ 
++#include "led.h"
++
+ #define TRUE 1
+ #define FALSE 0
+ 
+ #if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+ 
++#define AR7_PROC_DIRECTORY "led_mod"
+ #define AR7_RESET_FILE "led_mod/ar7reset"
+ #define AR7_VERSION_FILE "led_mod/hardware_version"
+ #define AR7_RESET_GPIO 11
+ #define RESET_POLL_TIME 1
+ #define RESET_HOLD_TIME 4
+-#define NO_OF_LEDS	
++#define NO_OF_LEDS
+ 
+ static struct proc_dir_entry *reset_file;
++static struct proc_dir_entry *hardware_version_file;
+ static int res_state = 0;
+-static int count;
+ static struct timer_list *pTimer = NULL;
+ static ssize_t proc_read_reset_fops(struct file *filp,
+-                                    char *buf,size_t count , loff_t *offp);
++				    char *buf, size_t count, loff_t * offp);
+ 
+ static ssize_t proc_read_hwversion_fops(struct file *filp,
+-                                    char *buf,size_t count , loff_t *offp);
++					char *buf, size_t count, loff_t * offp);
+ 
+ struct file_operations reset_fops = {
+-                                     read: proc_read_reset_fops
+-                                   };
++      read:proc_read_reset_fops
++};
+ struct file_operations hardware_version_fops = {
+-                                     read: proc_read_hwversion_fops
+-                                   };
++      read:proc_read_hwversion_fops
++};
+ #endif
+ 
+-static spinlock_t	device_lock;
++static spinlock_t device_lock;
+ led_reg_t temp[15];
+ 
+-static void gpio_led_on( unsigned long param )
++static void gpio_led_on(unsigned long param)
+ {
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&device_lock, flags);
+ 
+-	tnetd73xx_gpio_out(param,FALSE);
++	tnetd73xx_gpio_out(param, FALSE);
+ 	spin_unlock_irqrestore(&device_lock, flags);
+ }
+ 
+-static void gpio_led_off ( unsigned long param )
++static void gpio_led_off(unsigned long param)
+ {
+ 	unsigned int flags = 0x00;
+ 
+- 	spin_lock_irqsave(&device_lock, flags);
++	spin_lock_irqsave(&device_lock, flags);
+ 
+-	tnetd73xx_gpio_out(param,TRUE);
++	tnetd73xx_gpio_out(param, TRUE);
+ 	spin_unlock_irqrestore(&device_lock, flags);
+ }
+ 
+-static void gpio_led_init( unsigned long param)
++static void gpio_led_init(unsigned long param)
+ {
+-	tnetd73xx_gpio_ctrl(param,GPIO_PIN,GPIO_OUTPUT_PIN);
++	tnetd73xx_gpio_ctrl(param, GPIO_PIN, GPIO_OUTPUT_PIN);
+ }
+ 
+ static void board_gpio_reset(void)
+@@ -77,38 +87,38 @@
+ 
+ #if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+ 
+-static ssize_t proc_read_hwversion_fops(struct file *filp, char *buf, 
+-					size_t count, loff_t *offp)
++static ssize_t proc_read_hwversion_fops(struct file *filp, char *buf,
++					size_t count, loff_t * offp)
+ {
+ 	char line[8];
+-  	int len = 0;
+-  	if( *offp != 0 )
+-  		return 0;
+-
+-	len = sprintf(line,  "%d%d.%d%d%d%d\n", tnetd73xx_gpio_in(20),
+-			tnetd73xx_gpio_in(21), tnetd73xx_gpio_in(22),
+-			tnetd73xx_gpio_in(23), tnetd73xx_gpio_in(24),
+-		        tnetd73xx_gpio_in(25));
+-  	
++	int len = 0;
++	if (*offp != 0)
++		return 0;
++
++	len = sprintf(line, "%d%d.%d%d%d%d\n", tnetd73xx_gpio_in(20),
++		      tnetd73xx_gpio_in(21), tnetd73xx_gpio_in(22),
++		      tnetd73xx_gpio_in(23), tnetd73xx_gpio_in(24),
++		      tnetd73xx_gpio_in(25));
++
+ 	copy_to_user(buf, line, len);
+ 	*offp = len;
+ 	return len;
+-}	
++}
+ 
+ static ssize_t proc_read_reset_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				    char *buf, size_t count, loff_t * offp)
+ {
+-  char * pdata = NULL;
+-  char line[3];
+-  int len = 0;
+-  if( *offp != 0 )
+-  	return 0;
++	char *pdata = NULL;
++	char line[3];
++	int len = 0;
++	if (*offp != 0)
++		return 0;
+ 
+-  pdata = buf;
+-	len = sprintf(line,"%d\n", res_state );
++	pdata = buf;
++	len = sprintf(line, "%d\n", res_state);
+ //wwzh
+ //  res_state = 0;
+-  copy_to_user(buf,line,len );
++	copy_to_user(buf, line, len);
+ 	*offp = len;
+ 	return len;
+ }
+@@ -117,70 +127,62 @@
+ {
+ //wwzh
+ #if 0
+-  	count = (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0) ? count + 1: 0;
+-        if( count >= RESET_HOLD_TIME/RESET_POLL_TIME )
+-#endif
++	static int count;
++	count = (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0) ? count + 1 : 0;
++	if (count >= RESET_HOLD_TIME / RESET_POLL_TIME)
++		res_state = 1;
++	else
++		res_state = 0;
++#else
+ 	if (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0)
+-    		res_state = 1;
++		res_state = 1;
+ 	else
+ 		res_state = 0;
+-	pTimer->expires = jiffies + HZ*RESET_POLL_TIME;
+-	add_timer (pTimer);
+-  return;
++#endif
++	pTimer->expires = jiffies + HZ * RESET_POLL_TIME;
++	add_timer(pTimer);
+ }
+ 
+ static void hardware_version_init(void)
+ {
+-   	static struct proc_dir_entry *hardware_version_file;
+-  	hardware_version_file = create_proc_entry(AR7_VERSION_FILE, 0777, NULL);
+-  	if(hardware_version_file == NULL)
+-   		 return;
+-  	
+-	hardware_version_file->owner = THIS_MODULE;
+-  	hardware_version_file->proc_fops = &hardware_version_fops;
+-
+-  	tnetd73xx_gpio_ctrl(20,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(21,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(22,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(23,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(24,GPIO_PIN,GPIO_INPUT_PIN);
+-  	tnetd73xx_gpio_ctrl(25,GPIO_PIN,GPIO_INPUT_PIN);
+-	
+-	return;
++	hardware_version_file = create_proc_entry(AR7_VERSION_FILE, 0777, NULL);
++	if (hardware_version_file != NULL) {
++		hardware_version_file->owner = THIS_MODULE;
++		hardware_version_file->proc_fops = &hardware_version_fops;
++	}
++	tnetd73xx_gpio_ctrl(20, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(21, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(22, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(23, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(24, GPIO_PIN, GPIO_INPUT_PIN);
++	tnetd73xx_gpio_ctrl(25, GPIO_PIN, GPIO_INPUT_PIN);
+ }
+ 
+ static void reset_init(void)
+ {
+-  /* Create board reset proc file */
+-  reset_file = create_proc_entry( AR7_RESET_FILE, 0777, NULL);
+-  if( reset_file == NULL)
+-    goto reset_file;
+-  reset_file->owner = THIS_MODULE;
+-  reset_file->proc_fops = &reset_fops;
+-
+-  /* Initialise GPIO 11 for input */
+-  tnetd73xx_gpio_ctrl(AR7_RESET_GPIO,GPIO_PIN,GPIO_INPUT_PIN);
+-
+-  /* Create a timer which fires every seconds */
+-  pTimer = kmalloc(sizeof(struct timer_list),GFP_KERNEL);
+-	init_timer( pTimer );
++	/* Create board reset proc file */
++	reset_file = create_proc_entry(AR7_RESET_FILE, 0777, NULL);
++	if (reset_file != NULL) {
++		reset_file->owner = THIS_MODULE;
++		reset_file->proc_fops = &reset_fops;
++	}
++
++	/* Initialise GPIO 11 for input */
++	tnetd73xx_gpio_ctrl(AR7_RESET_GPIO, GPIO_PIN, GPIO_INPUT_PIN);
++
++	/* Create a timer which fires every seconds */
++	pTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++	init_timer(pTimer);
+ 	pTimer->function = reset_timer_func;
+ 	pTimer->data = 0;
+-  /* Start the timer */
+-  reset_timer_func(0);
+-  return ;
+ 
+-  reset_file:
+-    remove_proc_entry("AR7_RESET_FILE",NULL);
+-	return;
++	/* Start the timer */
++	reset_timer_func(0);
+ }
+ #endif
+ /*************wwzh****************/
+ #if 1
+-extern unsigned int sys_mod_state;
+-extern unsigned int  wan_mod_state;
+-extern unsigned int wlan_mod_state;
+-void sys_led_init(void)
++static void sys_led_init(void)
+ {
+ 	tnetd73xx_gpio_ctrl(4, GPIO_PIN, GPIO_OUTPUT_PIN);
+ 	tnetd73xx_gpio_ctrl(5, GPIO_PIN, GPIO_OUTPUT_PIN);
+@@ -189,30 +191,28 @@
+ 	tnetd73xx_gpio_out(4, FALSE);
+ 	tnetd73xx_gpio_out(5, TRUE);
+ 	tnetd73xx_gpio_out(8, TRUE);
+-	
+ 
+ 	sys_mod_state = 2;
+-
+ }
+-void wan_led_init(void)
++
++static void wan_led_init(void)
+ {
+-	
+ 	tnetd73xx_gpio_ctrl(2, GPIO_PIN, GPIO_OUTPUT_PIN);
+ 	tnetd73xx_gpio_ctrl(3, GPIO_PIN, GPIO_OUTPUT_PIN);
+-	
++
+ 	tnetd73xx_gpio_out(2, FALSE);
+ 	tnetd73xx_gpio_out(3, FALSE);
+ 
+ 	wan_mod_state = 1;
+ }
+-//wwzh wireless
+-#if 0
+-void wlan_led_init(void)
++
++#if defined(CONFIG_AR7_VLYNQ)
++static void wlan_led_init(void)
+ {
+-	//unsigned long i = 0;	
++	//unsigned long i = 0;  
+ 	tnetd73xx_gpio_ctrl(12, GPIO_PIN, GPIO_OUTPUT_PIN);
+ 	tnetd73xx_gpio_ctrl(13, GPIO_PIN, GPIO_OUTPUT_PIN);
+-	
++
+ 	tnetd73xx_gpio_out(12, FALSE);
+ 	tnetd73xx_gpio_out(13, TRUE);
+ 	//for (i = 0; i < 0x20000000; i++);
+@@ -231,152 +231,147 @@
+ 	sys_led_init();
+ 	wan_led_init();
+ 
++	proc_mkdir(AR7_PROC_DIRECTORY, NULL);
++
+ 	//junzhao 2004.3.15
+ 	hardware_version_init();
+-	
+-	//wlan_led_init();
+ 
+-  	/* Register Device MAX_LED_ID + 1 for reset to factory default */
+-	 temp[0].param = 0;
+- 	 temp[0].init = reset_init;
+-  	 temp[0].onfunc = 0;
+- 	 temp[0].offfunc = 0;
+-	 register_led_drv( MAX_LED_ID + 1 , &temp[0]);
++#if defined(CONFIG_AR7_VLYNQ)
++	wlan_led_init();
++#endif
++
++	/* Register Device MAX_LED_ID + 1 for reset to factory default */
++	temp[0].param = 0;
++	temp[0].init = reset_init;
++	temp[0].onfunc = 0;
++	temp[0].offfunc = 0;
++	register_led_drv(MAX_LED_ID + 1, &temp[0]);
+ //wwzh for wireless led  
+ #if 1
+-  /* Register led 12 WiFi 6 */
+-  temp[1].param = 6;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-  register_led_drv( 12 , &temp[1]);
+-
++	/* Register led 12 WiFi 6 */
++	temp[1].param = 6;
++	temp[1].init = gpio_led_init;
++	temp[1].onfunc = gpio_led_on;
++	temp[1].offfunc = gpio_led_off;
++	register_led_drv(12, &temp[1]);
+ #endif
+ 
+ #if 0
+ /**************end ************/
+ #if defined(CONFIG_AR5D01)
+-  /* Register led 1 GPIO0 */
+-  temp[0].param = GPIO_0;
+-  temp[0].init = gpio_led_init;
+-  temp[0].onfunc = gpio_led_on;
+-  temp[0].offfunc = gpio_led_off;
+-	register_led_drv( 1 , &temp[0]);
+-
+-  /* Register led 2 EINT1 */
+-  temp[1].param = EINT_1;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-	register_led_drv( 2 , &temp[1]);
+-
+-  /* Register led 5 EINT1 */
+-  temp[2].param = GPIO_1;
+-  temp[2].init = gpio_led_init;
+-  temp[2].onfunc = gpio_led_on;
+-  temp[2].offfunc = gpio_led_off;
+-	register_led_drv( 5 , &temp[2]);
++	/* Register led 1 GPIO0 */
++	temp[0].param = GPIO_0;
++	temp[0].init = gpio_led_init;
++	temp[0].onfunc = gpio_led_on;
++	temp[0].offfunc = gpio_led_off;
++	register_led_drv(1, &temp[0]);
++
++	/* Register led 2 EINT1 */
++	temp[1].param = EINT_1;
++	temp[1].init = gpio_led_init;
++	temp[1].onfunc = gpio_led_on;
++	temp[1].offfunc = gpio_led_off;
++	register_led_drv(2, &temp[1]);
++
++	/* Register led 5 EINT1 */
++	temp[2].param = GPIO_1;
++	temp[2].init = gpio_led_init;
++	temp[2].onfunc = gpio_led_on;
++	temp[2].offfunc = gpio_led_off;
++	register_led_drv(5, &temp[2]);
+ #endif
+ 
+ #if defined(CONFIG_AR5W01)
+-  /* Register led 5 GPIO_1 */
+-  temp[0].param = GPIO_1;
+-  temp[0].init = gpio_led_init;
+-  temp[0].onfunc = gpio_led_on;
+-  temp[0].offfunc = gpio_led_off;
+-	register_led_drv( 5 , &temp[0]);
+-
+-  /* Register led 7 GPIO_0 */
+-  temp[1].param = GPIO_0;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-	register_led_drv( 7 , &temp[1]);
++	/* Register led 5 GPIO_1 */
++	temp[0].param = GPIO_1;
++	temp[0].init = gpio_led_init;
++	temp[0].onfunc = gpio_led_on;
++	temp[0].offfunc = gpio_led_off;
++	register_led_drv(5, &temp[0]);
++
++	/* Register led 7 GPIO_0 */
++	temp[1].param = GPIO_0;
++	temp[1].init = gpio_led_init;
++	temp[1].onfunc = gpio_led_on;
++	temp[1].offfunc = gpio_led_off;
++	register_led_drv(7, &temp[1]);
+ #endif
+ 
+ //wwzh #if defined(CONFIG_AR7RD)
+ #if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+-  /* Register led 5 Green PPPOE GPIO 13 */
+-  temp[0].param = 13;
+-  temp[0].init = gpio_led_init;
+-  temp[0].onfunc = gpio_led_on;
+-  temp[0].offfunc = gpio_led_off;
+-	register_led_drv( 5 , &temp[0]);
+-
+-  /* Register led 7 Green USB GPIO 12 */
+-  temp[1].param = 12;
+-  temp[1].init = gpio_led_init;
+-  temp[1].onfunc = gpio_led_on;
+-  temp[1].offfunc = gpio_led_off;
+-	register_led_drv( 7 , &temp[1]);
+-
+-  /* Register Device MAX_LED_ID + 1 for reset to factory default */
+-  temp[2].param = 0;
+-  temp[2].init = reset_init;
+-  temp[2].onfunc = 0;
+-  temp[2].offfunc = 0;
+-	register_led_drv( MAX_LED_ID + 1 , &temp[2]);
+-
+-  /* Register led 8 RED DSL GPIO 10 */
+-  temp[3].param = 10;
+-  temp[3].init = gpio_led_init;
+-  temp[3].onfunc = gpio_led_on;
+-  temp[3].offfunc = gpio_led_off;
+-	register_led_drv( 8 , &temp[3]);
+-
+-  /* Register led 9 RED PPPoE down GPIO 9 */
+-  temp[4].param = 9;
+-  temp[4].init = gpio_led_init;
+-  temp[4].onfunc = gpio_led_on;
+-  temp[4].offfunc = gpio_led_off;
+-	register_led_drv( 9 , &temp[4]);
+-
+-  /* Register led 10 DSL down GPIO 8 */
+-  temp[5].param = 8;
+-  temp[5].init = gpio_led_init;
+-  temp[5].onfunc = gpio_led_on;
+-  temp[5].offfunc = gpio_led_off;
+-	register_led_drv( 10 , &temp[5]);
+-
+-  /* Register led 11 Power GPIO 7 */
+-  temp[6].param = 7;
+-  temp[6].init = gpio_led_init;
+-  temp[6].onfunc = gpio_led_on;
+-  temp[6].offfunc = gpio_led_off;
+-	register_led_drv( 11 , &temp[6]);
+-
+-  /* Register led 12 WiFi 6 */
+-  temp[7].param = 6;
+-  temp[7].init = gpio_led_init;
+-  temp[7].onfunc = gpio_led_on;
+-  temp[7].offfunc = gpio_led_off;
+-	register_led_drv( 12 , &temp[7]);
+-
+-  /* Register led 13 ELINK(AA1313) GPIO 15 */
+-  temp[8].param = 15;
+-  temp[8].init = gpio_led_init;
+-  temp[8].onfunc = gpio_led_on;
+-  temp[8].offfunc = gpio_led_off;
+-	register_led_drv( 13 , &temp[8]);
+-
+-  /* Register led 14 EACT(Y13) GPIO 16 */
+-  temp[9].param = 16;
+-  temp[9].init = gpio_led_init;
+-  temp[9].onfunc = gpio_led_on;
+-  temp[9].offfunc = gpio_led_off;
+-	register_led_drv( 14 , &temp[9]);
++	/* Register led 5 Green PPPOE GPIO 13 */
++	temp[0].param = 13;
++	temp[0].init = gpio_led_init;
++	temp[0].onfunc = gpio_led_on;
++	temp[0].offfunc = gpio_led_off;
++	register_led_drv(5, &temp[0]);
++
++	/* Register led 7 Green USB GPIO 12 */
++	temp[1].param = 12;
++	temp[1].init = gpio_led_init;
++	temp[1].onfunc = gpio_led_on;
++	temp[1].offfunc = gpio_led_off;
++	register_led_drv(7, &temp[1]);
++
++	/* Register Device MAX_LED_ID + 1 for reset to factory default */
++	temp[2].param = 0;
++	temp[2].init = reset_init;
++	temp[2].onfunc = 0;
++	temp[2].offfunc = 0;
++	register_led_drv(MAX_LED_ID + 1, &temp[2]);
++
++	/* Register led 8 RED DSL GPIO 10 */
++	temp[3].param = 10;
++	temp[3].init = gpio_led_init;
++	temp[3].onfunc = gpio_led_on;
++	temp[3].offfunc = gpio_led_off;
++	register_led_drv(8, &temp[3]);
++
++	/* Register led 9 RED PPPoE down GPIO 9 */
++	temp[4].param = 9;
++	temp[4].init = gpio_led_init;
++	temp[4].onfunc = gpio_led_on;
++	temp[4].offfunc = gpio_led_off;
++	register_led_drv(9, &temp[4]);
++
++	/* Register led 10 DSL down GPIO 8 */
++	temp[5].param = 8;
++	temp[5].init = gpio_led_init;
++	temp[5].onfunc = gpio_led_on;
++	temp[5].offfunc = gpio_led_off;
++	register_led_drv(10, &temp[5]);
++
++	/* Register led 11 Power GPIO 7 */
++	temp[6].param = 7;
++	temp[6].init = gpio_led_init;
++	temp[6].onfunc = gpio_led_on;
++	temp[6].offfunc = gpio_led_off;
++	register_led_drv(11, &temp[6]);
++
++	/* Register led 12 WiFi 6 */
++	temp[7].param = 6;
++	temp[7].init = gpio_led_init;
++	temp[7].onfunc = gpio_led_on;
++	temp[7].offfunc = gpio_led_off;
++	register_led_drv(12, &temp[7]);
++
++	/* Register led 13 ELINK(AA1313) GPIO 15 */
++	temp[8].param = 15;
++	temp[8].init = gpio_led_init;
++	temp[8].onfunc = gpio_led_on;
++	temp[8].offfunc = gpio_led_off;
++	register_led_drv(13, &temp[8]);
++
++	/* Register led 14 EACT(Y13) GPIO 16 */
++	temp[9].param = 16;
++	temp[9].init = gpio_led_init;
++	temp[9].onfunc = gpio_led_on;
++	temp[9].offfunc = gpio_led_off;
++	register_led_drv(14, &temp[9]);
+ 
+ #endif
+ /**************wwzh**************/
+ #endif
+ /**************end **************/
+-  return;
++	return;
+ }
+-
+-
+-
+-
+-
+-
+-
+-
+diff -urN linux-2.4.32/drivers/char/avalanche_led/led.h linux-2.4.32.new/drivers/char/avalanche_led/led.h
+--- linux-2.4.32/drivers/char/avalanche_led/led.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/led.h	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,15 @@
++/* ledmod.c */
++extern unsigned int sys_mod_state;
++extern unsigned int wan_mod_state;
++extern unsigned int wlan_mod_state;
++void led_operation(int mod, int state);
++void register_led_drv(int device, led_reg_t * pInfo);
++
++/* gpio.c */
++void board_gpio_init(void);
++
++/* leds.c */
++void avalanche_leds_init(void);
++
++/* uartled.c */
++void uart_led_init(void);
+diff -urN linux-2.4.32/drivers/char/avalanche_led/ledmod.c linux-2.4.32.new/drivers/char/avalanche_led/ledmod.c
+--- linux-2.4.32/drivers/char/avalanche_led/ledmod.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/ledmod.c	2005-12-27 21:44:16.000000000 +0100
+@@ -1,3 +1,10 @@
++/*
++ * Check:
++ * pTimer->data is unsigned long, pState is a pointer.
++ * What is the use of these assignments:
++ * led_arr[pState->led].pTimer->data = pState;
++ */
++
+ #include <linux/config.h>
+ #include <linux/init.h>
+ #include <linux/kernel.h>
+@@ -9,8 +16,11 @@
+ #include <linux/spinlock.h>
+ #include <asm/ar7/avalanche_regs.h>
+ #include <asm/ar7/ledapp.h>
++#include <asm/ar7/tnetd73xx_misc.h>	/* tnetd73xx_gpio_out */
+ #include <linux/module.h>
+ 
++#include "led.h"
++
+ #define LED_ON  		1
+ #define LED_OFF 		2
+ #define LED_BLINK   3
+@@ -19,189 +29,181 @@
+ #define LED_BLINK_UP   		5
+ #define LED_BLINK_DOWN   	6
+ 
+-extern void avalanche_leds_init(void);
++#if 0
++# define DPRINTK(format, args...) printk(KERN_DEBUG format, ## args)
++#else
++# define DPRINTK(format, args...) ((void)0)
++#endif
+ 
+ /***********wwzh**************/
+ unsigned int sys_mod_state;
+ unsigned int wan_mod_state;
+ unsigned int wlan_mod_state;
+ 
+-struct timer_list *pWanTimer = NULL;
+-struct timer_list *pWlanTimer = NULL;
++static struct timer_list *pWanTimer = NULL;
++static struct timer_list *pWlanTimer = NULL;
+ /***********end **************/
+ 
+-typedef struct state_entry{
+-  unsigned char mode;
+-  unsigned char led;
+-	void (*handler)(struct state_entry *pState);
+-  unsigned long param;
+-}state_entry_t;
+-
+-typedef struct mod_entry{
+-  state_entry_t *states[MAX_STATE_ID];
+-}mod_entry_t;
++typedef struct state_entry {
++	unsigned char mode;
++	unsigned char led;
++	void (*handler) (struct state_entry * pState);
++	unsigned long param;
++} state_entry_t;
++
++typedef struct mod_entry {
++	state_entry_t *states[MAX_STATE_ID];
++} mod_entry_t;
+ 
+ static mod_entry_t *modArr[MAX_MOD_ID];
+-static struct proc_dir_entry *led_proc_dir,*led_file;
++static struct proc_dir_entry *led_proc_dir, *led_file;
+ 
+ /* index of the array is the led number HARDWARE SPECIFIC*/
+-typedef struct led_data{
++typedef struct led_data {
+ 	led_reg_t *led;
+-  int				state;
++	int state;
+ 	struct timer_list *pTimer;
+ 	unsigned char timer_running;
+-  unsigned long param;
+-}led_data_t;
++	unsigned long param;
++} led_data_t;
+ 
+-led_data_t led_arr[MAX_LED_ID + 1];
++static led_data_t led_arr[MAX_LED_ID + 1];
+ /*!!! The last device is actually being used for ar7 reset to factory default */
+ 
++static spinlock_t config_lock;
+ 
+-static spinlock_t	config_lock;
+-
+-static void board_led_link_up( state_entry_t *pState );
+-static void board_led_link_down( state_entry_t *pState );
+-static void board_led_activity_on( state_entry_t *pState );
+-static void board_led_activity_off( state_entry_t *pState );
++static void board_led_link_up(state_entry_t * pState);
++static void board_led_link_down(state_entry_t * pState);
++static void board_led_activity_on(state_entry_t * pState);
++static void board_led_activity_off(state_entry_t * pState);
+ static void led_timer_func(unsigned long data);
+ 
+-extern void board_gpio_init(void);
+-extern void uart_led_init(void);
+-
+ static ssize_t proc_read_led_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp);
+-static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+-                                                      size_t count , loff_t *offp);
+-static int config_led( unsigned long y);
++				  char *buf, size_t count, loff_t * offp);
++static ssize_t proc_write_led_fops(struct file *filp, const char *buffer,
++				   size_t count, loff_t * offp);
++static int config_led(unsigned long y);
+ 
+ struct file_operations led_fops = {
+-                                     read: proc_read_led_fops,
+-                                     write: proc_write_led_fops,
+-                                   };
++      read:proc_read_led_fops,
++      write:proc_write_led_fops,
++};
+ 
+-static int led_atoi( char *name)
++static int led_atoi(char *name)
+ {
+ 	int val = 0;
+-  for(;;name++)
+-	{
+-		switch(*name)
+-		{
+-			case '0'...'9':
+-				val = val*10+(*name - '0');
+-				break;
+-			default:
+-				return val;
++	for (;; name++) {
++		switch (*name) {
++		case '0'...'9':
++			val = val * 10 + (*name - '0');
++			break;
++		default:
++			return val;
+ 		}
+ 	}
+ }
+ 
+ static int free_memory(void)
+ {
+-  int i, j;
++	int i, j;
+ 
+-  for( i = 0; i < MAX_MOD_ID ; i++)
+-	{
+-		if( modArr[i] != NULL )
+-		{
+-			for( j = 0; j < MAX_STATE_ID ; j++ )
+-			{
+-				if( modArr[i]->states[j] != NULL )
+-					kfree( modArr[i]->states[j]);
++	for (i = 0; i < MAX_MOD_ID; i++) {
++		if (modArr[i] != NULL) {
++			for (j = 0; j < MAX_STATE_ID; j++) {
++				if (modArr[i]->states[j] != NULL)
++					kfree(modArr[i]->states[j]);
+ 			}
+ 			kfree(modArr[i]);
+-      modArr[i] = NULL;
++			modArr[i] = NULL;
+ 		}
+ 	}
+-  return 0;
++	return 0;
+ }
+ 
+-static int led_on( state_entry_t *pState )
++static int led_on(state_entry_t * pState)
+ {
+-	if( led_arr[pState->led].led == NULL)
++	if (led_arr[pState->led].led == NULL)
+ 		return -1;
+-  led_arr[pState->led].led->onfunc( led_arr[pState->led].led->param);
+-  return 0;
++	led_arr[pState->led].led->onfunc(led_arr[pState->led].led->param);
++	return 0;
+ }
+ 
+-static int led_off( state_entry_t *pState )
++static int led_off(state_entry_t * pState)
+ {
+-	if( led_arr[pState->led].led == NULL)
++	if (led_arr[pState->led].led == NULL)
+ 		return -1;
+-  led_arr[pState->led].led->offfunc( led_arr[pState->led].led->param);
+-  return 0;
++	led_arr[pState->led].led->offfunc(led_arr[pState->led].led->param);
++	return 0;
+ }
+ 
+-static void board_led_link_up( state_entry_t *pState )
++static void board_led_link_up(state_entry_t * pState)
+ {
+-  led_arr[pState->led].state = LED_ON;
+-  if( led_arr[pState->led].timer_running == 0 )
+-  	led_on(pState);
+-  return;
++	led_arr[pState->led].state = LED_ON;
++	if (led_arr[pState->led].timer_running == 0)
++		led_on(pState);
++	return;
+ }
+ 
+-static void board_led_link_down( state_entry_t *pState )
++static void board_led_link_down(state_entry_t * pState)
+ {
+ 	led_arr[pState->led].state = LED_OFF;
+-  if( led_arr[pState->led].timer_running == 0 )
+-  	led_off(pState);
+-  return;
++	if (led_arr[pState->led].timer_running == 0)
++		led_off(pState);
++	return;
+ }
+ 
+-static void add_led_timer(state_entry_t *pState)
++static void add_led_timer(state_entry_t * pState)
+ {
+-	led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+-  led_arr[pState->led].param = pState->param;
+-  led_arr[pState->led].pTimer->data = pState;
+-	add_timer (led_arr[pState->led].pTimer);
++	led_arr[pState->led].pTimer->expires =
++	    jiffies + HZ * (pState->param) / 1000;
++	led_arr[pState->led].param = pState->param;
++	led_arr[pState->led].pTimer->data = pState;
++	add_timer(led_arr[pState->led].pTimer);
+ }
+ 
+-static void board_led_activity_on(state_entry_t *pState)
++static void board_led_activity_on(state_entry_t * pState)
+ {
+-  if(led_arr[pState->led].timer_running == 0)
+-	{
++	if (led_arr[pState->led].timer_running == 0) {
+ 		led_on(pState);
+ 		add_led_timer(pState);
+-	  led_arr[pState->led].timer_running = 1;
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-	}
+-	else if( led_arr[pState->led].timer_running > 0xF0)
+-	{
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-		led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+-  	led_arr[pState->led].param = pState->param;
+-  	led_arr[pState->led].pTimer->data = pState;
++		led_arr[pState->led].timer_running = 1;
++		led_arr[pState->led].state = LED_BLINK_UP;
++	} else if (led_arr[pState->led].timer_running > 0xF0) {
++		led_arr[pState->led].state = LED_BLINK_UP;
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (pState->param) / 1000;
++		led_arr[pState->led].param = pState->param;
++		led_arr[pState->led].pTimer->data = pState;
+ 	}
+ 	return;
+ }
+ 
+-static void board_led_activity_off(state_entry_t *pState)
++static void board_led_activity_off(state_entry_t * pState)
+ {
+-  if(led_arr[pState->led].timer_running == 0)
+-	{
++	if (led_arr[pState->led].timer_running == 0) {
+ 		led_off(pState);
+ 		add_led_timer(pState);
+-	  led_arr[pState->led].timer_running = 1;
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-	}
+-	else if( led_arr[pState->led].timer_running > 0xF0)
+-	{
+-	  led_arr[pState->led].state = LED_BLINK_UP;
+-		led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+-  	led_arr[pState->led].param = pState->param;
+-  	led_arr[pState->led].pTimer->data = pState;
++		led_arr[pState->led].timer_running = 1;
++		led_arr[pState->led].state = LED_BLINK_UP;
++	} else if (led_arr[pState->led].timer_running > 0xF0) {
++		led_arr[pState->led].state = LED_BLINK_UP;
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (pState->param) / 1000;
++		led_arr[pState->led].param = pState->param;
++		led_arr[pState->led].pTimer->data = pState;
+ 	}
+ 	return;
+ }
+ 
+-static void board_led_link_flash(state_entry_t *pState)
++static void board_led_link_flash(state_entry_t * pState)
+ {
+-  if(led_on(pState))
++	if (led_on(pState))
+ 		return;
+-  if(led_arr[pState->led].timer_running == 0)
++	if (led_arr[pState->led].timer_running == 0)
+ 		add_led_timer(pState);
+ 	else
+-    led_arr[pState->led].param = pState->param;
+-  led_arr[pState->led].timer_running = 0xFF;
++		led_arr[pState->led].param = pState->param;
++	led_arr[pState->led].timer_running = 0xFF;
+ 	led_arr[pState->led].state = LED_FLASH;
+ 	return;
+ }
+@@ -209,235 +211,236 @@
+ static void led_timer_func(unsigned long data)
+ {
+ 	state_entry_t *pState = NULL;
+-  mod_entry_t *pMod = NULL;
++	// mod_entry_t *pMod = NULL;
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+-  pState = (state_entry_t *)data;
++	pState = (state_entry_t *) data;
+ 
+-  if( led_arr[pState->led].state == LED_BLINK_DOWN )
+-	{
++	if (led_arr[pState->led].state == LED_BLINK_DOWN) {
+ 		led_arr[pState->led].timer_running = 0;
+-		if( pState->mode == 2 )
++		if (pState->mode == 2)
+ 			led_arr[pState->led].state = LED_OFF;
+ 		else
+ 			led_arr[pState->led].state = LED_ON;
+-	}
+-  else if( led_arr[pState->led].state == LED_BLINK_UP )
+-	{
+-    led_arr[pState->led].pTimer->expires = jiffies + HZ*(led_arr[pState->led].param)/1000;
+-  	led_arr[pState->led].pTimer->data = pState;
+-		add_timer (led_arr[pState->led].pTimer);
+-		if( pState->mode == 2 )
+-		{
+-  		led_off(pState);
++	} else if (led_arr[pState->led].state == LED_BLINK_UP) {
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (led_arr[pState->led].param) / 1000;
++		led_arr[pState->led].pTimer->data = pState;
++		add_timer(led_arr[pState->led].pTimer);
++		if (pState->mode == 2) {
++			led_off(pState);
+ 			led_arr[pState->led].state = LED_BLINK_DOWN;
+-		}
+-		else
+-		{
+-  		led_on(pState);
++		} else {
++			led_on(pState);
+ 			led_arr[pState->led].state = LED_BLINK_DOWN;
+ 		}
+ 		led_arr[pState->led].timer_running = 1;
+-	}
+-  else if( led_arr[pState->led].state == LED_FLASH )
+-	{
+-    led_arr[pState->led].pTimer->expires = jiffies + HZ*(led_arr[pState->led].param)/1000;
+-  	led_arr[pState->led].pTimer->data = pState;
+-		add_timer (led_arr[pState->led].pTimer);
+-
+-		if( led_arr[pState->led].timer_running == 0xFF )
+-		{
+-  		led_off(pState);
++	} else if (led_arr[pState->led].state == LED_FLASH) {
++		led_arr[pState->led].pTimer->expires =
++		    jiffies + HZ * (led_arr[pState->led].param) / 1000;
++		led_arr[pState->led].pTimer->data = pState;
++		add_timer(led_arr[pState->led].pTimer);
++
++		if (led_arr[pState->led].timer_running == 0xFF) {
++			led_off(pState);
+ 			led_arr[pState->led].timer_running--;
+-		}
+-		else
+-		{
+-  		led_on(pState);
++		} else {
++			led_on(pState);
+ 			led_arr[pState->led].timer_running++;
+ 		}
+ 		spin_unlock_irqrestore(&config_lock, flags);
+-    return;
+-	}
+-  else if(led_arr[pState->led].state == LED_OFF)
+-	{
+-  	led_off(pState);
+-    led_arr[pState->led].timer_running = 0;
+-	}
+-	else if( led_arr[pState->led].state == LED_ON )
+-	{
+-  	led_on(pState);
+-    led_arr[pState->led].timer_running = 0;
++		return;
++	} else if (led_arr[pState->led].state == LED_OFF) {
++		led_off(pState);
++		led_arr[pState->led].timer_running = 0;
++	} else if (led_arr[pState->led].state == LED_ON) {
++		led_on(pState);
++		led_arr[pState->led].timer_running = 0;
+ 	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+-  return;
++	return;
+ }
++
+ /************wwzh*****************/
+ #if 0
+ /************end *****************/
+ static ssize_t proc_read_led_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				  char *buf, size_t count, loff_t * offp)
+ {
+-  char * pdata = NULL;
+-  int i = 0, j = 0, len = 0, totallen = 0;
+-  char line[255];
+-
+-  if( *offp != 0 )
+-  	return 0;
+-
+-  pdata = buf;
+-  len += sprintf(line,"LEDS Registered for use are:");
+-  for( i = 0; i< MAX_LED_ID; i++)
+-		if( led_arr[i].led != NULL )
+-			len += sprintf(&line[len]," %d ", i );
+-  line[len++] = '\n';
+-
+-  copy_to_user(pdata, line,len );
+-  pdata += len;
+-  totallen += len;
+-  len = 0;
+-  len = sprintf(line,"USER MODULE INFORMATION:\n");
+-  copy_to_user(pdata, line,len );
+-  pdata += len;
+-  totallen += len;
+-  len = 0;
+-  for( i = 0; i< MAX_MOD_ID; i++)
+-	{
+-		if( modArr[i] != NULL )
+-		{
+-			len = sprintf(line,"  Module ID = %d \n" , i);
+-  		copy_to_user(pdata, line,len );
+-      pdata += len;
+-  		totallen += len;
+-  		len = 0;
+- 			for( j = 0; j < MAX_STATE_ID; j++)
+-			{
+-				if( modArr[i]->states[j] != NULL)
+-				{
+-					len = sprintf(line ,
+-                		"    State = %d , Led = %d," , j , modArr[i]->states[j]->led);
+-  				copy_to_user(pdata, line,len );
+-          pdata += len;
+-  				totallen += len;
+-
+-  				len = 0;
+-          switch( modArr[i]->states[j]->mode )
+-					{
+-						case 1:
+-									len = sprintf(line ," Mode = OFF\n");
+-									break;
+-						case 2:
+-									len = sprintf(line ," Mode = BLINK_ON , On Time(ms) = %d\n" ,
+-                                       (unsigned int)modArr[i]->states[j]->param);
+-									break;
+-						case 3:
+-									len = sprintf(line ," Mode = BLINK_OFF , Off Time(ms) = %d\n" ,
+-                                       (unsigned int)modArr[i]->states[j]->param);
+-									break;
+-						case 4:
+-									len = sprintf(line ," Mode = ON \n");
+-									break;
+-						case 5:
+-									len = sprintf(line ," Mode = FLASH , Time Period(ms) = %d\n" ,
+-                                       (unsigned int)modArr[i]->states[j]->param);
+-									break;
+-						default:
+-							break;
++	char *pdata = NULL;
++	int i = 0, j = 0, len = 0, totallen = 0;
++	char line[255];
++
++	if (*offp != 0)
++		return 0;
++
++	if (count < 4096) {
++		printk("%s might destroy user data (buffer size %u too small\n",
++		       __FUNCTION__, count);
++	}
++
++	pdata = buf;
++	len += sprintf(line, "LEDS Registered for use are:");
++	for (i = 0; i < MAX_LED_ID; i++)
++		if (led_arr[i].led != NULL)
++			len += sprintf(&line[len], " %d ", i);
++	line[len++] = '\n';
++
++	copy_to_user(pdata, line, len);
++	pdata += len;
++	totallen += len;
++	len = 0;
++	len = sprintf(line, "USER MODULE INFORMATION:\n");
++	copy_to_user(pdata, line, len);
++	pdata += len;
++	totallen += len;
++	len = 0;
++	for (i = 0; i < MAX_MOD_ID; i++) {
++		if (modArr[i] != NULL) {
++			len = sprintf(line, "  Module ID = %d \n", i);
++			copy_to_user(pdata, line, len);
++			pdata += len;
++			totallen += len;
++			len = 0;
++			for (j = 0; j < MAX_STATE_ID; j++) {
++				if (modArr[i]->states[j] != NULL) {
++					len = sprintf(line,
++						      "    State = %d , Led = %d,",
++						      j,
++						      modArr[i]->states[j]->
++						      led);
++					copy_to_user(pdata, line, len);
++					pdata += len;
++					totallen += len;
++
++					len = 0;
++					switch (modArr[i]->states[j]->mode) {
++					case 1:
++						len =
++						    sprintf(line,
++							    " Mode = OFF\n");
++						break;
++					case 2:
++						len =
++						    sprintf(line,
++							    " Mode = BLINK_ON , On Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 3:
++						len =
++						    sprintf(line,
++							    " Mode = BLINK_OFF , Off Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 4:
++						len =
++						    sprintf(line,
++							    " Mode = ON \n");
++						break;
++					case 5:
++						len =
++						    sprintf(line,
++							    " Mode = FLASH , Time Period(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					default:
++						len =
++						    sprintf(line, "Mode = %u\n",
++							    modArr[i]->
++							    states[j]->mode);
++						break;
+ 
+ 					}
+-  				copy_to_user(pdata, line,len );
+-          pdata += len;
+-  				totallen += len;
++					copy_to_user(pdata, line, len);
++					pdata += len;
++					totallen += len;
+ 
+-  				len = 0;
++					len = 0;
+ 				}
+ 			}
+ 		}
+ 	}
+-  /* Return with configuration information for LEDs */
++	/* Return with configuration information for LEDs */
+ 	*offp = totallen;
+ 	return totallen;
+ }
+-static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+-                                                      size_t count , loff_t *offp)
++static ssize_t proc_write_led_fops(struct file *filp, const char *buffer,
++				   size_t count, loff_t * offp)
+ {
+-  char *pdata = NULL, *ptemp = NULL;
+-  char line[10],temp[10];
+-  int i = 0;
+-  int mod = 0xFFFF , state = 0xFFFF;
+-  int flag = 0;
+-
+-  /* Check if this write is for configuring stuff */
+-  if( *(int *)(buffer) == 0xFFEEDDCC )
+-	{
+-    printk("<1>proc write:Calling Configuration\n");
+-		config_led((unsigned long)(buffer + sizeof(int)) );
++	char *pdata = NULL, *ptemp = NULL;
++	char line[10], temp[10];
++	int i = 0;
++	int mod = 0xFFFF, state = 0xFFFF;
++	int flag = 0;
++
++	/* Check if this write is for configuring stuff */
++	if (*(int *)(buffer) == 0xFFEEDDCC) {
++		printk("<1>proc write:Calling Configuration\n");
++		config_led((unsigned long)(buffer + sizeof(int)));
+ 		return count;
+ 	}
+ 
+-  if( count >= 10)
+-	{
+-    printk("<1>proc write:Input too long,max length = %d\n",10);
+-    return count;
+-	}
+-  memset( temp, 0x00 , 10);
+-  memset( line, 0x00 , 10);
+-  copy_from_user(line,buffer,count);
+-  line[count] = 0x00;
+-  pdata = line;
+-  ptemp = temp;
+-  while( flag == 0)
+-  {
+-		if( i > 10 )
+-			break;
+-		if( ((*pdata) >= '0' ) && ((*pdata) <= '9') )
+-		{	
+-			*ptemp = *pdata ;
++	if (count >= 10) {
++		printk("<1>proc write:Input too long,max length = %d\n", 10);
++		return count;
++	}
++	memset(temp, 0x00, 10);
++	memset(line, 0x00, 10);
++	copy_from_user(line, buffer, count);
++	line[count] = 0x00;
++	pdata = line;
++	ptemp = temp;
++	while (flag == 0) {
++		if (i > 10)
++			break;
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
++			*ptemp = *pdata;
+ 			ptemp++;
+-		}	
+-		else if( (*pdata) == ',' )
+-		{
+-      *ptemp = 0x00;
++		} else if ((*pdata) == ',') {
++			*ptemp = 0x00;
+ 			flag = 1;
+-		}	
++		}
+ 		pdata++;
+ 		i++;
+-  };
+-	if( flag == 1)
+-  	mod = led_atoi( temp);
++	};
++	if (flag == 1)
++		mod = led_atoi(temp);
+ 	else
+ 		return count;
+-		
+-  ptemp = temp;
+-  *ptemp = 0x00;
+-  flag = 0;
+-  while( flag == 0)
+-  {
+-		if( i > 10 )
+-			break;
+-		if( ((*pdata) >= '0' ) && ((*pdata) <= '9') )
+-		{	
+-			*ptemp = *pdata ;
++
++	ptemp = temp;
++	*ptemp = 0x00;
++	flag = 0;
++	while (flag == 0) {
++		if (i > 10)
++			break;
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
++			*ptemp = *pdata;
+ 			ptemp++;
+-		}	
+-		else if( (*pdata) == 0x00 )
+-		{
+-      *ptemp = 0x00;
++		} else if ((*pdata) == 0x00) {
++			*ptemp = 0x00;
+ 			flag = 1;
+-		}	
++		}
+ 		pdata++;
+-    i++;
+-  };
+-	if( flag == 1)
+-  	state = led_atoi( temp);
++		i++;
++	};
++	if (flag == 1)
++		state = led_atoi(temp);
+ 	else
+ 		return count;
+-  if( (mod == 0xFFFF) || (state == 0xFFFF))
++	if ((mod == 0xFFFF) || (state == 0xFFFF))
+ 		return count;
+-  else
+-    led_operation( mod , state );
+-  return count;
++	else
++		led_operation(mod, state);
++	return count;
+ }
+ 
+ /************wwzh*******************/
+@@ -449,44 +452,38 @@
+ static unsigned int wan_txrx_state = 0;
+ static unsigned int wlan_txrx_state = 0;
+ 
+-void led_operation( int mod , int state)
++void led_operation(int mod, int state)
+ {
+ 
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+-	if( (mod >= MAX_MOD_ID) || ( state >= MAX_STATE_ID) )
+-	{
+-	  spin_unlock_irqrestore(&config_lock, flags);
++	if ((mod >= MAX_MOD_ID) || (state >= MAX_STATE_ID)) {
++		spin_unlock_irqrestore(&config_lock, flags);
+ 		return;
+ 	}
+- 	if ( modArr[mod] == NULL )
+-	{
+-	  spin_unlock_irqrestore(&config_lock, flags);
++	if (modArr[mod] == NULL) {
++		spin_unlock_irqrestore(&config_lock, flags);
+ 		return;
+ 	}
+-	if( modArr[mod]->states[state] == NULL )
+-	{
+-	  spin_unlock_irqrestore(&config_lock, flags);
++	if (modArr[mod]->states[state] == NULL) {
++		spin_unlock_irqrestore(&config_lock, flags);
+ 		return;
+ 	}
+-  /* Call the function handler  */
+-  modArr[mod]->states[state]->handler(modArr[mod]->states[state]);
++	/* Call the function handler  */
++	modArr[mod]->states[state]->handler(modArr[mod]->states[state]);
+ 
+ 	spin_unlock_irqrestore(&config_lock, flags);
+ }
+ 
+ static void wan_led_func(unsigned long data)
+ {
+-	if (wan_txrx_state == 0)
+-	{
++	if (wan_txrx_state == 0) {
+ 		tnetd73xx_gpio_out(2, TRUE);
+ 		tnetd73xx_gpio_out(3, FALSE);
+ 		wan_txrx_state = 1;
+-	}
+-	else
+-	{
++	} else {
+ 		tnetd73xx_gpio_out(2, FALSE);
+ 		tnetd73xx_gpio_out(3, FALSE);
+ 		wan_txrx_state = 0;
+@@ -494,22 +491,20 @@
+ 	pWanTimer->expires = jiffies + FLICK_TIME;
+ 	add_timer(pWanTimer);
+ }
++
+ //wwzh for wireless
+-#if 0
++#if defined(CONFIG_AR7_VLYNQ)
+ static void wlan_led_func(unsigned long data)
+ {
+-	if (wlan_txrx_state == 0)
+-	{
++	if (wlan_txrx_state == 0) {
+ 		tnetd73xx_gpio_out(12, TRUE);
+ 		tnetd73xx_gpio_out(13, FALSE);
+ 		wlan_txrx_state = 1;
+-	}
+-	else
+-	{
++	} else {
+ 		tnetd73xx_gpio_out(12, FALSE);
+ 		tnetd73xx_gpio_out(13, FALSE);
+ 		wlan_txrx_state = 0;
+-		
++
+ 	}
+ 	pWlanTimer->expires = jiffies + FLICK_TIME;
+ 	add_timer(pWlanTimer);
+@@ -522,220 +517,252 @@
+ 
+ //printk("mod = %d state = %d\n", mod, state);
+ 	spin_lock_irqsave(&config_lock, flags);
+-	if ((mod >= 5) || (state >= 5))
+-	{
++	if ((mod >= 5) || (state >= 5)) {
+ 		spin_unlock_irqrestore(&config_lock, flags);
+ 		return;
+ 	}
+-	
+-	switch (mod)
+-	{
+-		case 2: /*system led */
+-			sys_mod_state = state;
+-			switch (state)
+-			{
+-				case 1:	
+-					break;
+-				case 2:  /*sys led flashing green */
+-					tnetd73xx_gpio_out(4, FALSE);
+-					tnetd73xx_gpio_out(5, TRUE);
+-					tnetd73xx_gpio_out(8, TRUE);
+-					break;
+-				case 3: /*sys led solid green */
+-					tnetd73xx_gpio_out(4, TRUE);
+-					tnetd73xx_gpio_out(5, TRUE);
+-					tnetd73xx_gpio_out(8, TRUE);
+-					
+-					break;
+-				case 4: /*sys fail red */
+-					tnetd73xx_gpio_out(4, TRUE);
+-					tnetd73xx_gpio_out(5, FALSE);
+-					tnetd73xx_gpio_out(8, FALSE);
+-					break;
+-				default:
+-					break;
++
++	switch (mod) {
++	case 2:		/*system led */
++		sys_mod_state = state;
++		switch (state) {
++		case 1:
++			break;
++		case 2:	/*sys led flashing green */
++			tnetd73xx_gpio_out(4, FALSE);
++			tnetd73xx_gpio_out(5, TRUE);
++			tnetd73xx_gpio_out(8, TRUE);
++			break;
++		case 3:	/*sys led solid green */
++			tnetd73xx_gpio_out(4, TRUE);
++			tnetd73xx_gpio_out(5, TRUE);
++			tnetd73xx_gpio_out(8, TRUE);
++
++			break;
++		case 4:	/*sys fail red */
++			tnetd73xx_gpio_out(4, TRUE);
++			tnetd73xx_gpio_out(5, FALSE);
++			tnetd73xx_gpio_out(8, FALSE);
++			break;
++		default:
++			break;
++		}
++		break;
++	case 3:		/*wan led */
++		wan_mod_state = state;
++		switch (state) {
++		case 1:	/*no wan interface */
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
+ 			}
++			tnetd73xx_gpio_out(2, FALSE);
++			tnetd73xx_gpio_out(3, FALSE);
+ 			break;
+-		case 3: /*wan led */
+-			wan_mod_state = state;
+-			switch (state)
+-			{
+-				case 1: /*no wan interface*/
+-					if (pWanTimer)
+-					{
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(2, FALSE);
+-					tnetd73xx_gpio_out(3, FALSE);
+-					break;
+-				case 2: /*wan connected */
+-					if (pWanTimer)
+-					{
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(2, TRUE);
+-					tnetd73xx_gpio_out(3, FALSE);
+-					break;
+-				case 3: /*rx/tx activity */
+-					if (pWanTimer != NULL)
+-						break;	
+-				
+-					pWanTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+-					init_timer(pWanTimer);
+-					
+-					pWanTimer->function = wan_led_func;
+-					pWanTimer->data = 0;
+-					pWanTimer->expires = jiffies + FLICK_TIME;
+-					tnetd73xx_gpio_out(2, FALSE);
+-					tnetd73xx_gpio_out(3, FALSE);
+-					wan_txrx_state = 0;
+-					add_timer(pWanTimer);
+-
+-					break;
+-				case 4: /*no ipaddress */
+-					if (pWanTimer)
+-					{
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(2, FALSE);
+-					tnetd73xx_gpio_out(3, TRUE);
+-					break;
+-				default:
+-					if (pWanTimer)
+-					{	
+-						del_timer(pWanTimer);
+-						kfree(pWanTimer);
+-						pWanTimer = NULL;
+-					}
+-					break;
++		case 2:	/*wan connected */
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
+ 			}
++			tnetd73xx_gpio_out(2, TRUE);
++			tnetd73xx_gpio_out(3, FALSE);
+ 			break;
+-	//wwzh for wireless 
+-	#if 0
+-		case 4: /*wlan led */
+-			wlan_mod_state = state;
+-			switch (state)
+-			{
+-				case 1: /* wlan off */
+-					if (pWlanTimer)
+-					{
+-						del_timer(pWlanTimer);
+-						kfree(pWlanTimer);
+-						pWlanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(12, FALSE);
+-					tnetd73xx_gpio_out(13, FALSE);
+-					break;
+-				case 2: /* wlan ready */
+-					if (pWlanTimer)
+-					{
+-						del_timer(pWlanTimer);
+-						kfree(pWlanTimer);
+-						pWlanTimer = NULL;
+-					}
+-					tnetd73xx_gpio_out(12, TRUE);
+-					tnetd73xx_gpio_out(13, FALSE);
+-					break;
+-				case 3: /* wlan rx/tx activity */
+-					if (pWlanTimer != NULL)
+-						break;
+-					
+-					pWlanTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+-					init_timer(pWlanTimer);
+-					
+-					pWlanTimer->function = wlan_led_func;
+-					pWlanTimer->data = 0;
+-					pWlanTimer->expires = jiffies + FLICK_TIME;
+-					tnetd73xx_gpio_out(12, FALSE);
+-					tnetd73xx_gpio_out(13, FALSE);
+-					wlan_txrx_state = 0;
+-					add_timer(pWlanTimer);
+-					
+-					break;
+-				default:
+-					if (pWlanTimer)
+-					{
+-						del_timer(pWlanTimer);
+-						kfree(pWlanTimer);
+-						pWlanTimer = NULL;
+-					}
+-					
+-					break;
++		case 3:	/*rx/tx activity */
++			if (pWanTimer != NULL)
++				break;
++
++			pWanTimer =
++			    kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++			init_timer(pWanTimer);
++
++			pWanTimer->function = wan_led_func;
++			pWanTimer->data = 0;
++			pWanTimer->expires = jiffies + FLICK_TIME;
++			tnetd73xx_gpio_out(2, FALSE);
++			tnetd73xx_gpio_out(3, FALSE);
++			wan_txrx_state = 0;
++			add_timer(pWanTimer);
++
++			break;
++		case 4:	/*no ipaddress */
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
+ 			}
++			tnetd73xx_gpio_out(2, FALSE);
++			tnetd73xx_gpio_out(3, TRUE);
+ 			break;
+-	#endif //for wireless
+ 		default:
++			if (pWanTimer) {
++				del_timer(pWanTimer);
++				kfree(pWanTimer);
++				pWanTimer = NULL;
++			}
+ 			break;
++		}
++		break;
++		//wwzh for wireless 
++#if defined(CONFIG_AR7_VLYNQ)
++	case 4:		/*wlan led */
++		wlan_mod_state = state;
++		switch (state) {
++		case 1:	/* wlan off */
++			if (pWlanTimer) {
++				del_timer(pWlanTimer);
++				kfree(pWlanTimer);
++				pWlanTimer = NULL;
++			}
++			tnetd73xx_gpio_out(12, FALSE);
++			tnetd73xx_gpio_out(13, FALSE);
++			break;
++		case 2:	/* wlan ready */
++			if (pWlanTimer) {
++				del_timer(pWlanTimer);
++				kfree(pWlanTimer);
++				pWlanTimer = NULL;
++			}
++			tnetd73xx_gpio_out(12, TRUE);
++			tnetd73xx_gpio_out(13, FALSE);
++			break;
++		case 3:	/* wlan rx/tx activity */
++			if (pWlanTimer != NULL)
++				break;
++
++			pWlanTimer =
++			    kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++			init_timer(pWlanTimer);
++
++			pWlanTimer->function = wlan_led_func;
++			pWlanTimer->data = 0;
++			pWlanTimer->expires = jiffies + FLICK_TIME;
++			tnetd73xx_gpio_out(12, FALSE);
++			tnetd73xx_gpio_out(13, FALSE);
++			wlan_txrx_state = 0;
++			add_timer(pWlanTimer);
++
++			break;
++		default:
++			if (pWlanTimer) {
++				del_timer(pWlanTimer);
++				kfree(pWlanTimer);
++				pWlanTimer = NULL;
++			}
++
++			break;
++		}
++		break;
++#endif				//for wireless
++	default:
++		break;
+ 	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+ }
+ static ssize_t proc_read_led_fops(struct file *filp,
+-                                 char *buf,size_t count , loff_t *offp)
++				  char *buf, size_t count, loff_t * offp)
+ {
+-	char *pdata = NULL;
+-	int i = 0, j = 0, len = 0, totallen = 0;
++	char *pdata = buf;
++	int i, j, len, totallen = 0;
+ 	char line[255];
+-	
++
++	DPRINTK("%s:%u %s(...,%u,...)\n", __FILE__, __LINE__, __FUNCTION__,
++		count);
++
+ 	if (*offp != 0)
+ 		return 0;
+-	pdata = buf;
++
++	if (count < 4096) {
++		printk("%s might destroy user data (buffer size %u too small\n",
++		       __FUNCTION__, count);
++	}
++
+ 	len = sprintf(line, "USER MODULE INFORMATION:\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+-	
++
+ 	//*******add Module 1 , this Module is ADSL ********/
+-	for (i = 0; i < MAX_MOD_ID; i++)
+-	{
+-		if (modArr[i] != NULL)
+-		{
++	for (i = 0; i < MAX_MOD_ID; i++) {
++		if (modArr[i] != NULL) {
+ 			len = sprintf(line, " Module ID = %d\n", i);
+ 			copy_to_user(pdata, line, len);
+ 			pdata += len;
+ 			totallen += len;
+ 			len = 0;
+-			for(j = 0; j < MAX_STATE_ID; j++)
+-			{
+-				if (modArr[i]->states[j] != NULL)
+-				{
+-					len = sprintf(line, "State =%d, Led = %d,", j, modArr[i]->states[j]->led);
++			for (j = 0; j < MAX_STATE_ID; j++) {
++#if 1				// needed for buggy values
++				if (modArr[i]->states[j] == 0xffffffff) {
++					printk("%s:%u i=%d, j=%d, state=%p\n",
++					       __FILE__, __LINE__, i, j,
++					       modArr[i]->states[j]);
++					continue;
++				}
++				if (modArr[i]->states[j] == 1) {
++					printk("%s:%u i=%d, j=%d, state=%p\n",
++					       __FILE__, __LINE__, i, j,
++					       modArr[i]->states[j]);
++					continue;
++				}
++#endif
++				if (modArr[i]->states[j] != NULL) {
++					len =
++					    sprintf(line,
++						    "State =%d, Led = %d,", j,
++						    modArr[i]->states[j]->led);
+ 					copy_to_user(pdata, line, len);
+ 					pdata += len;
+ 					totallen += len;
+ 					len = 0;
+-					switch(modArr[i]->states[j]->mode)
+-					{
+-					  case 1:
+-				            len = sprintf(line, "Mode = OFF\n");
+-					    break;
+-					  case 2:
+-					    len = sprintf(line, "Mode = BLINK_ON, On Time(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);	
+-					    break;
+-					  case 3:
+-					    len = sprintf(line, "Mode = BLINK_OFF, Off Time(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);
+-					    break;
+-					  case 4:
+-					    len = sprintf(line, "Mode = On\n");
+-					    break;
+-					  case 5:
+-					    len = sprintf(line, "Mode = FLASH, Time Period(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);
+-					    break;
+-					  default:
+-					    break;		
++					switch (modArr[i]->states[j]->mode) {
++					case 1:
++						len =
++						    sprintf(line,
++							    "Mode = OFF\n");
++						break;
++					case 2:
++						len =
++						    sprintf(line,
++							    "Mode = BLINK_ON, On Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 3:
++						len =
++						    sprintf(line,
++							    "Mode = BLINK_OFF, Off Time(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					case 4:
++						len =
++						    sprintf(line,
++							    "Mode = On\n");
++						break;
++					case 5:
++						len =
++						    sprintf(line,
++							    "Mode = FLASH, Time Period(ms) = %d\n",
++							    (unsigned int)
++							    modArr[i]->
++							    states[j]->param);
++						break;
++					default:
++						len =
++						    sprintf(line, "Mode = %u\n",
++							    modArr[i]->
++							    states[j]->mode);
++						break;
+ 					}
+ 					copy_to_user(pdata, line, len);
+ 					pdata += len;
+ 					totallen += len;
+ 					len = 0;
+ 				}
+-			} 
++			}
+ 		}
+ 
+ 	}
+@@ -745,87 +772,84 @@
+ 	pdata += len;
+ 	totallen += len;
+ 	len = 0;
+-	switch(sys_mod_state)
+-	{
+-		case 1:
+-			len = sprintf(line, "State = OFF\n");
+-			break;
+-		case 2:	
+-			len = sprintf(line, "State = Booting\n");
+-			break;
+-		case 3:
+-			len = sprintf(line, "State = System Ready\n");
+-			break;
+-		case 4:
+-			len = sprintf(line, "State = System Failure\n");
+-			break;
+-		default:
+-			break;
++	switch (sys_mod_state) {
++	case 1:
++		len = sprintf(line, "State = OFF\n");
++		break;
++	case 2:
++		len = sprintf(line, "State = Booting\n");
++		break;
++	case 3:
++		len = sprintf(line, "State = System Ready\n");
++		break;
++	case 4:
++		len = sprintf(line, "State = System Failure\n");
++		break;
++	default:
++		len = sprintf(line, "State = %u\n", sys_mod_state);
++		break;
+ 	}
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+-	
++
+ 	len = sprintf(line, "Module ID = 3(WAN led)\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+ 	len = 0;
+-	switch(wan_mod_state)
+-	{
+-		case 1:
+-			len = sprintf(line, "State = OFF\n");
+-			break;
+-		case 2:
+-			len = sprintf(line, "State = Wan Connected\n");
+-			break;
+-		case 3:
+-			len = sprintf(line, "State = Wan Tx/Rx Activity\n");
+-			break;
+-		case 4:
+-			len = sprintf(line, "State = Wan Connect Failure\n");
+-			break;
+-		default:
+-			break;
++	switch (wan_mod_state) {
++	case 1:
++		len = sprintf(line, "State = OFF\n");
++		break;
++	case 2:
++		len = sprintf(line, "State = Wan Connected\n");
++		break;
++	case 3:
++		len = sprintf(line, "State = Wan Tx/Rx Activity\n");
++		break;
++	case 4:
++		len = sprintf(line, "State = Wan Connect Failure\n");
++		break;
++	default:
++		len = sprintf(line, "State = %u\n", wan_mod_state);
++		break;
+ 	}
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+ 
+ //wwzh for wireless
+-#if 0
++#if defined(CONFIG_AR7_VLYNQ)
+ 	len = sprintf(line, "Module ID = 4(WLAN led)\n");
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+ 	len = 0;
+-	switch(wlan_mod_state)
+-	{
+-		case 1:
+-			len = sprintf(line, "State = OFF\n");
+-			break;
+-		case 2:
+-			len = sprintf(line, "State = wlan Ready\n");
+-			break;
+-		case 3:
+-			len = sprintf(line, "State = wlan rx/tx activity\n");
+-			break;
+-		default:
+-			break; 
++	switch (wlan_mod_state) {
++	case 1:
++		len = sprintf(line, "State = OFF\n");
++		break;
++	case 2:
++		len = sprintf(line, "State = wlan Ready\n");
++		break;
++	case 3:
++		len = sprintf(line, "State = wlan rx/tx activity\n");
++		break;
++	default:
++		len = sprintf(line, "State = %u\n", wlan_mod_state);
++		break;
+ 	}
+ 	copy_to_user(pdata, line, len);
+ 	pdata += len;
+ 	totallen += len;
+-	len = 0;
+-#endif //for wireless
+-	
++#endif				//for wireless
++
+ 	*offp = totallen;
+ 	return totallen;
+ }
+-static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+-                                               size_t count , loff_t *offp)
++static ssize_t proc_write_led_fops(struct file *filp, const char *buffer,
++				   size_t count, loff_t * offp)
+ {
+ 	char *pdata = NULL, *ptemp = NULL;
+ 	char line[10], temp[10];
+@@ -833,17 +857,15 @@
+ 	int mod = 0xffff, state = 0xffff;
+ 	int flag = 0;
+ 
+- 	 /* Check if this write is for configuring ADSL */
+-  	if( *(int *)(buffer) == 0xFFEEDDCC )
+-	{
+-   		 printk("<1>proc write:Calling Configuration\n");
+-		 config_led((unsigned long)(buffer + sizeof(int)) );
+-		 return count;
++	/* Check if this write is for configuring ADSL */
++	if (*(int *)(buffer) == 0xFFEEDDCC) {
++		printk("<1>proc write:Calling Configuration\n");
++		config_led((unsigned long)(buffer + sizeof(int)));
++		return count;
+ 	}
+ 
+-	if (count > 10)
+-	{
+-		printk("<1> proc write: Input too long, max length = 10\n");
++	if (count > 9) {
++		printk("<1> proc write: Input too long, max length = 9\n");
+ 		return count;
+ 	}
+ 	memset(temp, 0x00, 10);
+@@ -851,19 +873,15 @@
+ 	copy_from_user(line, buffer, count);
+ 	line[count] = 0x00;
+ 	pdata = line;
+-	ptemp = temp;	
+-	
+-	while (flag == 0)
+-	{
++	ptemp = temp;
++
++	while (flag == 0) {
+ 		if (i > 10)
+ 			break;
+-		if (((*pdata) >= '0') && ((*pdata) <= '9'))
+-		{
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
+ 			*ptemp = *pdata;
+ 			ptemp++;
+-		}
+-		else if ((*pdata) == ',')
+-		{
++		} else if ((*pdata) == ',') {
+ 			*ptemp = 0x00;
+ 			flag = 1;
+ 		}
+@@ -874,22 +892,17 @@
+ 		mod = led_atoi(temp);
+ 	else
+ 		return count;
+-	
++
+ 	ptemp = temp;
+-	*ptemp = 0x00;
+ 	flag = 0;
+-	
+-	while(flag == 0)
+-	{
++
++	while (flag == 0) {
+ 		if (i > 10)
+ 			break;
+-		if (((*pdata) >= '0') && ((*pdata) <= '9'))
+-		{
++		if (((*pdata) >= '0') && ((*pdata) <= '9')) {
+ 			*ptemp = *pdata;
+ 			ptemp++;
+-		}
+-		else if ((*pdata) == 0x00)
+-		{
++		} else if ((*pdata) == 0x00) {
+ 			*ptemp = 0x00;
+ 			flag = 1;
+ 		}
+@@ -902,164 +915,163 @@
+ 		return count;
+ 	if ((mod == 0xFFFF) || (state == 0xFFFF))
+ 		return count;
+-	else
+-	{
++	else {
+ 		if (mod != 4)
+-			led_active(mod, state);	
+-		else 
++			led_active(mod, state);
++		else
+ 			led_operation(mod, state);
+-	} 
++	}
+ 	return 1;
+ }
+ #endif
+ /************end *******************/
+ static int config_led(unsigned long y)
+ {
+-  config_elem_t *pcfg = NULL;
+-  char *pdata = NULL;
+-  int i;
+-  int length = 0 , number = 0;
++	config_elem_t *pcfg = NULL;
++	char *pdata = NULL;
++	int i;
++	int length = 0, number = 0;
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+-    /* ioctl to configure */
+-    length =  *((int*)y);
+-    pdata = (char *)y + sizeof(int);
+-    number =  (length - sizeof(int))/sizeof(config_elem_t);
+-    pcfg = (config_elem_t *)(pdata);
+-
+-    /* Check if an earlier configuration exists IF yes free it up */
+-    free_memory();
+-
+-    for ( i = 0 ; i < number ; i++ )
+-    {
+-			/* If no structure has been allocated for the module do so */
+-      if ( modArr[pcfg->name] == NULL )
+-			{
+-					printk("<1>module =  %d\n",pcfg->name);
+-        if( pcfg->name >= MAX_MOD_ID)
+-				{
+-					printk("<1>Exiting Configuration: Module ID too large %d\n",pcfg->name);
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-        modArr[pcfg->name] = kmalloc(sizeof(mod_entry_t),GFP_KERNEL);
+-        if(modArr[pcfg->name] == NULL)
+-				{
+-					printk("<1>Exiting Configuration: Error in allocating memory\n");
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-				memset( modArr[pcfg->name], 0x00, sizeof(mod_entry_t));
++	/* ioctl to configure */
++	length = *((int *)y);
++	pdata = (char *)y + sizeof(int);
++	number = (length - sizeof(int)) / sizeof(config_elem_t);
++	pcfg = (config_elem_t *) (pdata);
++
++	/* Check if an earlier configuration exists IF yes free it up */
++	free_memory();
++
++	for (i = 0; i < number; i++) {
++		/* If no structure has been allocated for the module do so */
++		if (modArr[pcfg->name] == NULL) {
++			printk("<1>module =  %d\n", pcfg->name);
++			if (pcfg->name >= MAX_MOD_ID) {
++				printk
++				    ("<1>Exiting Configuration: Module ID too large %d\n",
++				     pcfg->name);
++				free_memory();
++				spin_unlock_irqrestore(&config_lock, flags);
++				return -1;
+ 			}
+-
+-      /* if no structure is allocated previously for this state
+-         allocate a structure, if it's already there fill it up */
+-			if( modArr[pcfg->name]->states[pcfg->state] == NULL)
+-			{
+-					printk("<1>STATE =  %d\n",pcfg->state);
+-				if( pcfg->state >= MAX_STATE_ID)
+-				{
+-					printk("<1>Exiting Configuration: State ID too large\n");
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-				modArr[pcfg->name]->states[pcfg->state] =
+-                        kmalloc(sizeof(state_entry_t),GFP_KERNEL);
+-				if( modArr[pcfg->name]->states[pcfg->state] == NULL)
+-				{
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
+-				}
+-				memset( modArr[pcfg->name]->states[pcfg->state], 0x00, sizeof(state_entry_t));
++			modArr[pcfg->name] =
++			    kmalloc(sizeof(mod_entry_t), GFP_KERNEL);
++			if (modArr[pcfg->name] == NULL) {
++				printk
++				    ("<1>Exiting Configuration: Error in allocating memory\n");
++				free_memory();
++				spin_unlock_irqrestore(&config_lock, flags);
++				return -1;
+ 			}
+-			/* Fill up the fields of the state */
+-      if( pcfg->led >= MAX_LED_ID)
+-			{
+-				printk("<1>led =  %d\n",pcfg->led);
++			memset(modArr[pcfg->name], 0x00, sizeof(mod_entry_t));
++		}
++
++		/* if no structure is allocated previously for this state
++		   allocate a structure, if it's already there fill it up */
++		if (modArr[pcfg->name]->states[pcfg->state] == NULL) {
++			printk("<1>STATE =  %d\n", pcfg->state);
++			if (pcfg->state >= MAX_STATE_ID) {
++				printk
++				    ("<1>Exiting Configuration: State ID too large\n");
+ 				free_memory();
+ 				spin_unlock_irqrestore(&config_lock, flags);
+ 				return -1;
+ 			}
+-      modArr[pcfg->name]->states[pcfg->state]->led = pcfg->led;
+-      modArr[pcfg->name]->states[pcfg->state]->mode = pcfg->mode;
+-      modArr[pcfg->name]->states[pcfg->state]->param = pcfg->param;
+-			switch(pcfg->mode)
+-			{
+-				case 1:
+-      		modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_down;
+-					break;
+-				case 2:
+-				case 3:
+-				case 5:
+-					if( pcfg->mode == 2 )
+-						modArr[pcfg->name]->states[pcfg->state]->handler = board_led_activity_on;
+-					else if( pcfg->mode == 3)
+-      			modArr[pcfg->name]->states[pcfg->state]->handler = board_led_activity_off;
+-					else
+-		        modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_flash;
+-					break;
+-				case 4:
+-      		modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_up;
+-					break;
+-				default:
+-				  printk("<1>Exiting Configuration: Unknown LED Mode\n");
+-					free_memory();
+-					spin_unlock_irqrestore(&config_lock, flags);
+-					return -1;
++			modArr[pcfg->name]->states[pcfg->state] =
++			    kmalloc(sizeof(state_entry_t), GFP_KERNEL);
++			if (modArr[pcfg->name]->states[pcfg->state] == NULL) {
++				free_memory();
++				spin_unlock_irqrestore(&config_lock, flags);
++				return -1;
+ 			}
+-			pcfg++;			
+-    }
++			memset(modArr[pcfg->name]->states[pcfg->state], 0x00,
++			       sizeof(state_entry_t));
++		}
++		/* Fill up the fields of the state */
++		if (pcfg->led >= MAX_LED_ID) {
++			printk("<1>led =  %d\n", pcfg->led);
++			free_memory();
++			spin_unlock_irqrestore(&config_lock, flags);
++			return -1;
++		}
++		modArr[pcfg->name]->states[pcfg->state]->led = pcfg->led;
++		modArr[pcfg->name]->states[pcfg->state]->mode = pcfg->mode;
++		modArr[pcfg->name]->states[pcfg->state]->param = pcfg->param;
++		switch (pcfg->mode) {
++		case 1:
++			modArr[pcfg->name]->states[pcfg->state]->handler =
++			    board_led_link_down;
++			break;
++		case 2:
++		case 3:
++		case 5:
++			if (pcfg->mode == 2)
++				modArr[pcfg->name]->states[pcfg->state]->
++				    handler = board_led_activity_on;
++			else if (pcfg->mode == 3)
++				modArr[pcfg->name]->states[pcfg->state]->
++				    handler = board_led_activity_off;
++			else
++				modArr[pcfg->name]->states[pcfg->state]->
++				    handler = board_led_link_flash;
++			break;
++		case 4:
++			modArr[pcfg->name]->states[pcfg->state]->handler =
++			    board_led_link_up;
++			break;
++		default:
++			printk("<1>Exiting Configuration: Unknown LED Mode\n");
++			free_memory();
++			spin_unlock_irqrestore(&config_lock, flags);
++			return -1;
++		}
++		pcfg++;
++	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+-  return 0;
++	return 0;
+ }
+ 
+-
+ int __init led_init(void)
+ {
+ 
+-  /* Clear our memory */
+-  memset(modArr,0x00,sizeof(mod_entry_t *)*MAX_MOD_ID);
+-  memset(led_arr,0x00,sizeof(led_data_t *)*MAX_LED_ID);
++	/* Clear our memory */
++	memset(modArr, 0x00, sizeof(mod_entry_t *) * MAX_MOD_ID);
++	memset(led_arr, 0x00, sizeof(led_data_t *) * MAX_LED_ID);
+ 
+ 	/* Create spin lock for config data structure */
+-	config_lock=SPIN_LOCK_UNLOCKED;
++	config_lock = SPIN_LOCK_UNLOCKED;
+ 
+-  /* Create directory */
+-  led_proc_dir = proc_mkdir("led", NULL);
+-  if( led_proc_dir == NULL )
+-    goto out;
+-
+-  /* Create adsl file */
+-  led_file = create_proc_entry("led", 0777, led_proc_dir);
+-  if( led_file == NULL)
+-    goto led_file;
+-  led_file->owner = THIS_MODULE;
+-  led_file->proc_fops = &led_fops;
++	/* Create directory */
++	led_proc_dir = proc_mkdir("led", NULL);
++	if (led_proc_dir == NULL)
++		goto out;
++
++	/* Create adsl file */
++	led_file = create_proc_entry("led", 0777, led_proc_dir);
++	if (led_file == NULL)
++		goto led_file;
++	led_file->owner = THIS_MODULE;
++	led_file->proc_fops = &led_fops;
+ 
+-  memset( modArr , 0x00 , sizeof(mod_entry_t *) * MAX_MOD_ID);
+ 	/* Reset the GPIO pins  */
+-  board_gpio_init();
++	board_gpio_init();
+ 
+ 	/* Register the UART controlled LEDS  */
+-  uart_led_init();
+-  /* Create the usb proc file */
++	uart_led_init();
++	/* Create the usb proc file */
+ 	avalanche_leds_init();
+-  return 0;
++	return 0;
+ 
+-  led_file:
+-    remove_proc_entry("led",led_proc_dir);
+-  out:
+-    return 0;
++      led_file:
++	remove_proc_entry("led", led_proc_dir);
++      out:
++	return 0;
+ 
+ }
+ 
+-void led_exit()
++void led_exit(void)
+ {
+ 	remove_proc_entry("led", led_proc_dir);
+ }
+@@ -1067,7 +1079,7 @@
+ module_init(led_init);
+ module_exit(led_exit);
+ 
+-void register_led_drv( int device , led_reg_t *pInfo)
++void register_led_drv(int device, led_reg_t * pInfo)
+ {
+ 	unsigned int flags;
+ 	struct timer_list *pTimer = NULL;
+@@ -1075,42 +1087,40 @@
+ 	spin_lock_irqsave(&config_lock, flags);
+ 
+ 	led_arr[device].led = pInfo;
+-	if( led_arr[device].led->init != 0x00)
+-      led_arr[device].led->init(led_arr[device].led->param);
+-	if( led_arr[device].led->offfunc != 0x00)
+-      led_arr[device].led->offfunc(led_arr[device].led->param);
++	if (led_arr[device].led->init != 0x00)
++		led_arr[device].led->init(led_arr[device].led->param);
++	if (led_arr[device].led->offfunc != 0x00)
++		led_arr[device].led->offfunc(led_arr[device].led->param);
+ 
+ 	/* Create a timer for blinking   */
+-  pTimer = kmalloc(sizeof(struct timer_list),GFP_KERNEL);
+-	init_timer( pTimer );
++	pTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++	init_timer(pTimer);
+ 	pTimer->function = led_timer_func;
+ 	pTimer->data = 0;
+-  led_arr[device].pTimer = pTimer;
+-  led_arr[device].timer_running = 0;
++	led_arr[device].pTimer = pTimer;
++	led_arr[device].timer_running = 0;
+ 
+ 	spin_unlock_irqrestore(&config_lock, flags);
+ 
+-  return;
++	return;
+ }
+ 
+-void deregister_led_drv( int device)
++void deregister_led_drv(int device)
+ {
+ 	unsigned int flags;
+ 
+ 	spin_lock_irqsave(&config_lock, flags);
+ 	led_arr[device].led = NULL;
+ 
+-	if( led_arr[device].pTimer != NULL)
+-	{
++	if (led_arr[device].pTimer != NULL) {
+ 		del_timer(led_arr[device].pTimer);
+ 		kfree(led_arr[device].pTimer);
+ 	}
+ 	spin_unlock_irqrestore(&config_lock, flags);
+ 
+-  return;
++	return;
+ }
+ 
+ EXPORT_SYMBOL_NOVERS(led_operation);
+ EXPORT_SYMBOL_NOVERS(register_led_drv);
+ EXPORT_SYMBOL_NOVERS(deregister_led_drv);
+-
+diff -urN linux-2.4.32/drivers/char/avalanche_led/leds.c linux-2.4.32.new/drivers/char/avalanche_led/leds.c
+--- linux-2.4.32/drivers/char/avalanche_led/leds.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/leds.c	2005-12-27 21:44:16.000000000 +0100
+@@ -12,6 +12,41 @@
+ 
+ #include <asm/ar7/ledapp.h>
+ 
++#include "led.h"
++
++#if defined(CONFIG_AR7_LED)
++
++#include <asm/ar7/led_hal.h>	/* avalanche_led_action, ... */
++
++void avalanche_led_action(void *handle, int state_id)
++{
++	static unsigned counter;
++	if (counter++ < 10) {
++		printk("%s(%s,%d)\n", __FUNCTION__, (const char *)handle, state_id);
++		if (counter == 10) {
++			printk("%s log output disabled\n", __FUNCTION__);
++		}
++	}
++}
++
++void *avalanche_led_register(const char *module_name, int instance_num)
++{
++	printk("%s(%s,%d)\n", __FUNCTION__, module_name, instance_num);
++	return (void *)module_name;
++}
++
++int avalanche_led_unregister(void *handle)
++{
++	printk("%s(%s)\n", __FUNCTION__, (const char *)handle);
++	return 0;
++}
++
++EXPORT_SYMBOL(avalanche_led_action);
++EXPORT_SYMBOL(avalanche_led_register);
++EXPORT_SYMBOL(avalanche_led_unregister);
++
++#endif
++
+ #if defined(CONFIG_AR5D01) || defined(CONFIG_AR5W01) || defined(CONFIG_AR7)
+ 
+ #define ETH_MASK 0x01
+@@ -103,6 +138,8 @@
+ 
+ void avalanche_leds_init(void)
+ {
++  proc_mkdir("avalanche", NULL);
++
+   /* Create usb link proc file */
+   usb_file = create_proc_entry("avalanche/usb_link", 0444, NULL);
+   if( usb_file == NULL)
+@@ -126,8 +163,3 @@
+ }
+ 
+ #endif
+-
+-
+-
+-
+-
+diff -urN linux-2.4.32/drivers/char/avalanche_led/Makefile linux-2.4.32.new/drivers/char/avalanche_led/Makefile
+--- linux-2.4.32/drivers/char/avalanche_led/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -3,21 +3,11 @@
+ # Makefile for the Linux LED device driver.
+ #
+ 
+-
+ O_TARGET := avalanche_led.o
+-obj-m := avalanche_led.o
+-list-multi      := avalanche_led.o
++obj-$(CONFIG_AR7_LED) := ledmod.o gpio.o uartled.o leds.o
+ 
+ EXTRA_CFLAGS := -I$(TOPDIR)/include/asm/ar7
+ 
+ export-objs := ledmod.o leds.o
+ 
+-avalanche_led-objs := ledmod.o gpio.o uartled.o leds.o
+-
+ include $(TOPDIR)/Rules.make
+-
+-avalanche_led.o:      $(avalanche_led-objs)
+-	$(LD) -r -o $@ $(avalanche_led-objs)
+-
+-clean:
+-	rm -f core *.o *.a *.s
+diff -urN linux-2.4.32/drivers/char/avalanche_led/uartled.c linux-2.4.32.new/drivers/char/avalanche_led/uartled.c
+--- linux-2.4.32/drivers/char/avalanche_led/uartled.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_led/uartled.c	2005-12-27 21:44:16.000000000 +0100
+@@ -9,6 +9,7 @@
+ static spinlock_t	device_lock;
+ led_reg_t temp1[2];
+ 
++#if defined(CONFIG_AR5D01) || defined(CONFIG_AR5W01)
+ static void uart_led_on(unsigned long param)
+ {
+   unsigned long flags;
+@@ -25,6 +26,7 @@
+    UART_LED_REG |= 0x02;
+ 	spin_unlock_irqrestore(&device_lock, flags);
+ }
++#endif
+ 
+ void uart_led_init(void)
+ {
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_board.c linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_board.c
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_board.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_board.c	2005-12-27 21:44:16.000000000 +0100
+@@ -21,15 +21,16 @@
+ #include <linux/module.h>
+ #include <asm/ar7/sangam.h>  
+ #include <asm/ar7/avalanche_misc.h>  
+-#include <asm/ar7/vlynq.h>  
++#include <asm/ar7/vlynq_hal.h>  
+    
++#include "vlynq_drv.h"
++
+ #define SYS_VLYNQ_LOCAL_INTERRUPT_VECTOR	30 	/* MSB - 1 bit */
+ #define SYS_VLYNQ_REMOTE_INTERRUPT_VECTOR	31 	/* MSB bit */
+ #define SYS_VLYNQ_OPTIONS 		        0x7F; 	/* all options*/
+ 
+ /* These defines are board specific */
+ 
+-
+ #define VLYNQ0_REMOTE_WINDOW1_OFFSET           (0x0C000000)
+ #define VLYNQ0_REMOTE_WINDOW1_SIZE             (0x500)
+ 
+@@ -38,12 +39,11 @@
+ #define VLYNQ1_REMOTE_WINDOW1_SIZE             (0x500)
+ 
+ 
+-extern VLYNQ_DEV vlynqDevice0, vlynqDevice1;
+ int    vlynq_init_status[2] = {0, 0};
+ EXPORT_SYMBOL(vlynq_init_status);
+ static int reset_hack = 1;
+ 
+-void vlynq_ar7wrd_dev_init()
++void vlynq_ar7wrd_dev_init(void)
+ {
+     *(unsigned long*) AVALANCHE_GPIO_ENBL    |= (1<<18);
+     vlynq_delay(20000);
+@@ -148,6 +148,9 @@
+ void remote_vlynq_dev_reset_ctrl(unsigned int module_reset_bit,
+                                  AVALANCHE_RESET_CTRL_T reset_ctrl)
+ {
++    printk("%s:%u %s(%u,%u)\n", __FILE__, __LINE__, __FUNCTION__,
++	module_reset_bit, reset_ctrl);
++
+     if(module_reset_bit >= 32)
+         return;
+ 
+@@ -182,3 +185,52 @@
+     }
+ }
+ 
++void vlynq_set_function_pointers(void) {
++#if 0
++        p_vlynq_interrupt_vector_set    = (p_vlynq_interrupt_vector_set_t) vlynq_interrupt_vector_set;
++        p_vlynq_interrupt_vector_cntl   = (p_vlynq_interrupt_vector_cntl_t) vlynq_interrupt_vector_cntl;
++        p_vlynq_interrupt_get_count     = (p_vlynq_interrupt_get_count_t) vlynq_interrupt_get_count;
++        p_vlynq_install_isr             = (p_vlynq_install_isr_t) vlynq_install_isr;
++        p_vlynq_uninstall_isr           = (p_vlynq_uninstall_isr_t) vlynq_uninstall_isr;
++        p_vlynq_root_isr                = (p_vlynq_root_isr_t) vlynq_root_isr;
++        p_vlynq_delay                   = (p_vlynq_delay_t) vlynq_delay;
++        p_vlynq_interrupt_vector_map    = (p_vlynq_interrupt_vector_map_t) vlynq_interrupt_vector_map;
++        p_vlynq_interrupt_set_polarity  = (p_vlynq_interrupt_set_polarity_t) vlynq_interrupt_set_polarity;
++        p_vlynq_interrupt_get_polarity  = (p_vlynq_interrupt_get_polarity_t) vlynq_interrupt_get_polarity;
++        p_vlynq_interrupt_set_type      = (p_vlynq_interrupt_set_type_t) vlynq_interrupt_set_type;
++        p_vlynq_interrupt_get_type      = (p_vlynq_interrupt_get_type_t) vlynq_interrupt_get_type;
++        p_vlynq_interrupt_enable        = (p_vlynq_interrupt_enable_t) vlynq_interrupt_enable;
++        p_vlynq_interrupt_disable       = (p_vlynq_interrupt_disable_t) vlynq_interrupt_disable;
++#endif
++        p_remote_vlynq_dev_reset_ctrl   = remote_vlynq_dev_reset_ctrl;
++
++#if 0
++        p_vlynqDevice0 = &vlynqDevice0;
++        p_vlynqDevice1 = &vlynqDevice1;
++#endif
++}
++
++void vlynq_clear_function_pointers(void) {
++#if 0
++        p_vlynq_interrupt_vector_set    = NULL;
++        p_vlynq_interrupt_vector_cntl   = NULL;
++        p_vlynq_interrupt_get_count     = NULL;
++        p_vlynq_install_isr             = NULL;
++        p_vlynq_uninstall_isr           = NULL;
++        p_vlynq_root_isr                = NULL;
++        p_vlynq_delay                   = NULL;
++        p_vlynq_interrupt_vector_map    = NULL;
++        p_vlynq_interrupt_set_polarity  = NULL;
++        p_vlynq_interrupt_get_polarity  = NULL;
++        p_vlynq_interrupt_set_type      = NULL;
++        p_vlynq_interrupt_get_type      = NULL;
++        p_vlynq_interrupt_enable        = NULL;
++        p_vlynq_interrupt_disable       = NULL;
++#endif
++        p_remote_vlynq_dev_reset_ctrl   = NULL;
++
++#if 0
++        p_vlynqDevice0 = NULL;
++        p_vlynqDevice1 = NULL;
++#endif
++}
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.c linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.c
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.c	2005-12-27 21:44:16.000000000 +0100
+@@ -26,22 +26,23 @@
+ #include <linux/capability.h>
+ #include <asm/ar7/avalanche_intc.h>
+ #include <asm/ar7/sangam.h>
+-#include <asm/ar7/vlynq.h>
++#include <asm/ar7/vlynq_hal.h>
+ 
++#include "vlynq_drv.h"
+ 
+ #define    TI_VLYNQ_VERSION                 "0.2"
+ 
+-/* debug on ? */
+-#define VLYNQ_DEBUG 
++/* debug on? Macro is set in vlynq.h. */
++/* #define VLYNQ_DEBUG */
+ 
+ /* Macro for debug and error printf's */
+ #ifdef VLYNQ_DEBUG
+-#define DBGPRINT  printk
++# define DBGPRINT(format, args...) printk(format, ## args)
+ #else
+-#define DBGPRINT(x)  
++# define DBGPRINT(format, args...)  
+ #endif
+ 
+-#define ERRPRINT  printk
++#define ERRPRINT(format, args...) printk(format, ##args)
+ 
+ /* Define the max vlynq ports this driver will support. 
+    Device name strings are statically added here */
+@@ -54,8 +55,6 @@
+     VLYNQ_DEV *vlynqDevice;
+ }VLYNQ_PRIV;
+ 
+-extern int vlynq_init_status[2];
+-
+ /* Extern Global variable for vlynq devices used in initialization of the vlynq device
+  * These variables need to be populated/initialized by the system as part of initialization
+  * process. The vlynq enumerator can run at initialization and populate these globals
+@@ -80,8 +79,6 @@
+     { LNXINTNUM(AVALANCHE_HIGH_VLYNQ_INT),&vlynqDevice1},
+ };
+ 
+-extern void vlynq_dev_init(void);
+-
+ 
+ /* =================================== all the operations */
+ 
+@@ -139,10 +136,9 @@
+ static int                                                                                     
+ vlynq_read_ver_proc(char *buf, char **start, off_t offset, int count, int *eof, void *data)        
+ {                                                                                              
+-	int instance;                                                                              
+-	int len=0;                                                                                 
+-                                                                                               
+-	len += sprintf(buf +len,"\nTI Linux VLYNQ Driver Version %s\n",TI_VLYNQ_VERSION);         
++	int len;
++	// may cause buffer overflow!!!
++	len = sprintf(buf, "\nTI Linux VLYNQ Driver Version %s\n", TI_VLYNQ_VERSION);
+ 	return len;                                                                                
+ }                                                                                              
+ 
+@@ -162,7 +158,10 @@
+     int ret;
+     int unit = 0;
+     int instance_count = CONFIG_AR7_VLYNQ_PORTS;
+-    volatile int *ptr;
++
++    vlynq_set_function_pointers();
++    memset(&vlynqDevice0, 0, sizeof (VLYNQ_DEV));
++    memset(&vlynqDevice1, 0, sizeof (VLYNQ_DEV));
+ 
+     vlynq_dev_init();
+ 
+@@ -171,6 +170,7 @@
+     if (instance_count > MAX_VLYNQ_PORTS)
+     {
+         ERRPRINT("ERROR: vlynq_init_module(): Max %d supported\n", MAX_VLYNQ_PORTS);
++        vlynq_clear_function_pointers();
+         return (-1);
+     }
+ 
+@@ -184,16 +184,16 @@
+             ERRPRINT("ERROR:Could not register vlynq device:%d\n",unit);
+             continue;
+         }
+-        else 
+-            DBGPRINT("Vlynq Device %s registered with minor no %d as misc device. Result=%d\n", 
++	DBGPRINT("Vlynq Device %s registered with minor no %d as misc device. Result=%d\n", 
+                 vlynq_dev[unit].name, vlynq_dev[unit].minor, ret);
+-#if 0
+             
+-        DBGPRINT("Calling vlynq init\n");
++        if(vlynq_init_status[unit] == 0)
++	{
++		DBGPRINT("Calling vlynq init\n");
+ 
+-        /* Read the global variable for VLYNQ device structure and initialize vlynq driver */
+-        ret = vlynq_init(vlynq_priv[unit].vlynqDevice,VLYNQ_INIT_PERFORM_ALL );
+-#endif
++		/* Read the global variable for VLYNQ device structure and initialize vlynq driver */
++		ret = vlynq_init(vlynq_priv[unit].vlynqDevice,VLYNQ_INIT_PERFORM_ALL );
++	}
+ 
+         if(vlynq_init_status[unit] == 0)
+         {
+@@ -215,7 +215,6 @@
+         } 
+     }
+ 
+-    proc_mkdir("avalanche", NULL);
+     /* Creating proc entry for the devices */
+     create_proc_read_entry("avalanche/vlynq_link", 0, NULL, vlynq_read_link_proc, NULL);
+     create_proc_read_entry("avalanche/vlynq_ver", 0, NULL, vlynq_read_ver_proc, NULL);
+@@ -227,6 +226,8 @@
+ {
+     int unit = 0;
+     
++    vlynq_clear_function_pointers();
++
+     for (unit = 0; unit < CONFIG_AR7_VLYNQ_PORTS; unit++)
+     {
+         DBGPRINT("vlynq_cleanup_module(): Unregistring misc device %s\n",vlynq_dev[unit].name);
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.h linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.h
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_drv.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_drv.h	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,10 @@
++/* 
++ */
++
++extern void vlynq_set_function_pointers(void);
++extern void vlynq_clear_function_pointers(void);
++
++/* vlynq_board.h */
++extern int vlynq_init_status[2];
++extern void vlynq_dev_init(void);
++
+diff -urN linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_hal.c linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_hal.c
+--- linux-2.4.32/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-12-29 11:23:34.000000000 +0100
++++ linux-2.4.32.new/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-12-27 21:44:16.000000000 +0100
+@@ -36,7 +36,8 @@
+ 
+ #include <linux/stddef.h>
+ #include <linux/types.h>
+-#include <asm/ar7/vlynq.h>
++#include <linux/kernel_stat.h> /* kstat */
++#include <asm/ar7/vlynq_hal.h>
+ 
+ /**** Local Function prototypes *******/
+ static int vlynqInterruptInit(VLYNQ_DEV *pdev);
+@@ -128,7 +129,7 @@
+ int vlynq_init(VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options)
+ {
+     unsigned int map;
+-    unsigned int val=0,cnt,tmp;
++    unsigned int val = 0, tmp;
+     unsigned int counter=0;
+     VLYNQ_INTERRUPT_CNTRL *intSetting=NULL;
+ 
+@@ -538,7 +539,8 @@
+                 {
+                     pdev->isrCount++;   /* update isr invocation count */    
+                     /* Call the user ISR and update the count for ISR */
+-		    entry->isrCount++;   
++		    entry->isrCount++;
++		    kstat.irqs[0][80]++;
+                     entry->isr(entry->arg1, entry->arg2, entry->arg3);
+                     if (entry->next == NULL) break;
+                     entry = entry->next;
+diff -urN linux-2.4.32/drivers/char/Makefile linux-2.4.32.new/drivers/char/Makefile
+--- linux-2.4.32/drivers/char/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/char/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -191,7 +191,7 @@
+ endif
+ 
+ #
+-# Texas Intruments LED driver
++# Texas Instruments LED driver
+ # 
+ obj-$(CONFIG_AR7_LED) += avalanche_led/avalanche_led.o
+ subdir-$(CONFIG_AR7_LED) += avalanche_led
+diff -urN linux-2.4.32/drivers/mtd/maps/ar7-flash.c linux-2.4.32.new/drivers/mtd/maps/ar7-flash.c
+--- linux-2.4.32/drivers/mtd/maps/ar7-flash.c	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/mtd/maps/ar7-flash.c	2005-12-27 21:44:16.000000000 +0100
+@@ -21,58 +21,55 @@
+ #include <asm/mips-boards/prom.h>
+ extern char *prom_getenv(char *name);
+ 
+-static int create_mtd_partitions(void);
+-static void __exit ar7_mtd_cleanup(void);
+-	
+ #define MAX_NUM_PARTITIONS 5
+ static struct mtd_partition ar7_partinfo[MAX_NUM_PARTITIONS];
+ 
+ static struct mtd_info *ar7_mtd_info;
+ 
+-__u8 ar7_read8(struct map_info *map, unsigned long ofs)
++static __u8 ar7_read8(struct map_info *map, unsigned long ofs)
+ {
+ 	return __raw_readb(map->map_priv_1 + ofs);
+ }
+ 
+-__u16 ar7_read16(struct map_info *map, unsigned long ofs)
++static __u16 ar7_read16(struct map_info *map, unsigned long ofs)
+ {
+ 	return __raw_readw(map->map_priv_1 + ofs);
+ }
+ 
+-__u32 ar7_read32(struct map_info *map, unsigned long ofs)
++static __u32 ar7_read32(struct map_info *map, unsigned long ofs)
+ {
+ 	return __raw_readl(map->map_priv_1 + ofs);
+ }
+ 
+-void ar7_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
++static void ar7_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+ {
+ 	memcpy_fromio(to, map->map_priv_1 + from, len);
+ }
+ 
+-void ar7_write8(struct map_info *map, __u8 d, unsigned long adr)
++static void ar7_write8(struct map_info *map, __u8 d, unsigned long adr)
+ {
+ 	__raw_writeb(d, map->map_priv_1 + adr);
+ 	mb();
+ }
+ 
+-void ar7_write16(struct map_info *map, __u16 d, unsigned long adr)
++static void ar7_write16(struct map_info *map, __u16 d, unsigned long adr)
+ {
+ 	__raw_writew(d, map->map_priv_1 + adr);
+ 	mb();
+ }
+ 
+-void ar7_write32(struct map_info *map, __u32 d, unsigned long adr)
++static void ar7_write32(struct map_info *map, __u32 d, unsigned long adr)
+ {
+ 	__raw_writel(d, map->map_priv_1 + adr);
+ 	mb();
+ }
+ 
+-void ar7_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
++static void ar7_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+ {
+ 	memcpy_toio(map->map_priv_1 + to, from, len);
+ }
+ 
+-struct map_info ar7_map = {
++static struct map_info ar7_map = {
+ 	name: "Physically mapped flash",
+ 	size: WINDOW_SIZE,
+ 	buswidth: BUSWIDTH,
+@@ -86,44 +83,6 @@
+ 	copy_to: ar7_copy_to
+ };
+ 
+-int __init ar7_mtd_init(void)
+-{
+-	int partitions;
+-	
+-       	printk(KERN_NOTICE "ar7 flash device: 0x%lx at 0x%lx.\n", (unsigned long)WINDOW_SIZE, (unsigned long)WINDOW_ADDR);
+-	ar7_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
+-
+-	if (!ar7_map.map_priv_1) {
+-		printk("Failed to ioremap\n");
+-		return -EIO;
+-	}
+-	
+-	ar7_mtd_info = do_map_probe("cfi_probe", &ar7_map);
+-	if (!ar7_mtd_info)
+-	{
+-		ar7_mtd_cleanup();
+-		return -ENXIO;
+-	}
+-	
+-	ar7_mtd_info->module = THIS_MODULE;
+-
+-	if (!(partitions = create_mtd_partitions()))
+-		add_mtd_device(ar7_mtd_info);
+-	else		
+-		add_mtd_partitions(ar7_mtd_info, ar7_partinfo, partitions);
+-
+-	return 0;
+-}
+-
+-static char *strdup(char *str)
+-{
+-	int n = strlen(str)+1;
+-	char *s = kmalloc(n, GFP_KERNEL);
+-	if (!s) return NULL;
+-	return strcpy(s, str);
+-}
+-
+-
+ static int create_mtd_partitions(void)
+ {
+ 	unsigned int offset;
+@@ -190,12 +149,12 @@
+ 	
+ 	p = 0;
+ 	
+-	ar7_partinfo[p].name = strdup("adam2");
++	ar7_partinfo[p].name = "adam2";
+ 	ar7_partinfo[p].offset = 0;
+ 	ar7_partinfo[p].size = adam2_size;
+ 	ar7_partinfo[p++].mask_flags = 0;
+ 
+-	ar7_partinfo[p].name = strdup("linux");
++	ar7_partinfo[p].name = "linux";
+ 	ar7_partinfo[p].offset = adam2_size;
+ 	ar7_partinfo[p].size = config_offset - adam2_size;
+ 	ar7_partinfo[p++].mask_flags = 0;
+@@ -205,13 +164,13 @@
+ 		printk("Setting new rootfs offset to %08x\n", rootfs_start);
+ 	}
+ 	
+-	ar7_partinfo[p].name = strdup("rootfs");
++	ar7_partinfo[p].name = "rootfs";
+ 	ar7_partinfo[p].offset = rootfs_start;
+ 	ar7_partinfo[p].size = config_offset - rootfs_start;
+ 	
+ 	ar7_partinfo[p++].mask_flags = 0;
+ 
+-	ar7_partinfo[p].name = strdup("config");
++	ar7_partinfo[p].name = "config";
+ 	ar7_partinfo[p].offset = config_offset;
+ 	ar7_partinfo[p].size = WINDOW_SIZE - config_offset;
+ 	ar7_partinfo[p++].mask_flags = 0;
+@@ -222,7 +181,7 @@
+ 
+ 		ar7_copy_from(&ar7_map, &sb, rootfs_start, sizeof(sb));
+ 		printk("Squashfs detected (size = 0x%08x)\n", sb.bytes_used);
+-		
++
+ 		newoffset = rootfs_start + sb.bytes_used;
+ 
+ 		if ((newoffset % ar7_mtd_info->erasesize) > 0)
+@@ -230,7 +189,7 @@
+ 		
+ 		ar7_partinfo[p - 2].size = newoffset - rootfs_start;
+ 		
+-		ar7_partinfo[p].name = strdup("OpenWrt");
++		ar7_partinfo[p].name = "OpenWrt";
+ 		ar7_partinfo[p].offset = newoffset;
+ 		ar7_partinfo[p].size = config_offset - newoffset;
+ 		ar7_partinfo[p++].mask_flags = 0;
+@@ -245,6 +204,36 @@
+ 	return p;
+ }
+ 
++static int __init ar7_mtd_init(void)
++{
++	int partitions;
++	
++       	printk(KERN_NOTICE "ar7 flash device: 0x%lx at 0x%lx.\n", (unsigned long)WINDOW_SIZE, (unsigned long)WINDOW_ADDR);
++	ar7_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
++
++	if (!ar7_map.map_priv_1) {
++		printk("Failed to ioremap\n");
++		return -EIO;
++	}
++	
++	ar7_mtd_info = do_map_probe("cfi_probe", &ar7_map);
++	if (!ar7_mtd_info)
++	{
++		iounmap((void *)ar7_map.map_priv_1);
++		ar7_map.map_priv_1 = 0;
++		return -ENXIO;
++	}
++	
++	ar7_mtd_info->module = THIS_MODULE;
++
++	if (!(partitions = create_mtd_partitions()))
++		add_mtd_device(ar7_mtd_info);
++	else		
++		add_mtd_partitions(ar7_mtd_info, ar7_partinfo, partitions);
++
++	return 0;
++}
++
+ static void __exit ar7_mtd_cleanup(void)
+ {
+ 	if (ar7_mtd_info) {
+diff -urN linux-2.4.32/drivers/mtd/maps/Config.in linux-2.4.32.new/drivers/mtd/maps/Config.in
+--- linux-2.4.32/drivers/mtd/maps/Config.in	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/mtd/maps/Config.in	2005-12-27 21:44:16.000000000 +0100
+@@ -54,7 +54,11 @@
+       if [ "$CONFIG_MTD_AR7" = "y" -o "$CONFIG_MTD_AR7" = "m" ]; then
+          if [ "$CONFIG_MTD_AR7_DEFAULTS" = "y" ]; then
+             define_hex CONFIG_MTD_AR7_START 0x10000000
+-            define_hex CONFIG_MTD_AR7_LEN 0x400000
++	    if [ "$CONFIG_MIPS_SINUS154" = "y" ]; then
++               define_hex CONFIG_MTD_AR7_LEN 0x00200000
++	    else
++               define_hex CONFIG_MTD_AR7_LEN 0x00400000
++	    fi
+             define_int CONFIG_MTD_AR7_BUSWIDTH 2
+          else
+             hex '      Physical start address of flash mapping' CONFIG_MTD_AR7_START 0x10000000
+diff -urN linux-2.4.32/drivers/mtd/maps/Makefile linux-2.4.32.new/drivers/mtd/maps/Makefile
+--- linux-2.4.32/drivers/mtd/maps/Makefile	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/drivers/mtd/maps/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -11,6 +11,7 @@
+ 
+ # Chip mappings
+ obj-$(CONFIG_MTD_AR7)		+= ar7-flash.o
++obj-$(CONFIG_MTD_AR7)		+= sinus154-flash.o
+ obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
+ obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
+ obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
+diff -urN linux-2.4.32/drivers/mtd/maps/sinus154-flash.c linux-2.4.32.new/drivers/mtd/maps/sinus154-flash.c
+--- linux-2.4.32/drivers/mtd/maps/sinus154-flash.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-2.4.32.new/drivers/mtd/maps/sinus154-flash.c	2005-12-27 21:44:16.000000000 +0100
+@@ -0,0 +1,205 @@
++/*
++ * $Id: 011-sinus.patch,v 1.11 2005/12/29 10:26:15 stefan Exp stefan $
++ *
++ * Normal mappings of chips in physical memory
++ */
++
++#include <linux/module.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <asm/io.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/map.h>
++#include <linux/config.h>
++#include <linux/mtd/partitions.h>
++#include <linux/squashfs_fs.h>
++
++#define WINDOW_ADDR CONFIG_MTD_AR7_START
++#define WINDOW_SIZE CONFIG_MTD_AR7_LEN
++#define BUSWIDTH CONFIG_MTD_AR7_BUSWIDTH
++
++// AR7 internal PROM at physical address 0xbfc00000, 4 KiB
++#define AR7_WINDOW_ADDR 0x1fc00000
++#define AR7_WINDOW_SIZE 0x1000
++
++static struct mtd_partition ar7_partinfo[] = {
++	{
++		name: "Boot PROM",
++		offset: 0,
++		size: AR7_WINDOW_SIZE,
++		mask_flags: MTD_WRITEABLE, /* force read-only */
++	}
++};
++
++static struct mtd_info *ar7_mtd_info;
++
++static struct mtd_partition sinus154_partinfo[] = {
++	{
++		name: "Boot",
++		offset: 0,
++		size: 0x20000,
++		mask_flags: MTD_WRITEABLE, /* force read-only */
++	},
++	{
++		name: "Configuration",
++		offset: MTDPART_OFS_APPEND,
++		size: 0x20000,
++		mask_flags: 0,
++	},
++	{
++		name: "Web Image",
++		offset: MTDPART_OFS_APPEND,
++		size: 0xd0000,
++		mask_flags: 0,
++	},
++	{
++		name: "Code Image",
++		offset: MTDPART_OFS_APPEND,
++		size: 0xe0000,
++		mask_flags: 0,
++	},
++	{
++		name: "Boot Params",
++		offset: MTDPART_OFS_APPEND,
++		size: 0x10000,
++		mask_flags: 0,
++	},
++};
++
++static struct mtd_info *sinus154_mtd_info;
++
++static __u8 ar7_read8(struct map_info *map, unsigned long ofs)
++{
++	return __raw_readb(map->map_priv_1 + ofs);
++}
++
++static __u16 ar7_read16(struct map_info *map, unsigned long ofs)
++{
++	return __raw_readw(map->map_priv_1 + ofs);
++}
++
++static __u32 ar7_read32(struct map_info *map, unsigned long ofs)
++{
++	return __raw_readl(map->map_priv_1 + ofs);
++}
++
++static void ar7_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
++{
++	memcpy_fromio(to, map->map_priv_1 + from, len);
++}
++
++static void ar7_write8(struct map_info *map, __u8 d, unsigned long adr)
++{
++	__raw_writeb(d, map->map_priv_1 + adr);
++	mb();
++}
++
++static void ar7_write16(struct map_info *map, __u16 d, unsigned long adr)
++{
++	__raw_writew(d, map->map_priv_1 + adr);
++	mb();
++}
++
++static void ar7_write32(struct map_info *map, __u32 d, unsigned long adr)
++{
++	__raw_writel(d, map->map_priv_1 + adr);
++	mb();
++}
++
++static void ar7_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
++{
++	memcpy_toio(map->map_priv_1 + to, from, len);
++}
++
++static struct map_info ar7_map = {
++	name: "Boot PROM",
++	size: AR7_WINDOW_SIZE,
++	buswidth: BUSWIDTH,
++	read8: ar7_read8,
++	read16: ar7_read16,
++	read32: ar7_read32,
++	copy_from: ar7_copy_from,
++	write8: ar7_write8,
++	write16: ar7_write16,
++	write32: ar7_write32,
++	copy_to: ar7_copy_to
++};
++
++static struct map_info sinus154_map = {
++	name: "Sinus 154 Flash",
++	size: WINDOW_SIZE,
++	buswidth: BUSWIDTH,
++	read8: ar7_read8,
++	read16: ar7_read16,
++	read32: ar7_read32,
++	copy_from: ar7_copy_from,
++	write8: ar7_write8,
++	write16: ar7_write16,
++	write32: ar7_write32,
++	copy_to: ar7_copy_to
++};
++
++static int __init ar7_mtd_init(void)
++{
++       	printk(KERN_NOTICE "ar7 flash device: 0x%lx at 0x%lx.\n", (unsigned long)AR7_WINDOW_SIZE, (unsigned long)AR7_WINDOW_ADDR);
++	ar7_map.map_priv_1 = (unsigned long)ioremap_nocache(AR7_WINDOW_ADDR, AR7_WINDOW_SIZE);
++
++	if (!ar7_map.map_priv_1) {
++		printk("Failed to ioremap\n");
++		return -EIO;
++	}
++	
++	ar7_mtd_info = do_map_probe("map_rom", &ar7_map);
++
++	if (!ar7_mtd_info)
++	{
++		iounmap((void *)ar7_map.map_priv_1);
++		ar7_map.map_priv_1 = 0;
++		return -ENXIO;
++	}
++	
++	ar7_mtd_info->module = THIS_MODULE;
++
++	//~ add_mtd_device(ar7_mtd_info);
++	add_mtd_partitions(ar7_mtd_info, ar7_partinfo, 1);
++
++       	printk(KERN_NOTICE "Sinus154 flash device: 0x%lx at 0x%lx.\n", (unsigned long)WINDOW_SIZE, (unsigned long)WINDOW_ADDR);
++	sinus154_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
++	sinus154_mtd_info = do_map_probe("cfi_probe", &sinus154_map);
++	sinus154_mtd_info->module = THIS_MODULE;
++	add_mtd_partitions(sinus154_mtd_info, sinus154_partinfo, 5);
++
++	return 0;
++}
++
++static void __exit ar7_mtd_cleanup(void)
++{
++	if (ar7_mtd_info) {
++		del_mtd_partitions(ar7_mtd_info);
++		//~ del_mtd_device(ar7_mtd_info);
++		map_destroy(ar7_mtd_info);
++	}
++
++	if (ar7_map.map_priv_1) {
++		iounmap((void *)ar7_map.map_priv_1);
++		ar7_map.map_priv_1 = 0;
++	}
++
++	if (sinus154_mtd_info) {
++		del_mtd_partitions(ar7_mtd_info);
++		//~ del_mtd_device(sinus154_mtd_info);
++		map_destroy(sinus154_mtd_info);
++	}
++
++	if (sinus154_map.map_priv_1) {
++		iounmap((void *)sinus154_map.map_priv_1);
++		sinus154_map.map_priv_1 = 0;
++	}
++}
++
++module_init(ar7_mtd_init);
++module_exit(ar7_mtd_cleanup);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Stefan Weil");
++MODULE_DESCRIPTION("AR7 CFI map driver");
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.c linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.c
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.c	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.c	2005-12-27 21:44:16.000000000 +0100
+@@ -33,13 +33,17 @@
+ #include <asm/uaccess.h>
+ #include <linux/config.h>
+ #include <asm/ar7/if_port.h>
++#include <asm/ar7/led_hal.h>	/* avalanche_led_action, ... */
+ 
+-extern void build_psp_config(void);
+-extern void psp_config_cleanup(void);
++#include "psp_config_mgr.h"	/* build_psp_config, psp_config_cleanup */
+ 
+ #include "cpmacHalLx.h"
+ #include "cpmac.h"
+ 
++#if defined(CONFIG_AR7_LED)
++# define CONFIG_MIPS_AVALANCHE_LED
++#endif
++
+ static struct net_device *last_cpmac_device = NULL;
+ static int    cpmac_devices_installed = 0;
+ 
+@@ -955,9 +959,9 @@
+         dbgPrint("Maintaining the link up loopback for %s.\n", p_dev->name);
+ 	netif_carrier_on(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
++#endif
+ 
+         return(0);
+     }
+@@ -972,9 +976,9 @@
+ 	{
+             netif_carrier_on(p_cpmac_priv->owner);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
++#endif
+ 	    dbgPrint("Found the Link for the CPMAC instance %s.\n", p_dev->name);
+         }
+ 
+@@ -997,9 +1001,9 @@
+ 
+ 	    netif_carrier_off(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++            avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
++#endif
+ 
+ 	    dbgPrint("Lost the Link for the CPMAC for %s.\n", p_dev->name);
+ 	}
+@@ -1467,7 +1471,7 @@
+     if(!mac_string)
+     {
+         mac_string="08.00.28.32.06.02";
+-        printk("Error getting mac from Boot enviroment for %s\n",p_dev->name);
++        printk("Error getting mac from Boot environment for %s\n",p_dev->name);
+         printk("Using default mac address: %s\n",mac_string);
+         if(mac_name)
+         {
+@@ -1488,13 +1492,13 @@
+     p_cpmac_priv->set_to_close          = 1;
+     p_cpmac_priv->non_data_irq_expected = 0;
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    if((p_cpmac_priv->led_handle = avalanche_led_register("cpmac", instance_num)) == NULL)
+-//   {
+-//        errPrint("Could not allocate handle for CPMAC[%d] LED.\n", instance_num);
+-//       goto cpmac_init_mod_error;
+-//    }
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    if((p_cpmac_priv->led_handle = avalanche_led_register("cpmac", instance_num)) == NULL)
++    {
++       errPrint("Could not allocate handle for CPMAC[%d] LED.\n", instance_num);
++       // goto cpmac_init_mod_error;
++    }
++#endif
+ 
+     if(cpmac_drv_init_module(p_drv_hal, p_dev, instance_num) != 0)
+     {
+@@ -1546,11 +1550,11 @@
+ 
+     netif_carrier_off(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
++#endif
+ 
+-    /* Tasklet is initialized at the isr registeration time. */
++    /* Tasklet is initialized at the isr registration time. */
+     p_drv_hal->hal_funcs->Control(p_drv_hal->hal_dev, "CpmacBase", "Get", &p_dev->base_addr);
+     p_drv_hal->hal_funcs->Control(p_drv_hal->hal_dev, "CpmacSize", "Get", &p_cpmac_priv->dev_size);
+ 
+@@ -1698,9 +1702,9 @@
+         p_cpmac_priv->link_mode         = 1;
+         netif_carrier_off(p_dev);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++        avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_OFF);
++#endif
+ 
+         clear_bit(0, &p_cpmac_priv->non_data_irq_expected);
+ 
+@@ -1751,10 +1755,10 @@
+     int                     val           = 1;
+     int                     channel       = 0;
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)    
+-//    if(netif_carrier_ok(p_dev))
+-//      avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)    
++    if(netif_carrier_ok(p_dev))
++      avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_LINK_ON);
++#endif
+ 
+     if(p_dev->flags & IFF_PROMISC)
+     {
+@@ -1920,9 +1924,9 @@
+         goto cpmac_dev_tx_drop_pkt; 
+     }
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_TX_ACTIVITY);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_TX_ACTIVITY);
++#endif
+ 
+     return(ret_val);
+ 
+@@ -2134,9 +2138,8 @@
+         /* For Sangam Mdio-switching  action should be always "set"*/
+         if(cpmac_ci_strcmp(action, hcSet) == 0 && value != NULL )
+         {
+-           unsigned  int mdix =  *((unsigned int *) value) ;
+-
+ #ifdef CONFIG_AR7_MDIX
++           unsigned  int mdix =  *((unsigned int *) value) ;
+ 	   avalanche_set_mdix_on_chip(0xa8610000 , mdix ? 1: 0);
+ #endif
+   
+@@ -2219,9 +2222,9 @@
+ 
+     netif_rx(p_skb);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_RX_ACTIVITY);	
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++    avalanche_led_action(p_cpmac_priv->led_handle, CPMAC_RX_ACTIVITY);	
++#endif
+ 
+     p_cpmac_priv->net_dev_stats.rx_packets++;
+     p_cpmac_priv->net_dev_stats.rx_bytes += packet_size;
+@@ -2325,6 +2328,8 @@
+     //cpmac_cpu_freq = avalanche_clkc_get_freq(CLKC_MIPS);
+     cpmac_cpu_freq = CONFIG_AR7_CPU * 1000 * 1000;
+ 
++    dbgPrint("%s:%u freq = %lu\n", __FILE__, __LINE__, (unsigned long)cpmac_cpu_freq);
++
+     build_psp_config();                       
+ 
+     for(unit = 0; unit < instance_count; unit++)
+@@ -2469,9 +2474,9 @@
+       
+         cpmac_drv_cleanup(p_cpmac_priv->drv_hal);
+ 
+-//#if defined (CONFIG_MIPS_AVALANCHE_LED)
+-//        avalanche_led_unregister(p_cpmac_priv->led_handle);
+-//#endif
++#if defined (CONFIG_MIPS_AVALANCHE_LED)
++        avalanche_led_unregister(p_cpmac_priv->led_handle);
++#endif
+ 	strcpy(proc_name, "avalanche/");
+         strcat(proc_name, p_dev->name);
+         proc_category_name_len = strlen(proc_name);
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.h linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.h
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmac.h	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmac.h	2005-12-27 21:45:14.000000000 +0100
+@@ -348,7 +348,7 @@
+ 
+ 
+ void *cpmac_hal_malloc_buffer(unsigned int size, void *MemBase, unsigned int MemRange,
+-                              HAL_DEVICE *HalDev, HAL_RECEIVEINFO *HalReceiveInfo, 
++                              OS_SETUP *p_os_setup, HAL_RECEIVEINFO *HalReceiveInfo, 
+                               OS_RECEIVEINFO **OsReceiveInfo, OS_DEVICE *OsDev);
+ 
+ void cpmac_hal_tear_down_complete(OS_DEVICE*, int, int);
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/cpmacHalLx.h linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmacHalLx.h
+--- linux-2.4.32/drivers/net/avalanche_cpmac/cpmacHalLx.h	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/cpmacHalLx.h	2005-12-27 21:45:14.000000000 +0100
+@@ -22,16 +22,7 @@
+ typedef struct net_device         OS_DEVICE;
+ typedef struct sk_buff            OS_RECEIVEINFO;
+ typedef struct sk_buff            OS_SENDINFO;
+-
+-#ifdef DEBUG
+-typedef void                      HAL_RECEIVEINFO;
+-typedef void                      HAL_DEVICE;
+-typedef void                      OS_SETUP;
+-#endif
+-
+-#define OS_SETUP   void
+-#define HAL_DEVICE void
+-#define HAL_RECEIVEINFO void
++typedef struct _os_setup_s OS_SETUP;
+ 
+ #define _CPHAL_CPMAC
+  
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/Makefile linux-2.4.32.new/drivers/net/avalanche_cpmac/Makefile
+--- linux-2.4.32/drivers/net/avalanche_cpmac/Makefile	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/Makefile	2005-12-27 21:44:16.000000000 +0100
+@@ -5,22 +5,8 @@
+ 
+ O_TARGET := avalanche_cpmac.o
+ 
+-
+-list-multi := avalanche_cpmac.o
+-obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) := avalanche_cpmac.o
+-
+-avalanche_cpmac-objs += cpmac.o            cpmacHalLx.o       hcpmac.o \
+-                        	      psp_config_build.o psp_config_mgr.o            \
+-				      psp_config_parse.o psp_config_util.o
+-
++obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) := cpmac.o cpmacHalLx.o hcpmac.o
++obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) += psp_config_build.o psp_config_mgr.o
++obj-$(CONFIG_MIPS_AVALANCHE_CPMAC) += psp_config_parse.o psp_config_util.o
+ 
+ include $(TOPDIR)/Rules.make
+-
+-
+-avalanche_cpmac.o:        $(avalanche_cpmac-objs)
+-	$(LD) -r -o $@ $(avalanche_cpmac-objs)
+-
+-
+-
+-clean:
+-	rm -f core *.o *.a *.s
+diff -urN linux-2.4.32/drivers/net/avalanche_cpmac/psp_config_mgr.h linux-2.4.32.new/drivers/net/avalanche_cpmac/psp_config_mgr.h
+--- linux-2.4.32/drivers/net/avalanche_cpmac/psp_config_mgr.h	2005-12-29 11:23:33.000000000 +0100
++++ linux-2.4.32.new/drivers/net/avalanche_cpmac/psp_config_mgr.h	2005-12-27 21:44:16.000000000 +0100
+@@ -105,6 +105,8 @@
+   -------------------------------------------------------------------------*/
+ void  psp_config_print(char *key);
+ 
++void  psp_config_cleanup(void);
++
+ void  dump_device_cfg_pool(void);
+ 
+ #endif /* __PSP_CONFIG_MGR_H__ */
+diff -urN linux-2.4.32/drivers/net/wireless/Config.in linux-2.4.32.new/drivers/net/wireless/Config.in
+--- linux-2.4.32/drivers/net/wireless/Config.in	2004-11-17 12:54:21.000000000 +0100
++++ linux-2.4.32.new/drivers/net/wireless/Config.in	2005-12-27 21:44:16.000000000 +0100
+@@ -38,6 +38,7 @@
+ 
+ # yes, this works even when no drivers are selected
+ if [ "$CONFIG_ISA" = "y" -o "$CONFIG_PCI" = "y" -o \
++     "$CONFIG_AR7_VLYNQ" = "y" -o \
+      "$CONFIG_ALL_PPC" = "y" -o "$CONFIG_PCMCIA" != "n" ]; then
+    define_bool CONFIG_NET_WIRELESS y
+ else
+diff -urN linux-2.4.32/include/asm-mips/ar7/adam2_env.h linux-2.4.32.new/include/asm-mips/ar7/adam2_env.h
+--- linux-2.4.32/include/asm-mips/ar7/adam2_env.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/adam2_env.h	2005-12-27 21:44:16.000000000 +0100
+@@ -1,6 +1,9 @@
+ #ifndef _INCLUDE_ASM_AR7_ADAM2_ENV_H_
+ #define	_INCLUDE_ASM_AR7_ADAM2_ENV_H_
+ 
++extern int prom_argc;
++extern int *_prom_argv;
++
+ /* Environment variable */
+ typedef struct {
+ 	char *name;
+diff -urN linux-2.4.32/include/asm-mips/ar7/ar7.h linux-2.4.32.new/include/asm-mips/ar7/ar7.h
+--- linux-2.4.32/include/asm-mips/ar7/ar7.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/ar7.h	2005-12-27 21:45:12.000000000 +0100
+@@ -24,8 +24,6 @@
+ #include <asm/addrspace.h>
+ #include <linux/config.h>
+ 
+-#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(CONFIG_AR7_MEMORY))
+-
+ #define AR7_UART0_REGS_BASE (KSEG1ADDR(0x08610E00))
+ #define AR7_UART1_REGS_BASE (KSEG1ADDR(0x08610F00))
+ #define AR7_BASE_BAUD ( 3686400 / 16 )
+diff -urN linux-2.4.32/include/asm-mips/ar7/avalanche_intc.h linux-2.4.32.new/include/asm-mips/ar7/avalanche_intc.h
+--- linux-2.4.32/include/asm-mips/ar7/avalanche_intc.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/avalanche_intc.h	2005-12-27 21:45:06.000000000 +0100
+@@ -27,6 +27,7 @@
+ #define _AVALANCHE_INTC_H
+ 
+ #include <linux/config.h>
++#include "sangam.h"
+ 
+ /* ----- */
+ 
+@@ -34,7 +35,6 @@
+ #define KSEG_INV_MASK               0x1FFFFFFF /* Inverted mask for kseg address */
+ #define PHYS_ADDR(addr)             ((addr) & KSEG_INV_MASK)
+ #define PHYS_TO_K1(addr)            (PHYS_ADDR(addr)|KSEG1_BASE)
+-#define AVALANCHE_INTC_BASE PHYS_TO_K1(0x08612400)
+ 
+ /* ----- */
+ 
+@@ -285,8 +285,4 @@
+ 
+ #define EMIF_INT                    (7 + PRIMARY_INTS)
+ 
+-
+-extern void avalanche_int_set(int channel, int line);
+-
+-
+ #endif /* _AVALANCHE_INTC_H */
+diff -urN linux-2.4.32/include/asm-mips/ar7/avalanche_misc.h linux-2.4.32.new/include/asm-mips/ar7/avalanche_misc.h
+--- linux-2.4.32/include/asm-mips/ar7/avalanche_misc.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/avalanche_misc.h	2005-12-27 21:44:16.000000000 +0100
+@@ -79,6 +79,12 @@
+ 
+ typedef int (*REMOTE_VLYNQ_DEV_RESET_CTRL_FN)(unsigned int reset_module, AVALANCHE_RESET_CTRL_T reset_ctrl);
+ 
++int avalanche_reset_ctrl(unsigned int module_reset_bit, 
++			 AVALANCHE_RESET_CTRL_T reset_ctrl);
++ 
++/* ar7/misc.c */
++extern REMOTE_VLYNQ_DEV_RESET_CTRL_FN p_remote_vlynq_dev_reset_ctrl;
++
+ /*****************************************************************************
+  * Power Control Module
+  *****************************************************************************/
+diff -urN linux-2.4.32/include/asm-mips/ar7/tnetd73xx_misc.h linux-2.4.32.new/include/asm-mips/ar7/tnetd73xx_misc.h
+--- linux-2.4.32/include/asm-mips/ar7/tnetd73xx_misc.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/tnetd73xx_misc.h	2005-12-27 21:44:16.000000000 +0100
+@@ -17,6 +17,8 @@
+ #ifndef __TNETD73XX_MISC_H__
+ #define __TNETD73XX_MISC_H__
+ 
++#include <asm/ar7/tnetd73xx_err.h> /* TNETD73XX_ERR */
++
+ /*****************************************************************************
+  * Reset Control Module
+  *****************************************************************************/
+diff -urN linux-2.4.32/include/asm-mips/ar7/vlynq.h linux-2.4.32.new/include/asm-mips/ar7/vlynq.h
+--- linux-2.4.32/include/asm-mips/ar7/vlynq.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/vlynq.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,610 +0,0 @@
+-/***************************************************************************
+-**+----------------------------------------------------------------------+**
+-**|                                ****                                  |**
+-**|                                ****                                  |**
+-**|                                ******o***                            |**
+-**|                          ********_///_****                           |**
+-**|                           ***** /_//_/ ****                          |**
+-**|                            ** ** (__/ ****                           |**
+-**|                                *********                             |**
+-**|                                 ****                                 |**
+-**|                                  ***                                 |**
+-**|                                                                      |**
+-**|     Copyright (c) 2003 Texas Instruments Incorporated                |**
+-**|                        ALL RIGHTS RESERVED                           |**
+-**|                                                                      |**
+-**| Permission is hereby granted to licensees of Texas Instruments       |**
+-**| Incorporated (TI) products to use this computer program for the sole |**
+-**| purpose of implementing a licensee product based on TI products.     |**
+-**| No other rights to reproduce, use, or disseminate this computer      |**
+-**| program, whether in part or in whole, are granted.                   |**
+-**|                                                                      |**
+-**| TI makes no representation or warranties with respect to the         |**
+-**| performance of this computer program, and specifically disclaims     |**
+-**| any responsibility for any damages, special or consequential,        |**
+-**| connected with the use of this program.                              |**
+-**|                                                                      |**
+-**+----------------------------------------------------------------------+**
+-***************************************************************************/
+-
+-/*********************************************************************************
+- *  ------------------------------------------------------------------------------
+- *   Module      : vlynq_hal.h
+- *   Description :
+- *   This header file provides the set of functions exported by the 
+- *   VLYNQ HAL. This file is included from the SOC specific VLYNQ driver wrapper.
+- *  ------------------------------------------------------------------------------
+- *********************************************************************************/
+-
+-#ifndef _VLYNQ_HAL_H_
+-#define _VLYNQ_HAL_H_
+-
+-/* Enable/Disable debug feature */
+-#undef VLYNQ_DEBUG 
+-
+-#ifdef VLYNQ_DEBUG  /* This needs to be OS abstracted - for testing use vxworks/linux calls */
+-#define debugPrint(format,args...)    
+-#else 
+-#define debugPrint(format,args...)  
+-#endif
+-
+- /* number of VLYNQ memory regions supported */
+-#define VLYNQ_MAX_MEMORY_REGIONS 0x04
+-  
+- /* Max.number of external interrupt inputs supported by VLYNQ module */
+-#define VLYNQ_IVR_MAXIVR         0x08
+-
+-#define VLYNQ_CLK_DIV_MAX  0x08
+-#define VLYNQ_CLK_DIV_MIN  0x01
+-
+-
+-/*** the total number of entries allocated for ICB would be
+- * 32(for 32 bits in IntPending register) + VLYNQ_IVR_CHAIN_SLOTS*/
+-#define VLYNQ_IVR_CHAIN_SLOTS 10
+-
+-
+-/* Error defines */
+-#define VLYNQ_SUCCESS               0
+-
+-#define VLYNQ_ERRCODE_BASE          0 /* Chosen by system */
+-#define VLYNQ_INVALID_ARG          -(VLYNQ_ERRCODE_BASE+1)
+-#define VLYNQ_INVALID_DRV_STATE    -(VLYNQ_ERRCODE_BASE+2)
+-#define VLYNQ_INT_CONFIG_ERR       -(VLYNQ_ERRCODE_BASE+3)
+-#define VLYNQ_LINK_DOWN            -(VLYNQ_ERRCODE_BASE+4)
+-#define VLYNQ_MEMALLOC_FAIL        -(VLYNQ_ERRCODE_BASE+5)
+-#define VLYNQ_ISR_NON_EXISTENT     -(VLYNQ_ERRCODE_BASE+6)
+-#define VLYNQ_INTVEC_MAP_NOT_FOUND -(VLYNQ_ERRCODE_BASE+7)
+-
+-/* Vlynq Defines and Macros */
+-
+-#define VLYNQ_NUM_INT_BITS              32 /* 32 bit interrupt staus register */
+-
+-/* Base address of module */
+-#define VLYNQ_BASE                      (pdev->module_base)
+-
+-#define VLYNQ_REMOTE_REGS_OFFSET        0x0080
+-
+-#define VLYNQ_REV_OFFSET                0x0000
+-#define VLYNQ_CTRL_OFFSET               0x0004
+-#define VLYNQ_STATUS_OFFSET             0x0008
+-#define VLYNQ_INT_STAT_OFFSET           0x0010
+-#define VLYNQ_INT_PEND_OFFSET           0x0014
+-#define VLYNQ_INT_PTR_OFFSET            0x0018
+-#define VLYNQ_TXMAP_OFFSET              0x001c
+-
+-#define VLYNQ_RX0MAP_SIZE_REG_OFFSET    0x0020
+-#define VLYNQ_RX0MAP_OFFSET_REG_OFFSET  0x0024
+-
+-#define VLYNQ_CHIP_VER_OFFSET           0x0040
+-#define VLYNQ_IVR_REGS_OFFSET           0x0060
+-
+-#define VLYNQ_INT_PENDING_REG_PTR       0x14
+-#define VLYNQ_R_INT_PENDING_REG_PTR     VLYNQ_REMOTE_REGS_OFFSET + 0x14
+-
+-#define VLYNQ_REV_REG       *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_REV_OFFSET))
+-#define VLYNQ_CTRL_REG      *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_CTRL_OFFSET))
+-#define VLYNQ_STATUS_REG    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_STATUS_OFFSET))
+-#define VLYNQ_INT_STAT_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_STAT_OFFSET))
+-#define VLYNQ_INT_PEND_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_PEND_OFFSET))
+-#define VLYNQ_INT_PTR_REG   *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_PTR_OFFSET))
+-#define VLYNQ_TXMAP_REG     *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_TXMAP_OFFSET))
+-
+-/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+-#define VLYNQ_RXMAP_SIZE_REG(map) \
+-    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_RX0MAP_SIZE_REG_OFFSET+( (map-1)<<3)))
+-    
+-/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+-#define VLYNQ_RXMAP_OFFSET_REG(map) \
+-    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_RX0MAP_OFFSET_REG_OFFSET+( (map-1)<<3)))
+-
+-#define VLYNQ_CHIP_VER_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_CHIP_VER_OFFSET))
+-
+-/* 0 =< ivr <= 31; currently ivr < VLYNQ_IVR_MAXIVR=8) */
+-#define VLYNQ_IVR_OFFSET(ivr)  \
+-    (VLYNQ_BASE + VLYNQ_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3) )
+-
+-#define VLYNQ_IVR_03TO00_REG  *((volatile unsigned int*) (VLYNQ_IVR_OFFSET(0)) )
+-#define VLYNQ_IVR_07TO04_REG  *((volatile unsigned int*) (VLYNQ_IVR_OFFSET(4)) )
+-/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
+-
+-#define VLYNQ_IVR_INTEN(ivr)    (((unsigned int)(0x80)) << ((((unsigned)(ivr)) % 4) * 8))
+-#define VLYNQ_IVR_INTTYPE(ivr)  (((unsigned int)(0x40)) << ((((unsigned)(ivr)) % 4) * 8))
+-#define VLYNQ_IVR_INTPOL(ivr)   (((unsigned int)(0x20)) << ((((unsigned)(ivr)) % 4) * 8))
+-#define VLYNQ_IVR_INTVEC(ivr)   (((unsigned int)(0x1F)) << ((((unsigned)(ivr)) % 4) * 8))
+-#define VLYNQ_IVR_INTALL(ivr)   (((unsigned int)(0xFF)) << ((((unsigned)(ivr)) % 4) * 8))
+-
+-
+-
+-/*********************************
+- * Remote VLYNQ register set     *
+- *********************************/
+-
+-#define VLYNQ_R_REV_OFFSET              0x0080
+-#define VLYNQ_R_CTRL_OFFSET             0x0084
+-#define VLYNQ_R_STATUS_OFFSET           0x0088
+-#define VLYNQ_R_INT_STAT_OFFSET         0x0090
+-#define VLYNQ_R_INT_PEND_OFFSET         0x0094
+-#define VLYNQ_R_INT_PTR_OFFSET          0x0098
+-#define VLYNQ_R_TXMAP_OFFSET            0x009c
+-
+-#define VLYNQ_R_RX0MAP_SIZE_REG_OFFSET  0x00A0
+-#define VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET 0x00A4
+-
+-#define VLYNQ_R_CHIP_VER_OFFSET         0x00C0
+-#define VLYNQ_R_IVR_REGS_OFFSET         0x00E0
+-
+-#define VLYNQ_R_REV_REG       *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_REV_OFFSET)) 
+-#define VLYNQ_R_CTRL_REG      *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_CTRL_OFFSET))
+-#define VLYNQ_R_STATUS_REG    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_STATUS_OFFSET))
+-#define VLYNQ_R_INT_STAT_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_STAT_OFFSET))
+-#define VLYNQ_R_INT_PEND_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_PEND_OFFSET))
+-#define VLYNQ_R_INT_PTR_REG   *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_PTR_OFFSET))
+-#define VLYNQ_R_TXMAP_REG     *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_TXMAP_OFFSET))
+-
+-/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+-#define VLYNQ_R_RXMAP_SIZE_REG(map) \
+-    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_SIZE_REG_OFFSET + ((map-1)<<3)))
+-    
+-/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+-#define VLYNQ_R_RXMAP_OFFSET_REG(map) \
+-    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET + ((map-1)<<3)))
+-
+-#define VLYNQ_R_CHIP_VER_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_CHIP_VER_OFFSET)
+-
+-#define VLYNQ_R_IVR_OFFSET(ivr)  \
+-    (VLYNQ_BASE + VLYNQ_R_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3))
+- 
+-
+-/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
+-#define VLYNQ_R_IVR_03TO00_REG  *((volatile unsigned int*) (VLYNQ_R_IVR_OFFSET(0)) )
+-#define VLYNQ_R_IVR_07TO04_REG  *((volatile unsigned int*) (VLYNQ_R_IVR_OFFSET(4)) )
+-
+-
+-/****End of remote register set definition******/
+-
+-
+-/*** Masks for individual register fields ***/
+-
+-#define VLYNQ_MODULE_ID_MASK        0xffff0000
+-#define VLYNQ_MAJOR_REV_MASK        0x0000ff00
+-#define VLYNQ_MINOR_REV_MASK        0x000000ff
+-
+-    
+-#define VLYNQ_CTL_ILOOP_MASK        0x00000002
+-#define VLYNQ_CTL_INT2CFG_MASK      0x00000080
+-#define VLYNQ_CTL_INTVEC_MASK       0x00001f00
+-#define VLYNQ_CTL_INTEN_MASK        0x00002000
+-#define VLYNQ_CTL_INTLOCAL_MASK     0x00004000
+-#define VLYNQ_CTL_CLKDIR_MASK       0x00008000
+-#define VLYNQ_CTL_CLKDIV_MASK       0x00070000
+-#define VLYNQ_CTL_MODE_MASK         0x00e00000
+-
+-
+-#define VLYNQ_STS_LINK_MASK         0x00000001  /* Link is active */
+-#define VLYNQ_STS_MPEND_MASK        0x00000002  /* Pending master requests */
+-#define VLYNQ_STS_SPEND_MASK        0x00000004  /* Pending slave requests */
+-#define VLYNQ_STS_NFEMPTY0_MASK     0x00000008  /* Master data FIFO not empty */
+-#define VLYNQ_STS_NFEMPTY1_MASK     0x00000010  /* Master command FIFO not empty */
+-#define VLYNQ_STS_NFEMPTY2_MASK     0x00000020  /* Slave data FIFO not empty */
+-#define VLYNQ_STS_NFEMPTY3_MASK     0x00000040  /* Slave command FIFO not empty */
+-#define VLYNQ_STS_LERROR_MASK       0x00000080  /* Local error, w/c */
+-#define VLYNQ_STS_RERROR_MASK       0x00000100  /* remote error w/c */
+-#define VLYNQ_STS_OFLOW_MASK        0x00000200
+-#define VLYNQ_STS_IFLOW_MASK        0x00000400
+-#define VLYNQ_STS_MODESUP_MASK      0x00E00000  /* Highest mode supported */
+-#define VLYNQ_STS_SWIDTH_MASK       0x07000000  /* Used for reading the width of VLYNQ bus */
+-#define VLYNQ_STS_DEBUG_MASK        0xE0000000 
+-
+-#define VLYNQ_CTL_INTVEC_SHIFT      0x08
+-#define VLYNQ_CTL_INTEN_SHIFT       0x0D
+-#define VLYNQ_CTL_INT2CFG_SHIFT     0x07
+-#define VLYNQ_CTL_INTLOCAL_SHIFT    0x0E
+-
+-#define VLYNQ_CTL_INTFIELDS_CLEAR_MASK  0x7F80
+-
+-#define VLYNQ_CHIPVER_DEVREV_MASK   0xffff0000
+-#define VLYNQ_CHIPVER_DEVID_MASK    0x0000ffff
+-
+-#define VLYNQ_IVR_INTEN_MASK        0x80
+-#define VLYNQ_IVR_INTTYPE_MASK      0x40
+-#define VLYNQ_IVR_INTPOL_MASK       0x20
+-
+-
+-/**** Helper macros ****/
+-
+-#define VLYNQ_RESETCB(arg) \
+-   if( pdev->reset_cb != NULL)   \
+-   {                             \
+-      (pdev->reset_cb)(pdev, (arg));  \
+-   }
+-    
+-#define VLYNQ_STATUS_FLD_WIDTH(sts) (((sts) & VLYNQ_STS_SWIDTH_MASK) >> 24 )
+-#define VLYNQ_CTL_INTVEC(x)         (((x) & 31) << 8 )
+-
+-#define VLYNQ_INRANGE(x,hi,lo)      (((x) <= (hi)) && ((x) >= (lo)))
+-#define VLYNQ_OUTRANGE(x,hi,lo)     (((x) > (hi)) || ((x) < (lo)))
+-
+-#define VLYNQ_ALIGN4(x)             (x)=(x)&(~3)   
+-
+-
+-/*************************************
+- *             Enums                 *
+- *************************************/
+-
+-/* Initialization options define what operations are
+- * undertaken during vlynq module initialization */
+-typedef enum
+-{
+-    /* Init host local memory regions.This allows
+-     * local host access remote memory regions */
+-    VLYNQ_INIT_LOCAL_MEM_REGIONS = 0x01,
+-    /* Init host remote memory regions.This allows
+-     * remote device access local memory regions */
+-    VLYNQ_INIT_REMOTE_MEM_REGIONS =0x02,
+-    /* Init local interrupt config*/
+-    VLYNQ_INIT_LOCAL_INTERRUPTS   =0x04,
+-    /* Init remote interrupt config*/
+-    VLYNQ_INIT_REMOTE_INTERRUPTS  =0x08,
+-    /* Check link during initialization*/
+-    VLYNQ_INIT_CHECK_LINK         =0x10,
+-    /* configure clock during init */
+-    VLYNQ_INIT_CONFIG_CLOCK       =0x20,
+-    /* Clear errors during init */    
+-    VLYNQ_INIT_CLEAR_ERRORS       =0x40,
+-    /* All options */
+-    VLYNQ_INIT_PERFORM_ALL        =0x7F
+-}VLYNQ_INIT_OPTIONS;
+-
+-
+-/* VLYNQ_DEV_TYPE identifies local or remote device */
+-typedef enum
+-{
+-    VLYNQ_LOCAL_DVC  = 0,           /* vlynq local device (SOC's vlynq module) */
+-    VLYNQ_REMOTE_DVC = 1            /* vlynq remote device (remote vlynq module) */
+-}VLYNQ_DEV_TYPE;
+-
+-
+-/* VLYNQ_CLK_SOURCE identifies the vlynq module clock source */
+-typedef enum
+-{
+-    VLYNQ_CLK_SOURCE_NONE   = 0,    /* do not initialize clock generator*/
+-    VLYNQ_CLK_SOURCE_LOCAL  = 1,    /* clock is generated by local machine  */
+-    VLYNQ_CLK_SOURCE_REMOTE = 2     /* clock is generated by remote machine */
+-}VLYNQ_CLK_SOURCE;
+-
+-
+-/* VLYNQ_DRV_STATE indicates the current driver state */
+-typedef enum
+-{
+-    VLYNQ_DRV_STATE_UNINIT = 0,     /* driver is uninitialized  */
+-    VLYNQ_DRV_STATE_ININIT = 1,     /* VLYNQ is being initialized */
+-    VLYNQ_DRV_STATE_RUN    = 2,     /* VLYNQ is running properly  */
+-    VLYNQ_DRV_STATE_HOLD   = 3,     /* driver stopped temporarily */
+-    VLYNQ_DRV_STATE_ERROR  = 4      /* driver stopped on unrecoverable error */
+-}VLYNQ_DRV_STATE;
+-
+-
+-/* VLYNQ_BUS_WIDTH identifies the vlynq module bus width */
+-typedef enum
+-{
+-   VLYNQ_BUS_WIDTH_3 =  3,
+-   VLYNQ_BUS_WIDTH_5 =  5,
+-   VLYNQ_BUS_WIDTH_7 =  7,
+-   VLYNQ_BUS_WIDTH_9 =  9
+-}VLYNQ_BUS_WIDTH;
+-
+-
+-/* VLYNQ_LOCAL_INT_CONFIG indicates whether the local vlynq 
+- * interrupts are processed by the host or passed on to the 
+- * remote device.
+- */
+-typedef enum
+-{
+-    VLYNQ_INT_REMOTE = 0,   /* Interrupt packets sent to remote, intlocal=0 */
+-    VLYNQ_INT_LOCAL  = 1    /* Interrupts are handled locally, intlocal=1 */
+-}VLYNQ_LOCAL_INT_CONFIG;        
+-
+-
+-/* VLYNQ_REMOTE_INT_CONFIG indicates whether the remote 
+- * interrupts are to be handled by the SOC system ISR 
+- * or via the vlynq root ISR
+- */
+-typedef enum 
+-{
+-    VLYNQ_INT_ROOT_ISR   = 0,   /* remote ints handled via vlynq root ISR */
+-    VLYNQ_INT_SYSTEM_ISR = 1    /* remote ints handled via system ISR */
+-}VLYNQ_REMOTE_INT_CONFIG;
+-
+-
+-/* VLYNQ_INTR_POLARITY - vlynq interrupt polarity setting */
+-typedef enum
+-{
+-    VLYNQ_INTR_ACTIVE_HIGH = 0,
+-    VLYNQ_INTR_ACTIVE_LOW  = 1
+-}VLYNQ_INTR_POLARITY;
+-
+-
+-/* VLYNQ_INTR_TYPE  - vlynq interrupt type */
+-typedef enum
+-{
+-    VLYNQ_INTR_LEVEL  = 0,
+-    VLYNQ_INTR_PULSED = 1
+-}VLYNQ_INTR_TYPE;
+-
+-
+-/* VLYNQ_RESET_MODE - vlynq reset mode */
+-typedef enum
+-{
+-   VLYNQ_RESET_ASSERT,      /* hold device in reset state */
+-   VLYNQ_RESET_DEASSERT,    /* release device from reset state */
+-   VLYNQ_RESET_INITFAIL,    /* handle the device in case driver initialization fails */
+-   VLYNQ_RESET_LINKESTABLISH,  /* handle the device in case driver established link */
+-   VLYNQ_RESET_INITFAIL2,   /* Driver initialization failed but VLYNQ link exist. */
+-   VLYNQ_RESET_INITOK       /* Driver initialization finished OK. */
+-}VLYNQ_RESET_MODE;
+- 
+-
+-
+-/*************************************
+- *             Typedefs              *
+- *************************************/
+-
+-struct VLYNQ_DEV_t; /*forward declaration*/
+-
+-/*--------Function Pointers defintions -----------*/
+-
+-/* prototype for interrupt handler definition */
+-typedef void (*VLYNQ_INTR_CNTRL_ISR)(void *arg1,void *arg2,void *arg3);
+-
+-typedef void 
+-(*VLYNQ_RESET_REMOTE)(struct VLYNQ_DEV_t *pDev, VLYNQ_RESET_MODE mode);
+-
+-typedef void 
+-(*VLYNQ_REPORT_CB)( struct VLYNQ_DEV_t *pDev,   /* This VLYNQ */
+-                    VLYNQ_DEV_TYPE  aSrcDvc,    /* Event Cause -local/remote? */
+-                    unsigned int  dwStatRegVal);      /* Value of the relevant status register */
+-
+-
+-/*-------Structure Definitions------------*/
+-
+-typedef struct VLYNQ_MEMORY_MAP_t
+-{
+-    unsigned int Txmap;
+-    unsigned int RxOffset[VLYNQ_MAX_MEMORY_REGIONS];
+-    unsigned int RxSize[VLYNQ_MAX_MEMORY_REGIONS];
+-}VLYNQ_MEMORY_MAP;
+-
+-
+-/**VLYNQ_INTERRUPT_CNTRL - defines the vlynq module interrupt
+- * settings in vlynq Control register  */ 
+-typedef struct VLYNQ_INTERRUPT_CNTRL_t
+-{
+-    /* vlynq interrupts handled by host or remote - maps to 
+-     * intLocal bit in vlynq control register */
+-    VLYNQ_LOCAL_INT_CONFIG intLocal;
+-
+-    /* remote interrupts handled by vlynq isr or host system
+-     * interrupt controller - maps to the int2Cfg in vlynq 
+-     * control register */
+-    VLYNQ_REMOTE_INT_CONFIG intRemote;
+-    
+-    /* bit in pending/set register used for module interrupts*/
+-    unsigned int map_vector;
+-    
+-    /* used only if remote interrupts are to be handled by system ISR*/    
+-    unsigned int intr_ptr;
+-
+-}VLYNQ_INTERRUPT_CNTRL;
+-
+-
+-/* VLYNQ_INTR_CNTRL_ICB - defines the Interrupt control block which hold
+- * the interrupt dispatch table. The vlynq_root_isr() indexes into this 
+- * table to identify the ISR to be invoked
+- */
+-typedef struct VLYNQ_INTR_CNTRL_ICB_t
+-{
+-    VLYNQ_INTR_CNTRL_ISR            isr;    /* Clear errors during initialization */
+-    void                            *arg1 ; /* Arg 1 for the ISR */
+-    void                            *arg2 ; /* Arg 2 for the ISR */
+-    void                            *arg3 ; /* Arg 3 for the ISR */
+-    unsigned int  isrCount; /* number of ISR invocations so far */
+-    struct VLYNQ_INTR_CNTRL_ICB_t   *next;
+-}VLYNQ_INTR_CNTRL_ICB;
+-
+-/* overlay of vlynq register set */
+-typedef struct VLYNQ_REG_SET_t
+-{
+-    unsigned int revision; /*offset : 0x00 */
+-    unsigned int control;  /* 0x04*/
+-    unsigned int status;   /* 0x08*/
+-    unsigned int pad1;     /* 0x0c*/
+-    unsigned int intStatus;   /*0x10*/
+-    unsigned int intPending;  /*0x14*/
+-    unsigned int intPtr;      /*0x18*/
+-    unsigned int txMap;       /*0x1C*/ 
+-    unsigned int rxSize1;     /*0x20*/
+-    unsigned int rxOffset1;   /*0x24*/
+-    unsigned int rxSize2;     /*0x28*/
+-    unsigned int rxOffset2;   /*0x2C*/
+-    unsigned int rxSize3;     /*0x30*/
+-    unsigned int rxOffset3;   /*0x34*/
+-    unsigned int rxSize4;     /*0x38*/
+-    unsigned int rxOffset4;   /*0x3C*/
+-    unsigned int chipVersion; /*0x40*/
+-    unsigned int pad2[8];
+-    unsigned int ivr30;       /*0x60*/
+-    unsigned int ivr74;       /*0x64*/
+-    unsigned int pad3[7];
+-}VLYNQ_REG_SET;
+-    
+-
+-typedef struct VLYNQ_DEV_t
+-{
+-    /** module index:1,2,3... used for debugging purposes */
+-    unsigned int dev_idx; 
+-    
+-    /*VLYNQ module base address */
+-    unsigned int module_base;
+-   
+-    /* clock source selection */
+-    VLYNQ_CLK_SOURCE clk_source;
+-   
+-    /* Clock Divider.Val=1 to 8. VLYNQ_clk = VBUSCLK/clk_div */
+-    unsigned int  clk_div;
+-   
+-    /* State of the VLYNQ driver, set to VLYNQ_DRV_STATE_UNINIT, when initializing */
+-    VLYNQ_DRV_STATE state;
+-   
+-    /* Valid VLYNQ bus width, filled by driver  */
+-    VLYNQ_BUS_WIDTH width;
+-   
+-    /* local memory mapping   */
+-    VLYNQ_MEMORY_MAP local_mem;
+-   
+-    /* remote memory mapping   */
+-    VLYNQ_MEMORY_MAP remote_mem;
+-   
+-    /* Local module interrupt params */
+-    VLYNQ_INTERRUPT_CNTRL  local_irq;
+-   
+-    /* remote module interrupt params */
+-    VLYNQ_INTERRUPT_CNTRL  remote_irq;
+-
+-    /*** ICB related fields **/
+-   
+-    /* Sizeof of ICB = VLYNQ_NUM_INT_BITS(for 32 bits in IntPending) + 
+-     * expansion slots for shared interrupts*/
+-    VLYNQ_INTR_CNTRL_ICB  pIntrCB[VLYNQ_NUM_INT_BITS + VLYNQ_IVR_CHAIN_SLOTS];
+-    VLYNQ_INTR_CNTRL_ICB  *freelist;
+-   
+-   /* table holding mapping between intVector and the bit position the interrupt
+-    * is mapped to(mapVector)*/
+-    char vector_map[32];
+-   
+-    /* user callback for vlynq events, NULL if unused */
+-    VLYNQ_REPORT_CB        report_cb;    
+-    
+-   /* user callback for resetting/realeasing remote device */
+-    VLYNQ_RESET_REMOTE     reset_cb;
+-
+-    /*** Handles provided for direct access to register set if need be
+-     * Must be intialized to point to appropriate address during 
+-     * vlynq_init */
+-    volatile VLYNQ_REG_SET * local;
+-    volatile VLYNQ_REG_SET * remote;
+-
+-    unsigned int  intCount; /* number of interrupts generated so far */
+-    unsigned int  isrCount; /* number of ISR invocations so far */
+-}VLYNQ_DEV;
+-
+-
+-typedef struct VLYNQ_ISR_ARGS_t
+-{
+-    int irq;
+-    void * arg;
+-    void * regset;
+-}VLYNQ_ISR_ARGS;
+-
+-
+-/****************************************
+- *        Function Prototypes           *
+- * API exported by generic vlynq driver *
+- ****************************************/
+-/* Initialization function */ 
+-int vlynq_init( VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options);
+-
+-/* Check vlynq link */
+-unsigned int vlynq_link_check( VLYNQ_DEV * pdev);
+-
+-/* Set interrupt vector in local or remote device */
+-int vlynq_interrupt_vector_set( VLYNQ_DEV *pdev, 
+-                                         unsigned int int_vector,
+-                                         unsigned int map_vector, 
+-                                         VLYNQ_DEV_TYPE dev,
+-                                         VLYNQ_INTR_POLARITY pol,
+-                                         VLYNQ_INTR_TYPE type);
+-
+-
+-int vlynq_interrupt_vector_cntl( VLYNQ_DEV *pdev,
+-                                          unsigned int int_vector,
+-                                          VLYNQ_DEV_TYPE dev,
+-                                          unsigned int enable);
+-
+-unsigned int vlynq_interrupt_get_count( VLYNQ_DEV *pdev,
+-                                         unsigned int map_vector);
+-
+-int vlynq_install_isr( VLYNQ_DEV *pdev,
+-                                unsigned int map_vector,
+-                                VLYNQ_INTR_CNTRL_ISR isr,
+-                                void *arg1, void *arg2, void *arg3);
+-
+-int vlynq_uninstall_isr( VLYNQ_DEV *pdev,
+-                                  unsigned int map_vector,
+-                                  void *arg1, void *arg2, void *arg3);
+-
+-
+-void vlynq_root_isr(void *arg);
+-
+-void vlynq_delay(unsigned int clktime);
+-
+-/* The following functions, provide better granularity in setting
+- * interrupt parameters. (for better support of linux INT Controller)
+- * Note: The interrupt source is identified by "map_vector"- the bit 
+- * position in interrupt status register*/
+-
+-int vlynq_interrupt_vector_map(VLYNQ_DEV * pdev,
+-                                        VLYNQ_DEV_TYPE dev,
+-                                        unsigned int int_vector,
+-                                        unsigned int map_vector);
+-
+-int vlynq_interrupt_set_polarity(VLYNQ_DEV * pdev,
+-                                          VLYNQ_DEV_TYPE dev,
+-                                          unsigned int map_vector,
+-                                          VLYNQ_INTR_POLARITY pol);
+-
+-int vlynq_interrupt_get_polarity( VLYNQ_DEV *pdev ,
+-                                           VLYNQ_DEV_TYPE dev_type,
+-                                           unsigned int map_vector);
+-
+-int vlynq_interrupt_set_type(VLYNQ_DEV * pdev,
+-                                      VLYNQ_DEV_TYPE dev,
+-                                      unsigned int map_vector,
+-                                      VLYNQ_INTR_TYPE type);
+-
+-int vlynq_interrupt_get_type( VLYNQ_DEV *pdev, 
+-                                       VLYNQ_DEV_TYPE dev_type,
+-                                       unsigned int map_vector);
+-
+-int vlynq_interrupt_enable(VLYNQ_DEV* pdev,
+-                                    VLYNQ_DEV_TYPE dev,
+-                                    unsigned int map_vector);
+-
+-int vlynq_interrupt_disable(VLYNQ_DEV * pdev,
+-                                     VLYNQ_DEV_TYPE dev,
+-                                     unsigned int map_vector);
+-                 
+-
+-              
+-        
+-
+-#endif /* _VLYNQ_HAL_H_ */
+diff -urN linux-2.4.32/include/asm-mips/ar7/vlynq_hal.h linux-2.4.32.new/include/asm-mips/ar7/vlynq_hal.h
+--- linux-2.4.32/include/asm-mips/ar7/vlynq_hal.h	2005-12-29 11:23:32.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/ar7/vlynq_hal.h	2005-12-27 21:44:16.000000000 +0100
+@@ -598,9 +598,8 @@
+ GLOBAL INT32 vlynq_interrupt_disable(VLYNQ_DEV * pdev,
+                                      VLYNQ_DEV_TYPE dev,
+                                      UINT32 map_vector);
+-                 
+ 
+-              
+-        
++/* vlynq_drv.h */
++extern VLYNQ_DEV vlynqDevice0, vlynqDevice1;
+ 
+ #endif /* _VLYNQ_HAL_H_ */
+diff -urN linux-2.4.32/include/asm-mips/bootinfo.h linux-2.4.32.new/include/asm-mips/bootinfo.h
+--- linux-2.4.32/include/asm-mips/bootinfo.h	2005-12-29 11:23:22.000000000 +0100
++++ linux-2.4.32.new/include/asm-mips/bootinfo.h	2005-12-27 21:46:52.000000000 +0100
+@@ -37,6 +37,8 @@
+ #define MACH_GROUP_HP_LJ       20 /* Hewlett Packard LaserJet               */
+ #define MACH_GROUP_LASAT       21
+ #define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
++#define MACH_GROUP_AR531X      23 /* Atheros AR531X                         */
++#define MACH_GROUP_AR7         24 /* TI AR7 (Sangam) based Boards           */
+ 
+ /*
+  * Valid machtype values for group unknown (low order halfword of mips_machtype)
+@@ -201,6 +203,23 @@
+  */
+ #define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
+ 
++/*
++ * Valid machtype for group AR7 (SANGAM)
++ */
++#define MACH_AR7_ADAM2          0       /* ADAM2 based Boards */
++#define MACH_AR7_SINUS154       1       /* Sinus 154 DSL Basic SE / Basic 3 */
++
++/*
++ * Valid machtype for group MACH_GROUP_AR5312
++ */
++#define MACH_ATHEROS_UNUSED     0
++#define MACH_ATHEROS_AP30       1       /* AP30 */
++#define MACH_ATHEROS_AP33	2       /* AP33 */
++#define MACH_ATHEROS_AP38       3       /* AP38 */
++#define MACH_ATHEROS_AP43       4       /* AP43 */
++#define MACH_ATHEROS_AP48       5       /* AP48 */
++#define MACH_ATHEROS_PB32       6       /* PB32 */
++
+ #define CL_SIZE			(256)
+ 
+ const char *get_system_type(void);
+diff -urN linux-2.4.32/net/core/wireless.c linux-2.4.32.new/net/core/wireless.c
+--- linux-2.4.32/net/core/wireless.c	2003-11-28 19:26:21.000000000 +0100
++++ linux-2.4.32.new/net/core/wireless.c	2005-12-27 21:44:16.000000000 +0100
+@@ -474,6 +474,8 @@
+ 	/* Check if there is enough buffer up there */
+ 	if(iwr->u.data.length < dev->wireless_handlers->num_private_args) {
+ 		printk(KERN_ERR "%s (WE) : Buffer for request SIOCGIWPRIV too small (%d<%d)\n", dev->name, iwr->u.data.length, dev->wireless_handlers->num_private_args);
++		/* Give wireless tools a hint. */
++		iwr->u.data.length = dev->wireless_handlers->num_private_args;
+ 		return -E2BIG;
+ 	}
+ #endif	/* WE_STRICT_WRITE */
Index: target/linux/image/ar7/src/gzip.h
===================================================================
--- target/linux/image/ar7/src/gzip.h	(Revision 2793)
+++ target/linux/image/ar7/src/gzip.h	(Arbeitskopie)
@@ -14,25 +14,12 @@
 typedef unsigned long  ulg;
 
 
-static char *output_data;
-static ulg output_ptr;
-
 #ifndef NULL
 #define NULL 0
 #endif
 
 #define NOMEMCPY                /* Does routine memcpy exist? */
 
-//bvb static uch *inbuf;		/* input buffer */
-static uch *window;
-
-//bvb static uch outwin[WSIZE];
-
-//bvb static unsigned insize;		/* valid bytes in inbuf */
-static unsigned inptr;		/* index of next byte to process in inbuf */
-
-static unsigned outcnt;		/* bytes in output buffer */
-
 /* gzip flag byte */
 #define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
 #define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
@@ -46,6 +33,3 @@
 #define BMAX 16         /* maximum bit length of any code (16 for explode) */
 #define N_MAX 288       /* maximum number of codes in any set */
 
-static char *input_data;
-
-static void *freememstart;
Index: target/linux/image/ar7/src/uart16550.h
===================================================================
--- target/linux/image/ar7/src/uart16550.h	(Revision 0)
+++ target/linux/image/ar7/src/uart16550.h	(Revision 0)
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _uart16550_h_
+#define _uart16550_h_
+
+typedef         unsigned char uint8;
+typedef         unsigned int  uint32;
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_DATA_5BIT             0x0
+#define         UART16550_DATA_6BIT             0x1
+#define         UART16550_DATA_7BIT             0x2
+#define         UART16550_DATA_8BIT             0x3
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 stop);
+
+/* blocking call */
+uint8 Uart16550GetPoll(void);
+
+void Uart16550Put(uint8 byte);
+void Uart16550Puts(const char *string);
+
+#endif
Index: target/linux/image/ar7/src/entry.c
===================================================================
--- target/linux/image/ar7/src/entry.c	(Revision 0)
+++ target/linux/image/ar7/src/entry.c	(Revision 0)
@@ -0,0 +1,18 @@
+#include "loader.h"
+
+#if defined(CONFIG_MIPS_SINUS154)
+static const char *Argv[] = {
+	"xxx",
+	0
+};
+#endif
+
+// tikernelunzip is the entry point and must be the only function here!
+int tikernelunzip(int argc, const char *argv[], const char *arge[])
+{
+#if defined(CONFIG_MIPS_SINUS154)
+	argc = 1;
+	argv = Argv;
+#endif
+	return tikernelunzip2(argc, argv, arge);
+}
Index: target/linux/image/ar7/src/loader.c
===================================================================
--- target/linux/image/ar7/src/loader.c	(Revision 2793)
+++ target/linux/image/ar7/src/loader.c	(Arbeitskopie)
@@ -15,24 +15,46 @@
 #include <linux/config.h>
 #include "gzip.h"
 #include "LzmaDecode.h"
+#include "loader.h"
+#if defined(NO_FIRMWARE)
+#include "uart16550.h"
+#endif
 
 /* Function prototypes */
-unsigned char get_byte(void);
-int tikernelunzip(int,char *[], char *[]);
 static int tidecompress(uch *, uch *);
+#if defined(DEBUG)
+static void print_i(int i);
+#endif
+static void print_s(const char *ptr);
+#define printf(s) print_s(s)
 
-void kernel_entry(int, char *[], char *[]);
-void (*ke)(int, char *[], char *[]); /* Gen reference to kernel function */
-void (*prnt)(unsigned int, char *);		/* Gen reference to Yamon print function */
-void printf(char *ptr);			/* Generate our own printf */
+extern void kernel_entry(int, char *[], char *[]);
+extern unsigned int workspace;
+extern unsigned char kernelimage[], kernelimage_end[];
 
-int tikernelunzip(int argc, char *argv[], char *arge[])
+static unsigned char *input_data;
+
+static inline unsigned char get_byte(void)
 {
-	extern unsigned int _ftext;
-	extern uch kernelimage[];
+	unsigned char c;
+	
+	c = *input_data;
+	input_data++;
+
+	return c;
+}
+
+int tikernelunzip2(int argc, const char *argv[], const char *arge[])
+{
 	uch *in, *out;
 	int status;
 
+#if defined(DEBUG)
+	printf("argc = "); print_i(argc); printf("\n");
+	printf("argv = "); print_i((int)argv); printf("\n");
+	printf("arge = "); print_i((int)arge); printf("\n");
+#endif
+	
 	printf("Launching kernel decompressor.\n");
 
 	out = (unsigned char *) LOADADDR;
@@ -41,11 +63,11 @@
 	status = tidecompress(in, out);
 
 	if (status == 0) {
+		/* Gen reference to kernel function */
+		void (*ke)(int, const char *[], const char *[]) =
+			(void(*)(int, const char *[], const char*[]))kernel_entry;
 		printf("Kernel decompressor was successful ... launching kernel.\n");
-
-		ke = ( void(*)(int, char *[],char*[]))kernel_entry;
 		(*ke)(argc,argv,arge);
-
 		return (0);
 	} else {
 		printf("Error in decompression.\n");
@@ -53,9 +75,9 @@
 	}
 }
 
-#if 0
-char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
-void print_i(int i)
+#if defined(DEBUG)
+static const char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+static void print_i(int i)
 {
 	int j;
 	char buf[11];
@@ -63,7 +85,7 @@
 	buf[0] = '0';
 	buf[1] = 'x';
 	buf[10] = 0;
-	
+
 	for (j = 0; j < 8; j++)
 	{
 		buf[2 + 7 - j] = hex[i & 0xf];
@@ -74,10 +96,8 @@
 }
 #endif
 
-int tidecompress(uch *indata, uch *outdata)
+static int tidecompress(uch *indata, uch *outdata)
 {
-	extern unsigned int workspace;
-	extern unsigned char kernelimage[], kernelimage_end[];
 	unsigned int i;  /* temp value */
 	unsigned int lc; /* literal context bits */
 	unsigned int lp; /* literal pos state bits */
@@ -87,8 +107,6 @@
 	unsigned int insize = kernelimage_end - kernelimage;
 	int status;
 	
-	output_ptr = 0;
-	output_data = outdata;
 	input_data = indata;
 
 	/* lzma args */
@@ -114,27 +132,25 @@
 	wsize = (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp))) * sizeof(CProb);
 
 	if ((status = LzmaDecode((unsigned char *) &workspace, wsize, lc, lp, pb,
-		indata + 13, insize - 13, (unsigned char *) output_data, osize, &i)) == LZMA_RESULT_OK)
+		indata + 13, insize - 13, outdata, osize, &i)) == LZMA_RESULT_OK)
 			return 0;
 
 	return status;
 }
 
-
-void printf(char *ptr)
+static void print_s(const char *ptr)
 {
+#if defined(NO_FIRMWARE)
+	while (*ptr) {
+		if (*ptr == '\n') {
+			Uart16550Put('\r');
+		}
+		Uart16550Put(*ptr);
+		ptr++;
+	}
+#else
 	unsigned int *tempptr = (unsigned int  *)0x90000534;
 	prnt = ( void (*)(unsigned int, char *)) *tempptr;
 	(*prnt)(0,ptr);
+#endif
 }
-
-unsigned char get_byte()
-{
-	unsigned char c;
-	
-	c = *input_data;
-	input_data++;
-
-	return c;
-}
-
Index: target/linux/image/ar7/src/LzmaDecode.c
===================================================================
--- target/linux/image/ar7/src/LzmaDecode.c	(Revision 2793)
+++ target/linux/image/ar7/src/LzmaDecode.c	(Arbeitskopie)
@@ -45,7 +45,7 @@
   int ExtraBytes;
 } CRangeDecoder;
 
-Byte RangeDecoderReadByte(CRangeDecoder *rd)
+static Byte RangeDecoderReadByte(CRangeDecoder *rd)
 {
   if (rd->Buffer == rd->BufferLim)
   {
@@ -66,7 +66,7 @@
 /* #define ReadByte (*rd->Buffer++) */
 #define ReadByte (RangeDecoderReadByte(rd))
 
-void RangeDecoderInit(CRangeDecoder *rd,
+static void RangeDecoderInit(CRangeDecoder *rd,
   #ifdef _LZMA_IN_CB
     ILzmaInCallback *inCallback
   #else
@@ -93,7 +93,7 @@
 #define RC_FLUSH_VAR rd->Range = range; rd->Code = code;
 #define RC_NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | ReadByte; }
 
-UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
+static UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
 {
   RC_INIT_VAR
   UInt32 result = 0;
@@ -121,7 +121,7 @@
   return result;
 }
 
-int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
+static int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
 {
   UInt32 bound = (rd->Range >> kNumBitModelTotalBits) * *prob;
   if (rd->Code < bound)
@@ -159,7 +159,7 @@
 
 #define RC_GET_BIT(prob, mi) RC_GET_BIT2(prob, mi, ; , ;)               
 
-int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+static int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
 {
   int mi = 1;
   int i;
@@ -181,7 +181,7 @@
   return mi - (1 << numLevels);
 }
 
-int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+static int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
 {
   int mi = 1;
   int i;
@@ -206,7 +206,7 @@
   return symbol;
 }
 
-Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
+static Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
 { 
   int symbol = 1;
   #ifdef _LZMA_LOC_OPT
@@ -228,7 +228,7 @@
   return symbol;
 }
 
-Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
+static Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
 { 
   int symbol = 1;
   #ifdef _LZMA_LOC_OPT
@@ -286,7 +286,7 @@
 #define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
 #define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
 
-int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
+static int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
 {
   if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
     return RangeDecoderBitTreeDecode(p + LenLow +
Index: target/linux/image/ar7/src/loader.h
===================================================================
--- target/linux/image/ar7/src/loader.h	(Revision 0)
+++ target/linux/image/ar7/src/loader.h	(Revision 0)
@@ -0,0 +1,4 @@
+// tikernelunzip is the entry point (first function) of the boot loader.
+int tikernelunzip(int argc, const char *argv[], const char *arge[]);
+
+int tikernelunzip2(int argc, const char *argv[], const char *arge[]);
Index: target/linux/image/ar7/src/uart16550.c
===================================================================
--- target/linux/image/ar7/src/uart16550.c	(Revision 0)
+++ target/linux/image/ar7/src/uart16550.c	(Revision 0)
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+
+#include "uart16550.h"
+
+/* === CONFIG === */
+
+#define         BASE                   	0xa8610E00
+#define         MAX_BAUD                1152000
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+
+/* memory-mapped read/write of the port */
+#define         UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))
+#define         UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) = z)
+
+#define DEBUG_LED (*(unsigned short*)0xb7ffffc0)
+#define OutputLED(x)  (DEBUG_LED = x)
+
+void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 stop)
+{
+    /* disable interrupts */
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    /* set up baud rate */
+    { 
+        uint32 divisor;
+       
+        /* set DIAB bit */
+        UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+        
+        /* set divisor */
+        divisor = MAX_BAUD / baud;
+        UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);
+        UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);
+
+        /* clear DIAB bit */
+        UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
+    }
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);
+}
+
+uint8 Uart16550GetPoll()
+{
+    while((UART16550_READ(OFS_LINE_STATUS) & 0x1) == 0);
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void Uart16550Put(uint8 byte)
+{
+    while ((UART16550_READ(OFS_LINE_STATUS) &0x20) == 0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void Uart16550Puts(const char *string)
+{
+	while (*string) {
+		if (*string == '\n') {
+			Uart16550Put('\r');
+		}
+		Uart16550Put(*string);
+		string++;
+	}
+}
Index: target/linux/image/ar7/Makefile
===================================================================
--- target/linux/image/ar7/Makefile	(Revision 2793)
+++ target/linux/image/ar7/Makefile	(Arbeitskopie)
@@ -5,7 +5,11 @@
 PKG_BUILD_DIR:=$(BUILD_DIR)/ar7loader
 
 ifeq ($(IB),)
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+LOADADDR := 0x94000000
+else
 LOADADDR := 0x94020000
+endif
 KERNEL_ENTRY := 0x${shell nm $(KDIR)/linux-$(KERNEL)*/vmlinux | grep kernel_entry | cut -d' ' -f1}
 OUTPUT_FORMAT := elf32-tradlittlemips
 
@@ -15,6 +19,9 @@
 	-mabi=32 -march=mips32 -Wa,-32 -Wa,-march=mips32 -Wa,-mips32 -Wa,--trap \
 	-DLOADADDR=$(LOADADDR)
 
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+CFLAGS += -DNO_FIRMWARE
+endif
 
 $(PKG_BUILD_DIR):
 	mkdir -p $(PKG_BUILD_DIR)
@@ -27,12 +34,26 @@
 	sed -e 's/@@OUTPUT_FORMAT@@/$(OUTPUT_FORMAT)/' \
 	    -e 's/@@LOADADDR@@/$(LOADADDR)/' <$< >$@
 
+$(PKG_BUILD_DIR)/entry.o: src/entry.c
+	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
+
 $(PKG_BUILD_DIR)/LzmaDecode.o: src/LzmaDecode.c
 	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
 
 $(PKG_BUILD_DIR)/loader.o: src/loader.c
 	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
 
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+$(PKG_BUILD_DIR)/uart16550.o: src/uart16550.c
+	$(TARGET_CC) $(CFLAGS) -c -o $@ $<
+endif
+
+loader_objects := $(PKG_BUILD_DIR)/entry.o $(PKG_BUILD_DIR)/loader.o
+loader_objects += $(PKG_BUILD_DIR)/LzmaDecode.o
+ifeq ($(BR2_LINUX_2_4_SINUS154),y)
+loader_objects += $(PKG_BUILD_DIR)/uart16550.o
+endif
+
 $(STAGING_DIR)/bin/srec2bin: src/srec2bin.c
 	$(HOSTCC) -o $@ $<
 
@@ -42,19 +63,22 @@
 $(KDIR)/vmlinux.bin: $(KDIR)/vmlinux.lzma compile
 	$(TARGET_CROSS)ld -T $(PKG_BUILD_DIR)/zimage.script -r -b binary $< -o $(KDIR)/zimage.o
 	$(TARGET_CROSS)ld -static -G 0 --defsym kernel_entry=$(KERNEL_ENTRY) -T $(PKG_BUILD_DIR)/ld.script \
-		$(PKG_BUILD_DIR)/loader.o \
-		$(PKG_BUILD_DIR)/LzmaDecode.o \
+		$(loader_objects) \
 		$(KDIR)/zimage.o \
 		-o $(KDIR)/loader
 	$(TARGET_CROSS)objcopy -O srec $(KDIR)/loader $(KDIR)/ram_zimage.sre
 	$(STAGING_DIR)/bin/srec2bin $(KDIR)/ram_zimage.sre $@
 	
 $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin: $(KDIR)/vmlinux.bin 
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.raw: $(KDIR)/vmlinux.bin
 endif
 
 $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin:
 	cp $(KDIR)/vmlinux.bin $@
 
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.raw:
+	$(TARGET_CROSS)objcopy -O binary $(KDIR)/loader $@
+
 ifeq ($(FS),jffs2-8MB)
 ALIGN:=bs=131072 conv=sync
 endif
@@ -74,12 +98,14 @@
 install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-$(FS)-$(1).bin
 endef
 
+ifeq ($(BR2_LINUX_2_4_WAX),y)
 $(eval $(call pattern_template,AG1B))
 $(eval $(call pattern_template,WA22))
 $(eval $(call pattern_template,WAG2))
 $(eval $(call pattern_template,WA21))
 $(eval $(call pattern_template,WA31,-b))
 $(eval $(call pattern_template,WA32,-b))
+endif
 
 ifeq ($(IB),)
 clean:
@@ -87,14 +113,49 @@
 	rm -f $(BIN_DIR)/openwrt-$(BOARD)*
 
 prepare: $(PKG_BUILD_DIR) $(PKG_BUILD_DIR)/zimage.script $(PKG_BUILD_DIR)/ld.script
-compile: prepare $(PKG_BUILD_DIR)/loader.o $(PKG_BUILD_DIR)/LzmaDecode.o $(STAGING_DIR)/bin/srec2bin
+compile: prepare $(loader_objects) $(STAGING_DIR)/bin/srec2bin
 else
 clean:
 prepare:
 compile:
 endif
 
-install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-$(FS).bin
+ifeq ($(BR2_LINUX_2_4_WAX),y)
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.bin
+endif
+ifeq ($(BR2_LINUX_$(subst .,_,$(KERNEL))_SINUS154),y)
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel.raw
+endif
+
+define sinus_template
+# kernel image
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-$(1).bin: $(KDIR)/vmlinux
+	rm -f /tmp/soho.???
+	ln -s $(KDIR)/vmlinux /tmp/soho.bin
+	zip -9Xv /tmp/soho.zip -j /tmp/soho.bin
+	mkfirm -o $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-$(1).bin -m $(2) /tmp/soho.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-kernel-$(1).bin
+# filesystem image
+$(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-squashfs-$(1).bin: $(KDIR)/root.squashfs
+	rm -f /tmp/pfs.???
+	#echo "PFS/0.9" | cat - /dev/zero | dd of=/tmp/pfs.img bs=65536 count=1
+	cat $(TOPDIR)/PFS.IMG /dev/zero | dd of=/tmp/pfs.img bs=65536 count=1
+	zip -9Xv /tmp/pfstmp.zip -j /tmp/pfs.img
+	cat /tmp/pfstmp.zip /dev/zero | dd of=/tmp/pfs.zip bs=65536 count=1
+	cat $(KDIR)/root.squashfs >>/tmp/pfs.zip
+	mkfirm -o $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-squashfs-$(1).bin -m $(2) /tmp/pfs.zip
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-squashfs-$(1).bin
+endef
+
+ifeq ($(BR2_LINUX_$(subst .,_,$(KERNEL))_SINUS154_DSL_BASIC_SE),y)
+$(eval $(call sinus_template,SINUS154_DSL_BASIC_SE,BRN154BAS))
+endif
+ifeq ($(BR2_LINUX_$(subst .,_,$(KERNEL))_SINUS154_DSL_BASIC_3),y)
+$(eval $(call sinus_template,SINUS154_DSL_BASIC_3,BRNDTBAS3))
+endif
+
+install: $(BIN_DIR)/openwrt-$(BOARD)-$(KERNEL)-$(FS).bin
+
 install-ib:
 	mkdir -p $(IB_DIR)/build_$(ARCH)/linux-$(KERNEL)-$(BOARD)
 	cp -fpR $(KDIR)/vmlinux.bin $(IB_DIR)/build_$(ARCH)/linux-$(KERNEL)-$(BOARD)/
Index: target/linux/Config.in
===================================================================
--- target/linux/Config.in	(Revision 2793)
+++ target/linux/Config.in	(Arbeitskopie)
@@ -3,7 +3,7 @@
 	
 config BR2_LINUX_2_4_BRCM
 	bool "Support for Broadcom based routers [2.4]"
-	default y
+	# default y
 	depends BR2_mipsel
 	select BR2_LINUX_PCMCIA_SUPPORT
 	help
@@ -16,14 +16,14 @@
 
 config BR2_LINUX_2_4_AR7
 	bool "Support for TI AR7 based devices [2.4]"
-	default n
+	# default n
 	depends BR2_mipsel
 	help
 	  Build firmware images for TI AR7 based routers (w.g. Linksys WAG54G v2)
 
 config BR2_LINUX_2_4_X86
 	bool "Support for x86 boards [2.4]"
-	default n
+	# default n
 	depends BR2_i386
 	select BR2_LINUX_PCMCIA_SUPPORT
 	help
@@ -32,7 +32,7 @@
 
 config BR2_LINUX_2_6_BRCM
 	bool "Support for Broadcom based routers [2.6]"
-	default n
+	# default n
 	depends BR2_mipsel
 	select BR2_LINUX_PCMCIA_SUPPORT
 	help
@@ -41,7 +41,7 @@
 
 config BR2_LINUX_2_6_X86
 	bool "Support for x86 boards [2.6]"
-	default n
+	# default n
 	depends BR2_i386
 	select BR2_LINUX_PCMCIA_SUPPORT
 	help
@@ -50,7 +50,7 @@
 
 config BR2_LINUX_2_4_AR531X
 	bool "Support for Atheros ar531x based APs"
-	default n
+	# default n
 	depends BR2_mips
 	help
 	  Build firmware images for Atheros ar531x based boards
@@ -65,6 +65,43 @@
 	depends BR2_LINUX_2_4_X86 || BR2_LINUX_2_4_BRCM || BR2_LINUX_2_6_X86 || BR2_LINUX_2_6_BRCM
 
 
+
+choice
+	prompt "Device selection"
+
+	config BR2_LINUX_2_4_WAX
+		bool "Support for Linksys boards"
+		depends BR2_LINUX_2_4_AR7
+		help
+		  Build firmware images for AG1B, WA22, WAG2, WA21, WA32
+	
+	config BR2_LINUX_2_4_SINUS154
+		bool "Support for Sinus 154 boards"
+		depends BR2_LINUX_2_4_AR7
+		#select BUSYBOX_CONFIG_CMP
+		#select BUSYBOX_CONFIG_OD
+		#select BUSYBOX_CONFIG_RX
+		help
+		  Build firmware images for Sinus 154 DSL Basic SE and Sinus 154 DSL Basic 3
+	
+endchoice
+
+comment "Device variants"
+
+	config BR2_LINUX_2_4_SINUS154_DSL_BASIC_SE
+		bool "Support for Sinus 154 DSL Basic SE"
+		default y
+		depends BR2_LINUX_2_4_SINUS154
+		help
+		  Build firmware image for Sinus 154 DSL Basic SE
+	
+	config BR2_LINUX_2_4_SINUS154_DSL_BASIC_3
+		bool "Support for Sinus 154 DSL Basic 3"
+		default n
+		depends BR2_LINUX_2_4_SINUS154
+		help
+		  Build firmware image for Sinus 154 DSL Basic 3
+	
 comment "Device specific modules"
 
 config BR2_PACKAGE_KMOD_BRCM_ET
Index: package/Config.in
===================================================================
--- package/Config.in	(Revision 2793)
+++ package/Config.in	(Arbeitskopie)
@@ -131,6 +131,7 @@
 source "package/srelay/Config.in"
 source "package/tmsnc/Config.in"
 source "package/tcpdump/Config.in"
+#source "package/tiap/Config.in"
 source "package/tinc/Config.in"
 source "package/tor/Config.in"
 source "package/ttcp/Config.in"
Index: package/base-files/default/www/index.html
===================================================================
--- package/base-files/default/www/index.html	(Revision 0)
+++ package/base-files/default/www/index.html	(Revision 0)
@@ -0,0 +1,8 @@
+<html>
+<head>
+<title>Sinus 154 DSL Basic SE</title>
+</head>
+<body>
+Web server is running...
+</body>
+</html>
Index: package/base-files/default/www/README
===================================================================
--- package/base-files/default/www/README	(Revision 0)
+++ package/base-files/default/www/README	(Revision 0)
@@ -0,0 +1 @@
+This is the document root of the web server.
Index: package/base-files/default/usr/sbin/nvram
===================================================================
--- package/base-files/default/usr/sbin/nvram	(Revision 0)
+++ package/base-files/default/usr/sbin/nvram	(Revision 0)
@@ -0,0 +1,31 @@
+#/bin/sh
+
+#failsafe=1
+#dhcp_start=192.168.2.2
+#dhcp_num=
+lan_proto=static
+lan_hwaddr=00:30:f1:df:5f:55
+lan_ifname=eth0
+lan_ipaddr=192.168.2.1
+#lan_netmask=
+#lan_gateway=
+lan_dns=192.168.2.1
+wan_hostname=sinus154
+wan_proto=none
+wan_ifname=
+wifi_proto=none
+no_root_swap=1
+#static_route=
+
+if [ -f /dev/mtdblock/3 ]; then
+  eval $(strings /dev/mtdblock/3 | fgrep =)
+fi
+
+[ -w /dev/tty ] && echo $0 $@ >/dev/tty
+
+case $1 in
+	get) eval "echo \${$2:-\${DEFAULT_$2}}";;
+	*);;
+esac
+
+# eof

Eigenschaftsnderungen: package/base-files/default/usr/sbin/nvram
___________________________________________________________________
Name: svn:executable
   + *

Index: package/base-files/default/etc/init.d/S40network
===================================================================
--- package/base-files/default/etc/init.d/S40network	(Revision 2793)
+++ package/base-files/default/etc/init.d/S40network	(Arbeitskopie)
@@ -3,10 +3,10 @@
 [ "$FAILSAFE" != "true" -a -e /etc/config/network ] && . /etc/config/network
 case "$1" in
   start|restart)
-#    ifup lan
-#    ifup wan
-#    ifup wifi
-#    wifi up
+    ifup lan
+    ifup wan
+    ifup wifi
+    [ -x /sbin/wifi ] && wifi up
 
     for route in $(nvram get static_route); do {
       eval "set $(echo $route | sed 's/:/ /g')"
Index: package/base-files/default/etc/init.d/rcS
===================================================================
--- package/base-files/default/etc/init.d/rcS	(Revision 2793)
+++ package/base-files/default/etc/init.d/rcS	(Arbeitskopie)
@@ -1,9 +1,15 @@
 #!/bin/sh
 . /etc/nvram.sh
-syslog_ip=$(nvram get log_ipaddr)
-ipcalc -s "$syslog_ip" || syslog_ip=""
-syslogd -C 16 ${syslog_ip:+-L -R $syslog_ip}
-klogd
+
+mount none /proc -t proc
+mount none /dev -t devfs
+mount none /dev/pts -t devpts
+mount none /tmp -t tmpfs -o nosuid,nodev,mode=1777,size=50%
+
+#syslog_ip=$(nvram get log_ipaddr)
+#ipcalc -s "$syslog_ip" || syslog_ip=""
+#syslogd -C 16 ${syslog_ip:+-L -R $syslog_ip}
+#klogd
 #${FAILSAFE:+telnetd -l /bin/login; ifup lan; exit}
 for i in /etc/init.d/S*; do
   $i start 2>&1
Index: package/base-files/default/etc/TZ
===================================================================
--- package/base-files/default/etc/TZ	(Revision 0)
+++ package/base-files/default/etc/TZ	(Revision 0)
@@ -0,0 +1 @@
+CET-1CEST,M3.5.0,M10.5.0
Index: package/base-files/default/etc/fstab
===================================================================
--- package/base-files/default/etc/fstab	(Revision 0)
+++ package/base-files/default/etc/fstab	(Revision 0)
@@ -0,0 +1,7 @@
+# $Id: fstab $
+/dev/root	/		auto	defaults,errors=continue	0 0
+devfs		/dev		devfs	defaults			0 0
+devpts		/dev/pts	devpts	defaults			0 0
+tmpfs		/dev/shm	tmpfs	defaults			0 0
+proc		/proc		proc	defaults			0 0
+tmpfs		/tmp		tmpfs	defaults,nosuid,nodev,mode=1777,size=50%	0 0
Index: package/base-files/default/etc/profile
===================================================================
--- package/base-files/default/etc/profile	(Revision 2793)
+++ package/base-files/default/etc/profile	(Arbeitskopie)
@@ -8,5 +8,6 @@
 alias vim=vi
 
 arp() { cat /proc/net/arp; }
+hostname() { cat /proc/sys/kernel/hostname; }
 ldd() { LD_TRACE_LOADED_OBJECTS=1 $*; }
 reboot() { ifdown wan 2>&1 >/dev/null ; /sbin/reboot; }
Index: package/base-files/default/etc/preinit.sinus154
===================================================================
--- package/base-files/default/etc/preinit.sinus154	(Revision 0)
+++ package/base-files/default/etc/preinit.sinus154	(Revision 0)
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+set -x
+
+. /etc/nvram.sh
+export PATH=/bin:/sbin:/usr/bin:/usr/sbin
+
+mount /dev
+mount /proc
+mount /tmp
+
+if [ -f /dev/mtdblock/3 ]; then
+  lan_hwaddr=$(hexdump -e "\"\" 6/1 \"%02X:\" \"\\n\"" -n 6 -s 22 /dev/mtdblock/3|sed s/.$//)
+fi
+
+ifup lan
+if arping -c 1 192.168.2.2 -q; then
+	mount -t nfs -o nolock 192.168.2.2:/nfsroot /net
+	pivot_root /net /net/rom
+	[ -x /etc/preinit.net ] && . /etc/preinit.net
+	mount -a
+fi
+
+#mount none /proc -t proc
+#insmod diag
+[ -f /proc/sys/diag ] && echo 0x01 > /proc/sys/diag
+#sleep 1
+if [ -f /proc/sys/reset ] && [ $(cat /proc/sys/reset) = 1 -o "$(nvram get failsafe)" = 1 ]; then
+	export FAILSAFE=true
+	[ "$(nvram get boot_wait)" != "on" ] && {
+		nvram set boot_wait=on
+		nvram commit
+	}
+	while :; do { echo $(((X=(X+1)%8)%2)) > /proc/sys/diag; sleep $((X==0)); } done &
+fi
+
+exec /sbin/init

Eigenschaftsnderungen: package/base-files/default/etc/preinit.sinus154
___________________________________________________________________
Name: svn:executable
   + *

Index: package/Makefile
===================================================================
--- package/Makefile	(Revision 2793)
+++ package/Makefile	(Arbeitskopie)
@@ -206,6 +206,7 @@
 package-$(BR2_PACKAGE_SSMTP) += ssmtp
 package-$(BR2_PACKAGE_SRELAY) += srelay
 package-$(BR2_PACKAGE_STRACE) += strace
+#package-$(BR2_PACKAGE_KMOD_TIAP) += tiap
 package-$(BR2_PACKAGE_TCPDUMP) += tcpdump
 package-$(BR2_PACKAGE_TINC) += tinc
 package-$(BR2_PACKAGE_TOR) += tor
Index: package/busybox/config/Config.in
===================================================================
--- package/busybox/config/Config.in	(Revision 2793)
+++ package/busybox/config/Config.in	(Arbeitskopie)
@@ -12,7 +12,7 @@
 
 choice
 	prompt "Buffer allocation policy"
-	default BUSYBOX_CONFIG_FEATURE_BUFFERS_GO_ON_STACK
+	# default BUSYBOX_CONFIG_FEATURE_BUFFERS_GO_ON_STACK
 	help
 	  There are 3 ways BusyBox can handle buffer allocations:
 	  - Use malloc. This costs code size for the call to xmalloc.
